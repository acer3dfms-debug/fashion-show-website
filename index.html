<!DOCTYPE html> <!-- Tell the browser this is an HTML5 document -->
<html lang="en"> <!-- Root element with language set to English -->
<head>
  <meta charset="utf-8" /> <!-- Use UTF-8 character encoding -->
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" /> <!-- Responsive + use full safe area on iOS -->
  <!-- Make the browser UI bars match the dark theme (iOS Safari honors media-specific theme-color) -->
  <meta name="theme-color" media="(prefers-color-scheme: light)" content="#15171c" />
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#15171c" />
  <meta name="color-scheme" content="dark" />
  <!-- The following two affect iOS only when added to Home Screen (PWA mode) -->
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  <title>Fashion Show</title> <!-- Browser tab title -->
  <style>
    :root { /* CSS variables for theme colors used throughout */
      --bg: #15171c;            /* Dark grey marble base background */
      --runway: #b60c2f;        /* Red carpet color */
      --runway-edge: #f1cf63;   /* Gold accents */
      --accent: #f1cf63;        /* Gold accents for UI */
      --ui: #ffffff;            /* General UI text color */
      --spot: rgba(255,255,255,0.06); /* Soft spotlight color */
      --modal-bg: rgba(0,0,0,0.6);    /* Dim background behind modal */
    }
    html, body {
      margin: 0; height: 100%; background: var(--bg); color: var(--ui); /* Full-height dark background */
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; /* Nice default font stack */
      overflow: hidden; /* Hide scrollbars; camera handles movement */
    }
    #uiBar { /* Top translucent UI bar (fully disabled) */
      position: fixed; left: 0; right: 0; top: 0; height: 0; padding: 0; z-index: 0;
      background: transparent !important;
      display: none !important; /* Completely hide bar and its gradient */
      pointer-events: none;
    }
    #topNav, #uiBar .chip { display: none !important; }
    #uiBar .chip { pointer-events: auto; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); padding: 6px 10px; border-radius: 999px; backdrop-filter: blur(8px); } /* Small pill badges */
    /* Top navigation (click to open sections) */
    #topNav { position: absolute; left: 50%; transform: translateX(-50%); top: 10px; display: flex; gap: 8px; align-items: center; justify-content: center; pointer-events: auto; overflow-x: auto; max-width: 92vw; padding: 2px 6px; } /* Centered, scrollable menu */
    #topNav::-webkit-scrollbar { display: none; } /* Hide   WebKit */
    .navBtn { appearance: none; background: rgba(255,255,255,0.1); color: var(--ui); border: 1px solid rgba(255,255,255,0.2); border-radius: 999px; padding: 6px 10px; white-space: nowrap; cursor: pointer; backdrop-filter: blur(8px); } /* Button styling */
    .navBtn:hover { background: rgba(255,255,255,0.18); } /* Hover state */
    #legend { position: fixed; bottom: 10px; left: 10px; z-index: 5; font-size: 12px; opacity: 0.85; line-height: 1.4; background: rgba(0,0,0,0.35); padding: 8px 28px 8px 10px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.1); max-width: min(92vw, 420px); overflow-wrap: anywhere; } /* On-screen help */
    #legend .legendClose { position: absolute; top: 4px; right: 6px; width: 18px; height: 18px; border-radius: 50%; appearance: none; border: 1px solid rgba(255,255,255,0.35); background: rgba(255,255,255,0.12); color: #fff; font-size: 12px; line-height: 16px; padding: 0; cursor: pointer; display: grid; place-items: center; }
    #legend .legendClose:hover { background: rgba(255,255,255,0.2); }
    #tooltip { position: fixed; padding: 8px 10px; background: rgba(20,20,30,0.9); color: var(--ui); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; pointer-events: none; transform: translate(-50%, -120%); white-space: nowrap; z-index: 4; display: none; } /* Floating hint bubble */
    #hoverTip { position: fixed; padding: 6px 8px; background: rgba(20,20,30,0.9); color: var(--ui); border: 1px solid rgba(255,255,255,0.2); border-radius: 6px; pointer-events: none; transform: translate(10px, -10px); white-space: nowrap; z-index: 6; display: none; font-size: 12px; }
    #modalWrap { position: fixed; inset: 0; display: none; place-items: center; background: var(--modal-bg); backdrop-filter: blur(6px); z-index: 10; } /* Fullscreen modal overlay */
    #modal { width: min(720px, 92vw); max-height: 80vh; overflow: auto; background: #121219; border: 1px solid rgba(255,255,255,0.15); border-radius: 16px; box-shadow: 0 20px 60px rgba(0,0,0,0.6); } /* Modal panel */
    #modal header { display:flex; align-items:center; justify-content:space-between; padding: 14px 16px; border-bottom: 1px solid rgba(255,255,255,0.1); position: sticky; top:0; background:#121219; } /* Sticky modal header */
    #modal .content { padding: 16px; } /* Modal content area */
    #closeModal { appearance: none; background: rgba(255,255,255,0.1); color: var(--ui); border: 1px solid rgba(255,255,255,0.2); border-radius: 10px; padding: 6px 10px; cursor: pointer; } /* Close button */

    /* Mobile controls (optional) */
    #controls { position: fixed; right: 12px; bottom: 12px; display: grid; gap: 8px; z-index: 6; } /* Docked control cluster */
    #controls button { appearance: none; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.08); color: var(--ui); border-radius: 12px; font-size: 14px; padding: 10px 12px; min-width: 44px; backdrop-filter: blur(6px); } /* Tappable buttons */

    /* Paparazzi toggle button (world-anchored near spawn) */
    #paparazziBtn { position: fixed; z-index: 7; appearance: none; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.08); color: var(--ui); border-radius: 999px; font-size: 12px; padding: 6px 10px; backdrop-filter: blur(6px); cursor: pointer; }
    /* Scroll Up control: bubble container with header + slider */
    #scrollWrap { position: fixed; z-index: 7; display: grid; gap: 6px; align-items: center; justify-items: stretch; width: 160px; padding: 10px 12px 12px; border-radius: 14px; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.2); backdrop-filter: blur(6px); }
    #scrollWrap .title { font-size: 11px; color: var(--ui); opacity: 0.95; line-height: 1; }
    #zoomSlider { position: static; width: 100%; accent-color: var(--accent); }
    #zoomSlider, #zoomSlider::-webkit-slider-runnable-track { height: 16px; }
    #zoomSlider::-webkit-slider-runnable-track { border-radius: 999px; background: rgba(255,255,255,0.12); border: 1px solid rgba(255,255,255,0.18); }
    /* Center 28px thumb; nudge slightly down and extend visually with a bottom highlight */
    #zoomSlider::-webkit-slider-thumb { -webkit-appearance: none; width: 28px; height: 28px; border-radius: 50%; background: var(--accent); border: 1px solid rgba(255,255,255,0.2); margin-top: -3px; box-shadow: 0 1px 3px rgba(0,0,0,0.35), 0 2px 0 var(--accent); }
    #zoomSlider::-moz-range-track { height: 16px; border-radius: 999px; background: rgba(255,255,255,0.12); border: 1px solid rgba(255,255,255,0.18); }
    #zoomSlider::-moz-range-thumb { width: 28px; height: 28px; border-radius: 50%; background: var(--accent); border: 1px solid rgba(255,255,255,0.2); box-shadow: 0 1px 3px rgba(0,0,0,0.35); }

    /* Prevent text selection / callout on touch for on-screen controls and HUD */
    #controls, #controls button, #uiBar, #legend, #tooltip, canvas, .navBtn {
      user-select: none;
      -webkit-user-select: none;
      -ms-user-select: none;
      -webkit-touch-callout: none;
      -webkit-user-drag: none;
      -khtml-user-select: none;
    }
    /* Settings button and panel */
    #settingsBtn { position: fixed; left: 10px; top: 10px; z-index: 9; appearance: none; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.1); color: var(--ui); border-radius: 999px; font-size: 12px; padding: 6px 10px; backdrop-filter: blur(8px); cursor: pointer; }
    #settingsBtn:hover { background: rgba(255,255,255,0.16); }
    #settingsPanel { position: fixed; left: 10px; top: 46px; z-index: 9; width: min(90vw, 260px); display: none; background: rgba(20,20,28,0.9); color: var(--ui); border: 1px solid rgba(255,255,255,0.2); border-radius: 14px; box-shadow: 0 18px 48px rgba(0,0,0,0.5); backdrop-filter: blur(10px); }
    #settingsPanel header { display:flex; align-items:center; justify-content: space-between; padding: 8px 10px; border-bottom: 1px solid rgba(255,255,255,0.15); }
    #settingsPanel header strong { font-size: 13px; }
    #settingsClose { appearance: none; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.1); color: var(--ui); border-radius: 8px; font-size: 12px; padding: 4px 8px; cursor: pointer; }
    #settingsContent { padding: 10px; display: grid; gap: 10px; }
    /* When inside settings, make controls flow statically */
    #settingsPanel #paparazziBtn { position: static; width: 100%; }
    #settingsPanel #scrollWrap, #settingsPanel #musicWrap { position: static; width: auto; max-width: 100%; padding: 8px 10px; border-radius: 999px; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.2); backdrop-filter: none; box-shadow: none; overflow: hidden; }
    #settingsPanel #scrollWrap .title, #settingsPanel #musicWrap .title { margin: 0; font-size: 12px; opacity: 0.9; display:flex; align-items:center; justify-content: space-between; gap:8px; }
    #settingsPanel #zoomSlider, #settingsPanel #musicSlider { width: calc(100% - 4px); margin: 0 2px; display: block; box-sizing: border-box; }
    /* Remove blue tap highlight on mobile for interactive chrome */
    #controls button, .navBtn, #closeModal {
      -webkit-tap-highlight-color: transparent;
    }
    /* Keep modal content selectable for copy/paste */
    #modal .content { user-select: text; -webkit-user-select: text; }
    /* CTA row and small notes inside modal */
    .ctaRow { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 8px; }
    .assetNote { opacity: 0.85; font-size: 13px; margin-top: 6px; }
    .muted { opacity: 0.8; }
    /* Keep the instruction box from spanning too wide in portrait mobile */
    @media (orientation: portrait) and (max-width: 640px) {
      #legend { max-width: min(88vw, 320px); }
    }
  </style>
</head>
<body> <!-- Page content -->
  <div id="uiBar"> <!-- Top translucent bar with quick nav and badges -->
    <nav id="topNav" aria-label="Quick Navigation"></nav> <!-- Buttons to jump to sections -->
    <div class="chip">Fashion Show</div> <!-- Left badge text -->
    <div class="chip">Arrows/WASD to walk · Up/Enter=open · Down=close</div> <!-- Short usage hint -->
  </div>
  <div id="legend"> <!-- Bottom-left legend with instructions -->
    <button class="legendClose" title="Dismiss" aria-label="Dismiss">×</button>
    Walk to the left or right to explore sections. Stand under a marquee and press <b>Enter</b> or <b>Up</b> to open it. Press <b>Down</b> to close.
  </div>
  
  <!-- Settings launcher and panel -->
  <button id="settingsBtn" aria-haspopup="dialog" aria-controls="settingsPanel">Settings</button>
  <div id="settingsPanel" role="dialog" aria-modal="false" aria-label="Settings">
    <header>
      <strong>Settings</strong>
      <button id="settingsClose" aria-label="Close Settings">Close</button>
    </header>
    <div id="settingsContent"></div>
  </div>
  
  <div id="tooltip"></div> <!-- Floating tooltip that appears when close to a section -->
  <div id="hoverTip" aria-hidden="true"></div> <!-- Pointer hover hint for clickable areas -->
  <button id="paparazziBtn" title="Toggle paparazzi" aria-pressed="true">Paparazzi: On</button>
  <div id="scrollWrap">
    <div class="title">Scroll Up &amp; Scroll Down</div>
    <input id="zoomSlider" type="range" min="0" max="100" step="1" aria-label="Scroll Up" />
  </div>
  <div id="musicWrap" style="display:none;">
    <div class="title">Music Volume <span id="musicLabel"></span></div>
    <input id="musicSlider" type="range" min="0" max="150" step="1" aria-label="Music Volume" />
  </div>
  <div id="modalWrap" aria-hidden="true"> <!-- Fullscreen modal overlay -->
    <div id="modal" role="dialog" aria-modal="true"> <!-- Modal container -->
      <header> <!-- Modal header with title and close action -->
        <strong id="modalTitle">Section</strong> <!-- Title is filled in dynamically -->
        <button id="closeModal" aria-label="Close">Close</button> <!-- Closes the modal -->
      </header>
      <div class="content" id="modalContent"> <!-- Container for section HTML content -->
        <!-- populated dynamically -->
      </div>
    </div>
  </div>
  <canvas id="stage"></canvas> <!-- Fullscreen canvas used to draw the runway and avatar -->

  <div id="controls" aria-hidden="false"> <!-- On-screen control buttons for touch/mobile -->
    <button id="btnLeft"  title="Walk left" aria-label="Walk left">◀</button> <!-- Walk left -->
    <button id="btnRight" title="Walk right" aria-label="Walk right">▶</button> <!-- Walk right -->
    <button id="btnUp"    title="Open (Up)" aria-label="Open (Up)">▲</button> <!-- Open section -->
    <button id="btnDown"  title="Close (Down)" aria-label="Close (Down)">▼</button> <!-- Close modal -->
    <button id="btnEnter" title="Open section" aria-label="Open (Enter)">Enter</button> <!-- Open nearest section -->
  </div>

  <script>
  (() => { // IIFE: wrap all logic to avoid leaking variables to global scope
    // Minimal error overlay to surface runtime errors quickly
    window.addEventListener('error', (e) => {
      const el = document.createElement('div');
      el.style.position = 'fixed'; el.style.bottom = '6px'; el.style.left = '6px';
      el.style.zIndex = '9999'; el.style.background = 'rgba(200,0,0,0.9)'; el.style.color = '#fff';
      el.style.padding = '6px 8px'; el.style.borderRadius = '6px'; el.style.fontSize = '12px';
      el.textContent = 'Error: ' + (e?.message || 'unknown');
      document.body.appendChild(el);
    }, { once: true });

    // Basic touch capability hint (used for mobile-only layout tweaks)
    const IS_TOUCH = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0);

    // On touch devices, prevent long-press text selection/callout on HUD and canvas
    if ('ontouchstart' in window) {
      document.addEventListener('contextmenu', (e) => {
        if (e.target.closest('#controls, canvas, #uiBar, #legend')) {
          e.preventDefault();
        }
      }, { capture: true });
    }
    const canvas = document.getElementById('stage'); // Grab the canvas element
    const ctx = canvas.getContext('2d'); // 2D drawing context for canvas

    // High-DPI handling: recompute DPR on every resize/zoom for crisp rendering
    let DPR = window.devicePixelRatio || 1; // Will be updated inside resize()
    const DPR_CAP = 3; // cap for performance; increase if you want extra sharpness
    let vw = window.innerWidth, vh = window.innerHeight; // Current viewport width/height in CSS pixels
    let marbleTex = null; // Offscreen canvas for full-screen marble texture
    let brandingImg = null; // Branding image (drawn on the main curtain)
    let brandingReady = false; // Loaded flag
    let doorBackdropImg = null; // Image shown behind door curtains when they open
    let doorBackdropReady = false; // Loaded flag for door backdrop

    // Helper to choose a reasonable zoom for small screens
    function autoScaleForWidth(width) {
      let s = 1.75;
      if (width <= 420) s = 1.15;      // small phones
      else if (width <= 640) s = 1.25; // phones / small phablets
      else if (width <= 900) s = 1.5;  // tablets / small laptops
      return s;
    }

    function resize() { // Resize handler to keep canvas in sync with window (and zoom)
      vw = window.innerWidth; vh = window.innerHeight; // Update viewport size
      // Update DPR on every resize/zoom so the backing store stays crisp
      DPR = Math.min(DPR_CAP, window.devicePixelRatio || 1);
      canvas.width = Math.floor(vw * DPR); // Set canvas backing width in device pixels
      canvas.height = Math.floor(vh * DPR); // Set canvas backing height in device pixels
      canvas.style.width = vw + 'px'; // Match CSS size
      canvas.style.height = vh + 'px'; // Match CSS size
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0); // Scale drawing so 1 unit = 1 CSS pixel
      // Prefer crisp rendering for raster steps
      if ('imageSmoothingEnabled' in ctx) ctx.imageSmoothingEnabled = false;
      // Responsive zoom: on small screens, step back the camera a bit (use window.view to avoid TDZ)
      if (window.view && window.view.autoScale) {
        window.view.scale = autoScaleForWidth(vw);
      }
      // Orientation tweaks: scale up a bit in landscape (content larger), scale down slightly in portrait
      if (window.view && window.view.autoScaleLandscape) {
        const isLandscape = vw > vh;
        const base = window.view.baseScale || window.view.scale || 1.5;
        if (isLandscape) {
          // Landscape: shrink more on touch devices, and reduce on desktops for wider view
          const factor = (typeof IS_TOUCH !== 'undefined' && IS_TOUCH) ? 0.70 : 0.80; // desktop ~20% smaller
          window.view.scale = Math.max(0.6, Math.min(2, base * factor));
        } else {
          // Portrait: shrink a bit on touch, keep base on desktop
          const factorP = (typeof IS_TOUCH !== 'undefined' && IS_TOUCH) ? 0.90 : 1.0;
          window.view.scale = Math.max(0.6, Math.min(2, base * factorP));
        }
      }
      buildMarblePattern(); // Rebuild background texture for new size/theme
    }
    window.addEventListener('resize', resize); // Re-run on window resize
    window.addEventListener('orientationchange', () => setTimeout(resize, 100));
    resize(); // Initialize canvas size immediately

    // Load branding image helper (call once; safe to call again to change src)
    function loadBranding(src) {
      brandingReady = false;
      brandingImg = new Image();
      brandingImg.onload = () => { brandingReady = true; };
      brandingImg.onerror = () => { brandingReady = false; };
      brandingImg.src = src;
    }
    // Default expected filename (place this image next to index.html)
    loadBranding('fashion-show-branding.png');
    // Expose a setter for quick swaps via console if needed
    window.setBrandingImage = (url) => loadBranding(url);

    // Load per-door backdrop image (displayed behind opening curtains)
    function loadDoorBackdrop(src) {
      doorBackdropReady = false;
      doorBackdropImg = new Image();
      doorBackdropImg.onload = () => { doorBackdropReady = true; };
      doorBackdropImg.onerror = () => { doorBackdropReady = false; };
      doorBackdropImg.src = src;
    }
    // Default filename expected alongside index.html; safe to replace at runtime
    loadDoorBackdrop('door-backdrop.png');

    // Optional per-door backdrops: door-backdrop_1.png ... door-backdrop_7.png
    const doorBackdropSet = {}; // index -> { img, ready }
    function loadDoorBackdropSet(count) {
      for (let i = 1; i <= count; i++) {
        const img = new Image();
        doorBackdropSet[i] = { img, ready: false };
        img.onload = () => { doorBackdropSet[i].ready = true; };
        img.onerror = () => { doorBackdropSet[i].ready = false; };
        img.src = `door-backdrop_${i}.png`;
      }
    }
    loadDoorBackdropSet(7);
    
    // Load paparazzi strip images (alternate left/right across the bottom)
    let paparazziLeftImg = new Image();
    let paparazziRightImg = new Image();
    let paparazziLeftReady = false;
    let paparazziRightReady = false;

    function loadPaparazziPair(leftSrc, rightSrc) {
      paparazziLeftReady = paparazziRightReady = false;
      paparazziLeftImg.onload = () => { paparazziLeftReady = true; };
      paparazziRightImg.onload = () => { paparazziRightReady = true; };
      paparazziLeftImg.onerror = () => { paparazziLeftReady = false; };
      paparazziRightImg.onerror = () => { paparazziRightReady = false; };
      paparazziLeftImg.src = leftSrc;
      paparazziRightImg.src = rightSrc;
    }
    // Default pair (files should exist next to index.html)
    loadPaparazziPair('paparazzi_left.png', 'paparazzi_right.png');
    window.setPaparazziImages = (l, r) => loadPaparazziPair(l, r);

    // Stage props: Gary statues and judge chairs (drawn behind door curtains)
    let statueImg = new Image();
    let chairImg = new Image();
    let statueReady = false;
    let chairReady = false;
    function loadStageProps(statueSrc, chairSrc) {
      statueReady = chairReady = false;
      statueImg.onload = () => { statueReady = true; };
      statueImg.onerror = () => { statueReady = false; };
      chairImg.onload = () => { chairReady = true; };
      chairImg.onerror = () => { chairReady = false; };
      statueImg.src = statueSrc;
      chairImg.src = chairSrc;
    }
    loadStageProps('gary_statue.png', 'judge_chair.png');
    window.setStageProps = (s, c) => loadStageProps(s, c);

    // Limo image at far left of the catwalk
    let limoImg = new Image();
    let limoReady = false;
    function loadLimo(src) {
      limoReady = false;
      limoImg = new Image();
      limoImg.onload = () => { limoReady = true; };
      limoImg.onerror = () => { limoReady = false; };
      limoImg.src = src;
    }
    loadLimo('limo_0.png');
    window.setLimoImage = (src) => loadLimo(src);

    // AVATAR SPRITE SHEET (128x128 frames)
    // Rows:
    // 0: idle right (5 frames)
    // 1: idle left  (5 frames)
    // 2: walk right (11 frames)
    // 3: walk left  (11 frames)
    const AVATAR = {
      img: new Image(),
      ready: false,
      fw: 128,
      fh: 128,
      // Number of source pixels from the bottom of the frame to the soles.
      // Increase if feet appear to hover; decrease if they sink into the carpet.
      footInset: 16, // nudged up from 10 to drop avatar slightly
      // Overall size multiplier applied after viewport-based target height
      sizeMul: 0.847, // another +10% (feet remain anchored)
      // Screen-space vertical nudge in pixels (positive moves sprite down)
      yNudge: 10,
      seq: {
        idleRight: { row: 0, len: 5,  fps: 3 },
        idleLeft:  { row: 1, len: 5,  fps: 3 },
        walkRight: { row: 2, len: 11, fps: 12 },
        walkLeft:  { row: 3, len: 11, fps: 12 },
        // New sprint rows (0-based): 4 = sprint right (19 frames), 5 = sprint left (19 frames)
        sprintRight: { row: 4, len: 19, fps: 20 },
        sprintLeft:  { row: 5, len: 19, fps: 20 },
      }
    };
    AVATAR.img.onload = () => { AVATAR.ready = true; };
    AVATAR.img.onerror = () => { AVATAR.ready = false; };
    AVATAR.img.src = 'avatar_sprite_sheet.png';
    // Quick tuning from console: setAvatarFootInset(px), setAvatarScale(mult), setAvatarYNudge(px)
    window.setAvatarFootInset = (n) => { AVATAR.footInset = Math.max(0, Math.min(AVATAR.fh, Number(n)||0)); };
    window.setAvatarScale = (m) => { AVATAR.sizeMul = Math.max(0.5, Math.min(2, Number(m)||1)); };
    window.setAvatarYNudge = (n) => { AVATAR.yNudge = Math.max(-200, Math.min(200, Number(n)||0)); };

    // Draw alternating paparazzi tiles under the runway
    function drawPaparazziStrip() {
      if (!(paparazziLeftReady || paparazziRightReady)) return;
      const yRunway = world.runwayY();
      // Base target height; scale to be 1/3 smaller than previous doubled size
      const targetHBase = Math.max(36, Math.min(120, Math.floor(vh * 0.14)));
      const isSmallScreen = (vw < 900) || (vh < 600); // heuristic for phones/smaller tablets
      let targetH = Math.floor(targetHBase * (4/3));   // desktop baseline size (~1.33x base)
      if (isSmallScreen) targetH = Math.floor(targetH * 1.25); // make robots ~25% larger on small screens
      const hL = paparazziLeftReady ? paparazziLeftImg.naturalHeight : (paparazziRightReady ? paparazziRightImg.naturalHeight : 100);
      const hR = paparazziRightReady ? paparazziRightImg.naturalHeight : hL;
      const scaleL = targetH / hL;
      const scaleR = targetH / hR;
      const tileWL = paparazziLeftReady ? Math.ceil(paparazziLeftImg.naturalWidth * scaleL) : Math.ceil(paparazziRightImg.naturalWidth * scaleR);
      const tileWR = paparazziRightReady ? Math.ceil(paparazziRightImg.naturalWidth * scaleR) : tileWL;
      // Position row: move up another 75px on both desktop and small screens
      const yTop = Math.floor(yRunway + (isSmallScreen ? 75 : 105));
      const baseTile = Math.max(1, Math.min(tileWL, tileWR));
      const start = Math.floor((camera.x - vw) / baseTile) * baseTile;
      const end = camera.x + vw + baseTile;
      const t = performance.now() * 0.001;
      // deterministic pseudo-random helper for per-tile variance
      const rnd = (n) => { const s = Math.sin(n) * 43758.5453; return s - Math.floor(s); };
      // Back row disabled here; re-drawn later on top
      if (false) {
        let tileIndexB = 0;
        let useLeftB = false;
        const yTopBack = yTop + 60;         // lower on screen
        const scaleMulBack = 1.25;          // larger size
        const startBack = start + Math.floor(baseTile / 2) - 10; // half-tile offset, shifted 10px left
        ctx.save();
        ctx.globalAlpha = 0.9; // a touch dimmer
        for (let wx = startBack; wx < end; ) {
          const img = (useLeftB && paparazziLeftReady) ? paparazziLeftImg : (paparazziRightReady ? paparazziRightImg : paparazziLeftImg);
          const isLeft = (img === paparazziLeftImg);
          const scale = (isLeft ? scaleL : scaleR) * scaleMulBack;
          const dw = Math.ceil(img.naturalWidth * scale);
          const dh = Math.ceil(img.naturalHeight * scale);
          const sx = Math.floor(wx - camera.x);
          ctx.drawImage(img, sx, yTopBack, dw, dh);

          // Subtler flash for back row
          const seed = tileIndexB * 97 + (isLeft ? 3 : 5);
          const freq = 0.8 + rnd(seed + 1) * 1.4;
          const phase = rnd(seed + 2) * Math.PI * 2;
          let pulse = Math.sin(t * freq + phase);
          pulse = pulse > 0.94 ? Math.pow((pulse - 0.94) / 0.06, 2) : 0; // rarer, softer
          if (pulse > 0) {
            const cx = isLeft ? (sx + Math.round(dw * 0.18)) : (sx + Math.round(dw * (1 - 0.18)));
            const cy = yTopBack + Math.round(dh * 0.16);
            const baseInner = Math.max(6, Math.round(Math.min(dw, dh) * 0.08));
            const rInner = Math.max(6, Math.round(baseInner * 4));
            const rOuter = Math.max(14, Math.round(rInner * 2.0));
            const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, rOuter);
            let a = Math.min(0.55, 0.22 + pulse * 0.4);
            g.addColorStop(0.0, `rgba(255,255,255,${a})`);
            g.addColorStop(0.3, `rgba(255,255,255,${a*0.7})`);
            g.addColorStop(1.0, 'rgba(255,255,255,0)');
            ctx.save(); ctx.globalCompositeOperation = 'screen'; ctx.fillStyle = g;
            ctx.beginPath(); ctx.arc(cx, cy, rOuter, 0, Math.PI * 2); ctx.fill();
            ctx.restore();
          }

          wx += dw;
          useLeftB = !useLeftB;
          tileIndexB++;
        }
        ctx.restore();
      }

      // Front row (original)
      let tileIndex = 0;
      ctx.save();
      ctx.globalAlpha = 0.98;
      let useLeft = true;
      for (let wx = start; wx < end; ) {
        const img = (useLeft && paparazziLeftReady) ? paparazziLeftImg : (paparazziRightReady ? paparazziRightImg : paparazziLeftImg);
        const isLeft = (img === paparazziLeftImg);
        const scale = isLeft ? scaleL : scaleR;
        const dw = Math.ceil(img.naturalWidth * scale);
        const dh = Math.ceil(img.naturalHeight * scale);
        const sx = Math.floor(wx - camera.x);
        // Draw the paparazzi tile
        ctx.drawImage(img, sx, yTop, dw, dh);

        // Camera flash effect near the camera position on each tile
        // Compute a per-tile flashing pattern
        const seed = tileIndex * 101 + (isLeft ? 1 : 2);
        const freq = 0.8 + rnd(seed + 1) * 1.4;     // 0.8..2.2 Hz
        const phase = rnd(seed + 2) * Math.PI * 2;   // 0..2π
        // Short bright pop using a steep power curve
        let pulse = Math.sin(t * freq + phase);
        pulse = pulse > 0.92 ? Math.pow((pulse - 0.92) / 0.08, 2) : 0; // only top 8% of the wave
        if (pulse > 0) {
          // Position near the camera: UL for left-facing, UR for right-facing
          const cx = isLeft ? (sx + Math.round(dw * 0.18)) : (sx + Math.round(dw * (1 - 0.18)));
          const cy = yTop + Math.round(dh * 0.16);
          // Make flashes 5x larger than before
          const baseInner = Math.max(6, Math.round(Math.min(dw, dh) * 0.08));
          const rInner = Math.max(6, Math.round(baseInner * 5));
          const rOuter = Math.max(14, Math.round(rInner * 2.2));
          const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, rOuter);
          // Make flashes ~1.2x brighter than before (with a higher cap)
          let a = Math.min(0.65, 0.25 + pulse * 0.5);
          a = Math.min(0.78, a * 1.2); // boost and cap
          g.addColorStop(0.0, `rgba(255,255,255,${a})`);
          g.addColorStop(0.3, `rgba(255,255,255,${a*0.7})`);
          g.addColorStop(1.0, 'rgba(255,255,255,0)');
          ctx.save();
          ctx.globalCompositeOperation = 'screen'; // brighten without blowing out blacks
          ctx.fillStyle = g;
          ctx.beginPath();
          ctx.arc(cx, cy, rOuter, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }

        wx += dw;
        useLeft = !useLeft;
        tileIndex++;
      }
      ctx.restore();

      // Back row drawn ON TOP: lower, larger, and horizontally offset; opposite orientation start
      {
        let tileIndexB = 0;
        let useLeftB = false; // start opposite to the front row
        const yTopBack = yTop + 60;         // lower on screen (further down)
        const scaleMulBack = 1.25;          // larger size
        const startBack = start + Math.floor(baseTile / 2); // half-tile offset
        ctx.save();
        ctx.globalAlpha = 0.96; // slightly brighter since this row is on top
        for (let wx = startBack; wx < end; ) {
          const img = (useLeftB && paparazziLeftReady) ? paparazziLeftImg : (paparazziRightReady ? paparazziRightImg : paparazziLeftImg);
          const isLeft = (img === paparazziLeftImg);
          const scale = (isLeft ? scaleL : scaleR) * scaleMulBack;
          const dw = Math.ceil(img.naturalWidth * scale);
          const dh = Math.ceil(img.naturalHeight * scale);
          const sx = Math.floor(wx - camera.x);
          ctx.drawImage(img, sx, yTopBack, dw, dh);

          // Subtler flash for back row
          const seed = tileIndexB * 97 + (isLeft ? 3 : 5);
          const freq = 0.8 + rnd(seed + 1) * 1.4;
          const phase = rnd(seed + 2) * Math.PI * 2;
          let pulse = Math.sin(t * freq + phase);
          pulse = pulse > 0.94 ? Math.pow((pulse - 0.94) / 0.06, 2) : 0; // rarer, softer
          if (pulse > 0) {
            const cx = isLeft ? (sx + Math.round(dw * 0.18)) : (sx + Math.round(dw * (1 - 0.18)));
            const cy = yTopBack + Math.round(dh * 0.16);
            const baseInner = Math.max(6, Math.round(Math.min(dw, dh) * 0.08));
            const rInner = Math.max(6, Math.round(baseInner * 4));
            const rOuter = Math.max(14, Math.round(rInner * 2.0));
            const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, rOuter);
            let a = Math.min(0.55, 0.22 + pulse * 0.4);
            g.addColorStop(0.0, `rgba(255,255,255,${a})`);
            g.addColorStop(0.3, `rgba(255,255,255,${a*0.7})`);
            g.addColorStop(1.0, 'rgba(255,255,255,0)');
            ctx.save(); ctx.globalCompositeOperation = 'screen'; ctx.fillStyle = g;
            ctx.beginPath(); ctx.arc(cx, cy, rOuter, 0, Math.PI * 2); ctx.fill();
            ctx.restore();
          }

          wx += dw;
          useLeftB = !useLeftB;
          tileIndexB++;
        }
        ctx.restore();
      }

      // Fore row drawn LAST: even lower and bigger to fill the bottom
      {
        let tileIndexC = 0;
        let useLeftC = false; // switch starting orientation for variety
        const yTopFore = yTop + 110;        // drop further down
        const scaleMulFore = 1.55;          // biggest row
        const startFore = start + Math.floor(baseTile * 3 / 4) + 10; // new stagger
        ctx.save();
        ctx.globalAlpha = 0.99; // most prominent
        for (let wx = startFore; wx < end; ) {
          const img = (useLeftC && paparazziLeftReady) ? paparazziLeftImg : (paparazziRightReady ? paparazziRightImg : paparazziLeftImg);
          const isLeft = (img === paparazziLeftImg);
          const scale = (isLeft ? scaleL : scaleR) * scaleMulFore;
          const dw = Math.ceil(img.naturalWidth * scale);
          const dh = Math.ceil(img.naturalHeight * scale);
          const sx = Math.floor(wx - camera.x);
          ctx.drawImage(img, sx, yTopFore, dw, dh);

          // Flash effect similar to front row
          const seed = tileIndexC * 89 + (isLeft ? 7 : 11);
          const freq = 0.8 + rnd(seed + 1) * 1.4;
          const phase = rnd(seed + 2) * Math.PI * 2;
          let pulse = Math.sin(t * freq + phase);
          pulse = pulse > 0.92 ? Math.pow((pulse - 0.92) / 0.08, 2) : 0;
          if (pulse > 0) {
            const cx = isLeft ? (sx + Math.round(dw * 0.18)) : (sx + Math.round(dw * (1 - 0.18)));
            const cy = yTopFore + Math.round(dh * 0.16);
            const baseInner = Math.max(6, Math.round(Math.min(dw, dh) * 0.08));
            const rInner = Math.max(6, Math.round(baseInner * 5));
            const rOuter = Math.max(14, Math.round(rInner * 2.2));
            const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, rOuter);
            let a = Math.min(0.78, 0.28 + pulse * 0.55);
            g.addColorStop(0.0, `rgba(255,255,255,${a})`);
            g.addColorStop(0.3, `rgba(255,255,255,${a*0.7})`);
            g.addColorStop(1.0, 'rgba(255,255,255,0)');
            ctx.save(); ctx.globalCompositeOperation = 'screen'; ctx.fillStyle = g;
            ctx.beginPath(); ctx.arc(cx, cy, rOuter, 0, Math.PI * 2); ctx.fill();
            ctx.restore();
          }

          wx += dw;
          useLeftC = !useLeftC;
          tileIndexC++;
        }
        ctx.restore();
      }
    }

    // Build a subtle marble texture as a repeated pattern
    function buildMarblePattern() {
      const cw = Math.max(1, Math.floor(vw));
      const ch = Math.max(1, Math.floor(vh));
      const off = document.createElement('canvas');
      off.width = cw; off.height = ch;
      const c = off.getContext('2d');
      const bgCol = getComputedStyle(document.documentElement).getPropertyValue('--bg') || '#15171c';
      c.fillStyle = bgCol; c.fillRect(0,0,cw,ch);

      const area = cw * ch;
      const diag = Math.hypot(cw, ch);

      // cloudy areas for dark marble (soft lightening)
      const cloudCount = Math.max(6, Math.floor(area / 180000));
      for (let i = 0; i < cloudCount; i++) {
        const x = Math.random()*cw;
        const y = Math.random()*ch;
        const r = diag * (0.10 + Math.random()*0.18);
        const g = c.createRadialGradient(x,y,0,x,y,r);
        g.addColorStop(0, 'rgba(255,255,255,0.10)');
        g.addColorStop(1, 'rgba(255,255,255,0)');
        c.fillStyle = g;
        c.beginPath(); c.arc(x,y,r,0,Math.PI*2); c.fill();
      }

      // subtle warm/cool tints for depth
      const warmCount = Math.max(3, Math.floor(area / 350000));
      for (let i = 0; i < warmCount; i++) {
        const x = Math.random()*cw, y = Math.random()*ch, r = diag * (0.10 + Math.random()*0.14);
        const tintWarm = c.createRadialGradient(x,y,0,x,y,r);
        tintWarm.addColorStop(0, 'rgba(180,160,140,0.05)');
        tintWarm.addColorStop(1, 'rgba(180,160,140,0)');
        c.fillStyle = tintWarm; c.beginPath(); c.arc(x,y,r,0,Math.PI*2); c.fill();
      }
      const coolCount = Math.max(2, Math.floor(area / 480000));
      for (let i = 0; i < coolCount; i++) {
        const x = Math.random()*cw, y = Math.random()*ch, r = diag * (0.10 + Math.random()*0.14);
        const tintCool = c.createRadialGradient(x,y,0,x,y,r);
        tintCool.addColorStop(0, 'rgba(140,160,180,0.05)');
        tintCool.addColorStop(1, 'rgba(140,160,180,0)');
        c.fillStyle = tintCool; c.beginPath(); c.arc(x,y,r,0,Math.PI*2); c.fill();
      }

      // faint veins: subtle criss-cross lines for marble texture
      c.lineCap = 'round';
      const veinCount = Math.max(14, Math.floor(area / 220000));
      for (let i = 0; i < veinCount; i++) {
        const ang = (-25 + Math.random()*50) * Math.PI/180;
        const len = diag * (0.5 + Math.random()*0.6);
        const cx = Math.random()*cw;
        const cy = Math.random()*ch;
        const dx = Math.cos(ang)*len/2;
        const dy = Math.sin(ang)*len/2;
        c.strokeStyle = 'rgba(220,220,220,0.10)';
        c.lineWidth = 1 + Math.random()*1.5;
        c.shadowColor = 'rgba(0,0,0,0.10)';
        c.shadowBlur = 2;
        c.beginPath();
        c.moveTo(cx-dx, cy-dy);
        c.quadraticCurveTo(cx + (Math.random()-0.5)*60, cy + (Math.random()-0.5)*60, cx+dx, cy+dy);
        c.stroke();
        if (Math.random() < 0.4) {
          c.beginPath(); c.moveTo(cx, cy);
          c.quadraticCurveTo(cx + (Math.random()-0.5)*40, cy + (Math.random()-0.5)*40, cx+dx*0.35, cy+dy*0.35);
          c.stroke();
        }
        // highlight
        c.strokeStyle = 'rgba(255,255,255,0.12)';
        c.shadowBlur = 0;
        c.beginPath(); c.moveTo(cx-dx, cy-dy);
        c.quadraticCurveTo(cx + (Math.random()-0.5)*50, cy + (Math.random()-0.5)*50, cx+dx, cy+dy);
        c.stroke();
      }
      c.shadowBlur = 0;

      // speckles (disabled for a cleaner background)
      const speckCount = 0;
      for (let i = 0; i < speckCount; i++) {
        const x = Math.random()*cw;
        const y = Math.random()*ch;
        c.fillStyle = Math.random() < 0.5 ? 'rgba(255,255,255,0.07)' : 'rgba(0,0,0,0.08)';
        c.fillRect(x, y, 1, 1);
      }

      marbleTex = off; // store full-screen texture
    }

    // Pre-rendered golden bulb sprite for marquee lights (for smooth drawing)
    let BULB_SPRITE = null;
    function ensureBulbSprite() {
      if (BULB_SPRITE) return BULB_SPRITE;
      // Increase bulb size by 50% for a bolder look
      const s = 30; // sprite size (square)
      const off = document.createElement('canvas');
      off.width = s; off.height = s;
      const c = off.getContext('2d');
      const r = s / 2;
      const g = c.createRadialGradient(r, r, 0, r, r, r);
      // Warm gold glow with a tighter falloff for a crisper look
      g.addColorStop(0.0, 'rgba(241,207,99,1.0)');
      g.addColorStop(0.22, 'rgba(241,207,99,0.85)');
      g.addColorStop(0.60, 'rgba(241,207,99,0)');
      c.fillStyle = g;
      c.beginPath(); c.arc(r, r, r, 0, Math.PI*2); c.fill();
      BULB_SPRITE = off;
      return BULB_SPRITE;
    }

    // Draw branding image at spawn area behind the carpet (world-anchored)
    function drawSpawnBranding() {
      if (!(brandingReady && brandingImg && brandingImg.naturalWidth)) return;
      const curtainTop = Math.max(60, world.runwayY() - (220 + CURTAIN_LIFT));
      const carpetTop = world.runwayY() - 2; // top edge of carpet
      const padAboveCarpet = 18;            // keep a gap above the carpet
      const maxW = Math.min(520, vw * 0.5);
      const maxH = Math.min(240, Math.max(60, carpetTop - padAboveCarpet - curtainTop));
      const scale = Math.min(maxW / brandingImg.naturalWidth, maxH / brandingImg.naturalHeight);
      const dw = Math.floor(brandingImg.naturalWidth * scale);
      const dh = Math.floor(brandingImg.naturalHeight * scale);

      // Center on the spawn X in world space
      const dx = Math.floor(((SPAWN_X + BRAND_OFFSET_X) - camera.x) - dw / 2);
      // Move branding up by an additional 50px (now total 95px up from original)
      const dy = Math.floor(carpetTop - padAboveCarpet - dh - 95);

      ctx.save();
      // Draw two gold poles holding up the branding, like a billboard
      const gold = getComputedStyle(document.documentElement).getPropertyValue('--runway-edge') || '#f1cf63';
      ctx.fillStyle = gold;
      const poleWidth = 20; // reduce to ~1/3 thickness
      const poleInset = 12; // base inset from image edges
      const extraInset = 30; // move posts inward toward center by 30px
      const poleTop = dy + dh; // start at bottom of image
      const poleBottom = carpetTop - 2; // stop slightly above carpet
      const leftPoleX = dx + poleInset + extraInset;
      const rightPoleX = dx + dw - poleInset - poleWidth - extraInset;
      if (poleBottom > poleTop) {
        ctx.fillRect(leftPoleX, poleTop, poleWidth, poleBottom - poleTop);
        ctx.fillRect(rightPoleX, poleTop, poleWidth, poleBottom - poleTop);
        // small round base caps
        ctx.beginPath(); ctx.arc(leftPoleX + poleWidth/2, poleBottom, 3.5, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(rightPoleX + poleWidth/2, poleBottom, 3.5, 0, Math.PI*2); ctx.fill();
      }
      // very soft shadow so it sits on the wall behind
      ctx.shadowColor = 'rgba(0,0,0,0.25)';
      ctx.shadowBlur = 8;
      ctx.drawImage(brandingImg, dx, dy, dw, dh);

      // Golden outline around the branding
      ctx.shadowBlur = 0;
      ctx.lineWidth = 3;
      ctx.strokeStyle = gold;
      ctx.strokeRect(dx - 2, dy - 2, dw + 4, dh + 4);

      // Small flashing golden light pattern around the brand png
      const t = performance.now() * 0.001;
      const bulbSpacing = 22;
      const bulbR = 3;
      ctx.save();
      ctx.globalCompositeOperation = 'screen';
      // Top edge bulbs
      for (let x = dx; x <= dx + dw; x += bulbSpacing) {
        const i = Math.floor((x - dx) / bulbSpacing);
        const phase = i * 0.6;
        const pulse = Math.max(0, Math.sin(t * 3.0 + phase));
        const a = 0.18 + Math.pow(pulse, 6) * 0.82; // sharp bright pops
        const gx = x, gy = dy - 6;
        const g = ctx.createRadialGradient(gx, gy, 0, gx, gy, bulbR * 4.2);
        g.addColorStop(0, `rgba(241,207,99,${Math.min(1,a)})`);
        g.addColorStop(1, 'rgba(241,207,99,0)');
        ctx.fillStyle = g;
        ctx.beginPath(); ctx.arc(gx, gy, bulbR * 3.8, 0, Math.PI*2); ctx.fill();
      }
      // Bottom edge bulbs
      for (let x = dx + bulbSpacing/2; x <= dx + dw; x += bulbSpacing) {
        const i = Math.floor((x - dx) / bulbSpacing) + 37;
        const phase = i * 0.6;
        const pulse = Math.max(0, Math.sin(t * 3.0 + phase));
        const a = 0.18 + Math.pow(pulse, 6) * 0.82;
        const gx = x, gy = dy + dh + 6;
        const g = ctx.createRadialGradient(gx, gy, 0, gx, gy, bulbR * 4.2);
        g.addColorStop(0, `rgba(241,207,99,${Math.min(1,a)})`);
        g.addColorStop(1, 'rgba(241,207,99,0)');
        ctx.fillStyle = g;
        ctx.beginPath(); ctx.arc(gx, gy, bulbR * 3.8, 0, Math.PI*2); ctx.fill();
      }
      // Left/right edges bulbs (sparser)
      for (let y = dy + 12; y <= dy + dh - 12; y += bulbSpacing * 1.1) {
        const i = Math.floor((y - dy) / bulbSpacing);
        const phase = i * 0.7;
        const pulse = Math.max(0, Math.sin(t * 3.0 + phase));
        const a = 0.12 + Math.pow(pulse, 6) * 0.75;
        const gx1 = dx - 6, gy1 = y;
        const g1 = ctx.createRadialGradient(gx1, gy1, 0, gx1, gy1, bulbR * 4.2);
        g1.addColorStop(0, `rgba(241,207,99,${Math.min(1,a)})`);
        g1.addColorStop(1, 'rgba(241,207,99,0)');
        ctx.fillStyle = g1; ctx.beginPath(); ctx.arc(gx1, gy1, bulbR * 3.8, 0, Math.PI*2); ctx.fill();
        const gx2 = dx + dw + 6, gy2 = y;
        const g2 = ctx.createRadialGradient(gx2, gy2, 0, gx2, gy2, bulbR * 4.2);
        g2.addColorStop(0, `rgba(241,207,99,${Math.min(1,a*0.9)})`);
        g2.addColorStop(1, 'rgba(241,207,99,0)');
        ctx.fillStyle = g2; ctx.beginPath(); ctx.arc(gx2, gy2, bulbR * 3.8, 0, Math.PI*2); ctx.fill();
      }
      ctx.restore();

      // store clickable rect for spawn branding
      view._spawnBrandRect = { x: dx, y: dy, w: dw, h: dh };
      ctx.restore();
    }
    // Draw a second stationary branding at the far right endcap (after last door)
    function drawEndcapBranding(endX) {
      if (!(brandingReady && brandingImg && brandingImg.naturalWidth)) return;
      const curtainTop = Math.max(60, world.runwayY() - (220 + CURTAIN_LIFT));
      const carpetTop = world.runwayY() - 2;
      const padAboveCarpet = 18;
      const maxW = Math.min(520, vw * 0.5);
      const maxH = Math.min(240, Math.max(60, carpetTop - padAboveCarpet - curtainTop));
      const scale = Math.min(maxW / brandingImg.naturalWidth, maxH / brandingImg.naturalHeight);
      const dw = Math.floor(brandingImg.naturalWidth * scale);
      const dh = Math.floor(brandingImg.naturalHeight * scale);
      const dx = Math.floor((endX - camera.x) - dw / 2);
      // Move branding up by an additional 50px (now total 95px up from original)
      const dy = Math.floor(carpetTop - padAboveCarpet - dh - 95);
      ctx.save();
      // Draw two gold poles for endcap branding as well
      const gold = getComputedStyle(document.documentElement).getPropertyValue('--runway-edge') || '#f1cf63';
      ctx.fillStyle = gold;
      const poleWidth = 20; // reduce to ~1/3 thickness
      const poleInset = 12;
      const extraInset = 30; // move posts inward toward center by 30px
      const poleTop = dy + dh;
      const poleBottom = carpetTop - 2;
      const leftPoleX = dx + poleInset + extraInset;
      const rightPoleX = dx + dw - poleInset - poleWidth - extraInset;
      if (poleBottom > poleTop) {
        ctx.fillRect(leftPoleX, poleTop, poleWidth, poleBottom - poleTop);
        ctx.fillRect(rightPoleX, poleTop, poleWidth, poleBottom - poleTop);
        ctx.beginPath(); ctx.arc(leftPoleX + poleWidth/2, poleBottom, 3.5, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(rightPoleX + poleWidth/2, poleBottom, 3.5, 0, Math.PI*2); ctx.fill();
      }
      ctx.shadowColor = 'rgba(0,0,0,0.25)';
      ctx.shadowBlur = 8;
      ctx.drawImage(brandingImg, dx, dy, dw, dh);

      // Golden outline
      ctx.shadowBlur = 0;
      ctx.lineWidth = 3;
      ctx.strokeStyle = gold;
      ctx.strokeRect(dx - 2, dy - 2, dw + 4, dh + 4);

      // Flashing golden bulbs around frame
      const t2 = performance.now() * 0.001;
      const bulbSpacing2 = 22;
      const bulbR2 = 3;
      ctx.save();
      ctx.globalCompositeOperation = 'screen';
      for (let x = dx; x <= dx + dw; x += bulbSpacing2) {
        const i = Math.floor((x - dx) / bulbSpacing2);
        const phase = i * 0.6 + 0.3; // slight offset so endcap differs
        const pulse = Math.max(0, Math.sin(t2 * 3.0 + phase));
        const a = 0.18 + Math.pow(pulse, 6) * 0.82;
        const gx = x, gy = dy - 6;
        const g = ctx.createRadialGradient(gx, gy, 0, gx, gy, bulbR2 * 4.2);
        g.addColorStop(0, `rgba(241,207,99,${Math.min(1,a)})`);
        g.addColorStop(1, 'rgba(241,207,99,0)');
        ctx.fillStyle = g; ctx.beginPath(); ctx.arc(gx, gy, bulbR2 * 3.8, 0, Math.PI*2); ctx.fill();
      }
      for (let x = dx + bulbSpacing2/2; x <= dx + dw; x += bulbSpacing2) {
        const i = Math.floor((x - dx) / bulbSpacing2) + 41;
        const phase = i * 0.6 + 0.3;
        const pulse = Math.max(0, Math.sin(t2 * 3.0 + phase));
        const a = 0.18 + Math.pow(pulse, 6) * 0.82;
        const gx = x, gy = dy + dh + 6;
        const g = ctx.createRadialGradient(gx, gy, 0, gx, gy, bulbR2 * 4.2);
        g.addColorStop(0, `rgba(241,207,99,${Math.min(1,a)})`);
        g.addColorStop(1, 'rgba(241,207,99,0)');
        ctx.fillStyle = g; ctx.beginPath(); ctx.arc(gx, gy, bulbR2 * 3.8, 0, Math.PI*2); ctx.fill();
      }
      for (let y = dy + 12; y <= dy + dh - 12; y += bulbSpacing2 * 1.1) {
        const i = Math.floor((y - dy) / bulbSpacing2);
        const phase = i * 0.7 + 0.3;
        const pulse = Math.max(0, Math.sin(t2 * 3.0 + phase));
        const a = 0.12 + Math.pow(pulse, 6) * 0.75;
        const gx1 = dx - 6, gy1 = y;
        const g1 = ctx.createRadialGradient(gx1, gy1, 0, gx1, gy1, bulbR2 * 4.2);
        g1.addColorStop(0, `rgba(241,207,99,${Math.min(1,a)})`);
        g1.addColorStop(1, 'rgba(241,207,99,0)');
        ctx.fillStyle = g1; ctx.beginPath(); ctx.arc(gx1, gy1, bulbR2 * 3.8, 0, Math.PI*2); ctx.fill();
        const gx2 = dx + dw + 6, gy2 = y;
        const g2 = ctx.createRadialGradient(gx2, gy2, 0, gx2, gy2, bulbR2 * 4.2);
        g2.addColorStop(0, `rgba(241,207,99,${Math.min(1,a*0.9)})`);
        g2.addColorStop(1, 'rgba(241,207,99,0)');
        ctx.fillStyle = g2; ctx.beginPath(); ctx.arc(gx2, gy2, bulbR2 * 3.8, 0, Math.PI*2); ctx.fill();
      }
      ctx.restore();

      // store clickable rect for endcap branding
      view._endcapBrandRect = { x: dx, y: dy, w: dw, h: dh };
      ctx.restore();
    }

    // WORLD CONFIG
    const world = {
      width: 6000, // base catwalk length in px
      minX: -2000, // extra walking room to the left (negative world space)
      maxX: 6000,  // will be updated after sections are defined
      runwayY: () => Math.floor(vh * 0.62), // Y position of runway relative to viewport
      runwayW: () => Math.min(800, Math.max(420, vw * 0.6)), // Runway visual width
      speed: 2.2, // Base movement speed factor
      ambient: 0.25, // Ambient light factor (not used heavily here)
    };

    // PLAYER (blocky voxel-like avatar with normal gait)
    const SPAWN_X = 360; // anchor for spawn area and branding placement (branding uses this)
    const player = {
      x: SPAWN_X, y: 0, vy: 0, facing: 1, walking: false, t: 0, // position, velocity, facing, walk state, walk time
      width: 32, height: 64, // player dimensions for drawing/placement
      anim: { key: 'idleRight', frame: 0, accum: 0 }, // sprite animation state
    };

    // CAMERA
    const camera = { x: 0 }; // Camera x scroll position (y is fixed by design)
    // Safe default zoom to avoid any auto-scale edge cases causing a blank scene
    const view = { scale: 1.5, offsetX: 0, yLift: 0, globalScale: 0.7, autoScale: false, autoScaleLandscape: true, landscapeScale: 0.9, edgeFades: false, edgeFadesInLandscape: false }; // You can tweak with setViewScale()/setViewOffset()
    // Expose quick tuning via console: setViewScale(1.2..1.6)
    window.view = view;
    if (view.baseScale == null) view.baseScale = view.scale; // store base scale
    // Paparazzi toggle (global)
    window.paparazziOn = true;
    window.setViewScale = (s) => { view.autoScale = false; view.scale = Math.max(1, Math.min(2, Number(s)||1)); };
    window.setGlobalScale = (f) => { view.globalScale = Math.max(0.4, Math.min(1.2, Number(f)||1)); };
    // Optional: adjust horizontal nudge via console: setViewOffset(px)
    window.setViewOffset = (x) => { view.offsetX = Math.max(-200, Math.min(200, Number(x)||0)); };
    // Optional: lock/unlock landscape auto zoom and set amount
    window.setLandscapeAutoZoom = (on) => { view.autoScaleLandscape = !!on; if (on) resize(); };
    window.setLandscapeZoom = (s) => { view.landscapeScale = Math.max(0.8, Math.min(2, Number(s)||0.9)); resize(); };
    // Optional: toggle edge fades (disabled by default)
    window.setEdgeFades = (on) => { view.edgeFades = !!on; };
    window.setEdgeFadesLandscape = (on) => { view.edgeFadesInLandscape = !!on; };
    // Stage layout: shift all marquees and carpet to the right to create a left entry area
    const stage = { leftOffset: 600 };
    // Raise the top valance a bit (in pixels). Increase to move it up more.
    const CURTAIN_LIFT = 30;
    // Branding horizontal offset relative to spawn
    // Place the billboard center ~1800px to the right of the far-left world edge
    let BRAND_OFFSET_X = (((world && typeof world.minX === 'number' ? world.minX : -2000) + 1800) - SPAWN_X);
    // Spawn the avatar near the far-left limo (independent of branding position)
    const LIMO_SPAWN_OFFSET_X = 170; // move avatar spawn further to the right
    try { player.x = (world && typeof world.minX === 'number' ? world.minX : -2000) + LIMO_SPAWN_OFFSET_X; } catch (_) {}
    // Ensure sizing applies with the now-defined view
    try { resize(); } catch (_) {}

    // INTERACTIVE SECTIONS (marquees along the runway)
    /**
     * Each section defines: x position, width, title, and content (HTML).
     * The `x` is in world space; we subtract `camera.x` to get screen position.
     */
    // Sections will be defined below; remove placeholders to avoid confusion
    // Single source of truth: sections are defined later with final content
    let sections = [];

    // Define sections used by the seven doors (final content)
    sections = [
      // Quick Sign-Up door near spawn (to the left)
      { x: -615, w: 340, key: 'signup', title: 'Artist Quick Sign-Up', content: `
        <p>Show your style on the runway. Enter the raffle to become a featured artist for an upcoming monthly show.</p>
        <h4>What you’ll make</h4>
        <ul>
          <li>Full VoxEdit gear set: Headpiece, Chest, Arms, Legs</li>
          <li>Optional: Main-hand and Off-hand equipment</li>
          <li>Original, show-safe voxel work created in VoxEdit</li>
        </ul>
        <h4>How selection works</h4>
        <ul>
          <li>New artists enter the primary raffle</li>
          <li>If slots remain, past artists enter a secondary raffle</li>
          <li>After draws, we announce the theme and the deadline</li>
        </ul>
        <h4>Timeline</h4>
        <ul>
          <li>Theme drop → ~3 weeks to finish your gear set</li>
          <li>Submit 3–5 hero images, a short description, and your display name/socials</li>
          <li>Quick tech check before showtime</li>
        </ul>
        <h4>Ready checklist</h4>
        <ul>
          <li>&#9633; VoxEdit installed</li>
          <li>&#9633; Time for ~3 weeks of build/polish</li>
        </ul>
        <p><strong>Need help?</strong> Join Discord for Q&amp;A, feedback, and tech checks.</p>
        <div class="ctaRow">
          <a class="navBtn" href="https://docs.google.com/forms/d/e/1FAIpQLSejCyO7RukrV90BhihqQB3vkTJEC29arEzdcdXc1HONIPfXNQ/viewform?usp=send_form" target="_blank" rel="noopener">Open Artist Raffle Form</a>
          <a class="navBtn" href="https://www.sandbox.game/en/create/vox-edit/" target="_blank" rel="noopener">Download VoxEdit</a>
          <a class="navBtn" href="https://discord.gg/fCMD3NkXMZ" target="_blank" rel="noopener">Join Discord</a>
          <a class="navBtn" href="#" data-close>Back to Runway</a>
        </div>
      `},
      // Door 1 — About This Website
      { x: 400, w: 360, key: 'about', title: 'The Fashion Show Website', content: `
        <p>Step onto the stage. Walk the runway and stop under a door to open a short popup about the show.</p>
        <h4>Controls</h4>
        <ul>
          <li><strong>Move:</strong> &larr; / &rarr; or A / D, or use the on-screen arrows</li>
          <li><strong>Open a door:</strong> Enter or &uarr; / W, or tap the on-screen Enter</li>
          <li><strong>Close a popup:</strong> Esc or &darr; / S, click outside the popup, or tap the X</li>
        </ul>
        <h4>Quick tips</h4>
        <ul>
          <li>Works on desktop and mobile (best in Chrome/Edge/Safari/Firefox)</li>
          <li>If keys don’t respond, click the page once to give it focus</li>
          <li>If layout looks off, rotate your device or hard refresh (Ctrl/Cmd + Shift + R)</li>
        </ul>
        <div class="ctaRow">
          <a class="navBtn" href="#" data-close>Start Walking</a>
          <a class="navBtn" href="#" data-modal="troubleshooting">Troubleshooting</a>
        </div>
      `},
      // Door 2 — The Show
      { x: 1100, w: 360, key: 'show', title: 'The Fashion Show Origin', content: `
        <p>This show was seeded by a community grant from The Sandbox DAO—funding creators to experiment, tell stories, and put voxel fashion in the spotlight. What began as an idea to showcase voxel artists on a catwalk prototype became a full showcase thanks to DAO support and feedback from builders like you. We’re committed to transparency, community credit, and sharing what we learn so more creators can ship bold ideas.</p>
        <div class="ctaRow">
          <a class="navBtn" href="https://www.sandboxdao.com/" target="_blank" rel="noopener">Open The Sandbox DAO</a>
          <a class="navBtn" href="https://forum.sandboxdao.com/t/sandbox-fashion-show/2744" target="_blank" rel="noopener">Read the Proposal</a>
          <a class="navBtn" href="https://discord.gg/fCMD3NkXMZ" target="_blank" rel="noopener">Get Updates (Discord)</a>
        </div>
      `},
      // Door 3 — How the Show Works (In The Sandbox)
      { x: 1900, w: 360, key: 'origin', title: 'What is the Fashion Show', content: `
        <p>Each month, four featured artists present a themed gearset on a playable catwalk inside The Sandbox. Artists walk the runway for live judging, while the audience joins in from the stands.</p>
        <p>During the show, attendees earn Catwalk Coins (CWK) by exploring, dancing, and other ways. Then they spend CWK to vote for their favorite creations. Judges' scores and audience votes are tallied together to spotlight the monthly winner.</p>
        <ul>
          <li>One main show every month</li>
          <li>Four artists compete per show</li>
          <li>Live panel scores: craft, originality, theme fit</li>
          <li>Audience voting with CWK during timed windows (in-experience)</li>
          <li>Live leaderboard moments</li>
        </ul>
        <div class="ctaRow">
          <a class="navBtn" href="https://www.sandbox.game/en/experiences/The%20Sandbox%20-%20Fashion%20Show/e157abb3-bda0-44c5-a769-8f797f1ebbd4/page/" target="_blank" rel="noopener">Visit Experience Page</a>
          <a class="navBtn" href="https://www.sandbox.game/en/create/vox-edit/" target="_blank" rel="noopener">Get VoxEdit (Create Gear)</a>
          <a class="navBtn" href="https://www.sandbox.game/en/create/game-maker/" target="_blank" rel="noopener">Get Game Maker (Build Experiences)</a>
        </div>
      `},
      // Door 4 — Being an Artist on the Show
      { x: 2700, w: 360, key: 'artists', title: 'Being an Artist', content: `
        <p><strong>Build a full voxel gear set in VoxEdit and bring it to the runway.</strong></p>
        <h4>What you make</h4>
        <ul>
          <li><strong>Required:</strong> Headpiece, Chest, Arms, Legs</li>
          <li><strong>Optional:</strong> Main-hand and Off-hand equipment</li>
          <li>Original work, show-safe, and created in VoxEdit</li>
        </ul>
        <h4>How selection works</h4>
        <ul>
          <li>Sign up on the Google Form to enter the primary raffle (new artists first).</li>
          <li>If slots remain, a secondary raffle includes returning artists from past shows.</li>
        </ul>
        <h4>Timeline</h4>
        <ul>
          <li>A theme is announced after the raffle.</li>
          <li>You have ~3 weeks to finish your gear set.</li>
          <li>Deliverables: 3–5 hero images, short description, display name/socials (asset files for tech check).</li>
        </ul>
        <p><strong>Need help?</strong> Join Discord for Q&amp;A, feedback, and tech checks.</p>
        <div class="ctaRow">
          <a class="navBtn" href="https://docs.google.com/forms/d/e/1FAIpQLSejCyO7RukrV90BhihqQB3vkTJEC29arEzdcdXc1HONIPfXNQ/viewform?usp=send_form" target="_blank" rel="noopener">Artist Raffle Form</a>
          <a class="navBtn" href="https://www.sandbox.game/en/create/vox-edit/" target="_blank" rel="noopener">Download VoxEdit</a>
          <a class="navBtn" href="https://discord.gg/fCMD3NkXMZ" target="_blank" rel="noopener">Join Discord</a>
        </div>
      `},
      // Door 5 — Judging & How to Join
      { x: 3500, w: 360, key: 'judging', title: 'Judging', content: `
        <p>Artists show a gearset on the live runway while a panel scores each look and the audience adds momentum.</p>
        <h4>Scoring (how winners are chosen)</h4>
        <p><strong>Panel score (1–5 per judge):</strong> three judges each pick a number from 1–5.</p>
        <p>Criteria the judges consider:</p>
        <ul>
          <li><strong>Craft &amp; Build Quality</strong> — clean geometry, detail, polish</li>
          <li><strong>Originality &amp; Concept</strong> — idea strength, voice, inventiveness</li>
          <li><strong>Runway Readability &amp; Presence</strong> — silhouette, staging, “reads” at a glance</li>
          <li><strong>Theme Fit</strong> — how well it matches the show’s theme/prompt</li>
        </ul>
        <p><strong>Audience bonus (0–1):</strong> adds 0.0 → 1.0 based on Catwalk Coins (CWK) supporting a look during the voting window.<br>
        <small>(Scaled per show; typically requires &gt; 5,000 CWK for the full +1.0 bonus.)</small></p>
        <p><strong>Final tally</strong> = average panel score + audience bonus. Tie-breaks go to panel discussion.</p>
      `},
      // Door 6 — Join the Community
      { x: 4300, w: 380, key: 'community', title: 'Join the Community', content: `
        <p>Backstage passes live on Discord. Get announcements, submission windows, tech checks, WIP feedback, and post-show recaps. Meet other creators, share progress, and help shape what comes next.</p>
        <h4>What you\u2019ll find</h4>
        <ul>
          <li><code>#announcements</code> &mdash; dates, themes, results</li>
          <li><code>#artist-signup</code> &mdash; raffle reminders &amp; guidelines</li>
          <li><code>#wip-critique</code> &mdash; share progress, get feedback</li>
          <li><code>#tech-help</code> &mdash; VoxEdit/GameMaker setup help</li>
          <li><code>#show-chat</code> &mdash; watch parties &amp; discussion</li>
        </ul>
        <h4>Roles &amp; pings</h4>
        <ul>
          <li>Artist / Judge / Audience roles</li>
          <li>Opt-in @Showtime and @ThemeDrop alerts</li>
        </ul>
        <p>Friendly, modded, PG-13 space. Zero harassment. Bring good vibes.</p>
        <div class="ctaRow">
          <a class="navBtn" href="https://discord.gg/fCMD3NkXMZ" target="_blank" rel="noopener">Join Discord</a>
          <a class="navBtn" href="#" data-modal="rules">Read Server Rules</a>
          <a class="navBtn" href="#" data-modal="ask">Ask a Question</a>
        </div>
      `},
      // Door 7 — Schedule & Following Along
      { x: 5200, w: 380, key: 'schedule', title: 'Schedule & Following Along', content: `
        <p>We run one main show every month on the <strong>fredandferd</strong> Twitch channel—live runway, judges on mic, and chat energy. Between shows, follow updates and theme drops on our Impossible Dream Studio X account, or hop into Discord for reminders and Q&amp;A.</p>
        <p><em>Want to help between live shows?</em> Try the Discord judging bot: preview gear sets, score them, and earn a raffle ticket for each valid vote. Tickets are pulled during “Fun Stream Nights” on Twitch.</p>
        <div class="ctaRow">
          <a class="navBtn" href="https://www.twitch.tv/fredandferd" target="_blank" rel="noopener">Follow on Twitch</a>
          <a class="navBtn" href="https://x.com/ImDream_Studio" target="_blank" rel="noopener">Follow on X</a>
          <a class="navBtn" href="https://discord.gg/fCMD3NkXMZ" target="_blank" rel="noopener">Join Discord</a>
        </div>
      `}
    ];

    // Assign per-door backdrop indices (exclude the quick sign-up door)
    (function assignBackdropIndexes(){
      let idx = 0;
      for (const sec of sections) {
        if (sec.key === 'signup') { sec._backdropIndex = 0; continue; }
        idx += 1; sec._backdropIndex = idx; // 1-based
      }
    })();

    // Reflow door positions so billboard appears first, then Quick Sign-Up starts
    // 4000px to the right of the billboard, and remaining doors follow evenly spaced.
    (function reflowDoors(){
      try {
        const spacing = 780;         // even spacing between door centers/anchors
        const brandCenter = (SPAWN_X + BRAND_OFFSET_X);
        const firstDoorOffset = 300; // px to the right of billboard center
        if (sections[0] && sections[0].key === 'signup') {
          sections[0].x = Math.round(brandCenter + firstDoorOffset);
        }
        let x = (sections[0] ? sections[0].x : (brandCenter + firstDoorOffset)) + spacing;
        for (let i = 1; i < sections.length; i++) {
          sections[i].x = Math.round(x);
          x += spacing;
        }
      } catch(_) {}
    })();
    // Compute a little extra world to the right of the last door and position the endcap logo
    const lastRightEdge = stage.leftOffset + Math.max.apply(null, sections.map(s => s.x + s.w));
    const TAIL_GAP = 800; // space after last door
    const ENDCAP_X = lastRightEdge + Math.floor(TAIL_GAP * 0.5); // center branding in the tail gap
    // Add generous walking room on both ends for future easter eggs/partners
    const EXTRA_WALK_LEFT = 2000;
    const EXTRA_WALK_RIGHT = 2000;
    // Update world span
    world.minX = -EXTRA_WALK_LEFT;
    world.maxX = Math.max(world.width, lastRightEdge + TAIL_GAP) + EXTRA_WALK_RIGHT;
    world.width = world.maxX; // keep legacy code that reads width functioning

    // INPUT
    const keys = { left: false, right: false, run: false }; // Track walking directions and run modifier
    // Mouse steering dead zone with hysteresis (screen pixels)
    const MOUSE_DEAD_IN = 16;  // threshold to stop when already moving
    const MOUSE_DEAD_OUT = 28; // threshold to start moving when idle
    // Click/hold-to-walk state (scene-space X target)
    let mouseWalk = { active: false, targetX: null };
    window.addEventListener('keydown', e => { // Keyboard controls
      const k = e.key;
      if (k === 'ArrowLeft' || k === 'a' || k === 'A') { keys.left = true; e.preventDefault(); }
      if (k === 'ArrowRight' || k === 'd' || k === 'D') { keys.right = true; e.preventDefault(); }
      if (k === 'Enter' || k === 'ArrowUp' || k === 'w' || k === 'W') { tryOpen(); e.preventDefault(); }
      if (k === 'ArrowDown' || k === 's' || k === 'S' || k === 'Escape' || k === 'Esc') { closeModal(); e.preventDefault(); }
      if (k === 'Shift') { keys.run = true; }
    });
    window.addEventListener('keyup', e => { // Stop walking when keys released
      const k = e.key;
      if (k === 'ArrowLeft' || k === 'a' || k === 'A') keys.left = false; // Stop left
      if (k === 'ArrowRight' || k === 'd' || k === 'D') keys.right = false; // Stop right
      if (k === 'Shift') keys.run = false; // Stop running
    });

    // Mobile buttons
    const btnLeft  = document.getElementById('btnLeft'); // Left button element
    const btnRight = document.getElementById('btnRight'); // Right button element
    const btnUp    = document.getElementById('btnUp'); // Up/open button
    const btnDown  = document.getElementById('btnDown'); // Down/close button
    const btnEnter = document.getElementById('btnEnter'); // Enter action button
    const paparazziBtn = document.getElementById('paparazziBtn');
    const zoomSlider = document.getElementById('zoomSlider');
    const scrollWrap = document.getElementById('scrollWrap');
    const settingsBtn = document.getElementById('settingsBtn');
    const settingsPanel = document.getElementById('settingsPanel');
    const settingsContent = document.getElementById('settingsContent');
    let settingsOpen = false;
    const press = (k, v) => { keys[k] = v; }; // Helper to set key state
    btnLeft.addEventListener('pointerdown', () => press('left', true)); // Hold left
    btnLeft.addEventListener('pointerup',   () => press('left', false)); // Release left
    btnLeft.addEventListener('pointerleave',() => press('left', false)); // Stop if pointer leaves
    btnRight.addEventListener('pointerdown',() => press('right', true)); // Hold right
    btnRight.addEventListener('pointerup',  () => press('right', false)); // Release right
    btnRight.addEventListener('pointerleave',() => press('right', false)); // Stop if pointer leaves
    btnUp.addEventListener('click', () => tryOpen()); // Tap up to open
    btnDown.addEventListener('click', () => closeModal()); // Tap down to close
    btnEnter.addEventListener('click', () => tryOpen()); // Tap to open
    // Start/stop mouse-driven walking along the carpet
    function startMouseWalk(targetSceneX) {
      mouseWalk.active = true; mouseWalk.targetX = targetSceneX;
      // Decide initial direction from player center in scene space
      const centerScene = (player.x - camera.x) + 16;
      const d = (targetSceneX - centerScene);
      keys.left = d < -3; keys.right = d > 3;
    }
    function stopMouseWalk() {
      mouseWalk.active = false; mouseWalk.targetX = null;
      keys.left = false; keys.right = false;
    }
    function updatePaparazziBtnPosition() {
      if (!paparazziBtn) return;
      if (settingsOpen) return; // controls live in settings; skip world-anchored positioning
      const s = (Number(view && view.scale) || 1) * (Number(view && view.globalScale) || 1);
      const tx = Number(view && view._tx) || 0;
      const ty = Number(view && view._ty) || 0;
      const ox = Number(view && view.offsetX) || 0;
      // Place 120px to the right of the spawn avatar and 40px below the runway baseline
      const sx = (SPAWN_X + 120 - camera.x + ox) * s + tx;
      const sy = (world.runwayY() + 40) * s + ty; // slightly below avatar feet
      paparazziBtn.style.left = Math.round(sx) + 'px';
      paparazziBtn.style.top = Math.round(sy) + 'px';
      if (scrollWrap) {
        // Place Scroll Up bubble directly below the paparazzi button
        const btnH = paparazziBtn.offsetHeight || 24;
        const gap = 8;
        const wrapX = sx;
        const wrapY = sy + btnH + gap;
        scrollWrap.style.left = Math.round(wrapX) + 'px';
        scrollWrap.style.top  = Math.round(wrapY) + 'px';
      }
    }
    if (paparazziBtn) {
      paparazziBtn.addEventListener('click', () => {
        window.paparazziOn = !window.paparazziOn;
        paparazziBtn.setAttribute('aria-pressed', String(window.paparazziOn));
        paparazziBtn.textContent = 'Paparazzi: ' + (window.paparazziOn ? 'On' : 'Off');
      });
    }
    if (zoomSlider) {
      // Repurpose slider: move camera DOWN to reveal more of the TOP (no zoom)
      // Map 0..100 -> 0..250 px of downward scene shift
      const valueToLift = (v) => Math.max(0, Math.min(250, Math.round(250 * (v/100))));
      // Start with no lift (0)
      zoomSlider.value = '0';
      view.yLift = 0;
      view.autoScale = false; // ensure auto zoom doesn’t fight manual lift
      zoomSlider.setAttribute('aria-label', 'Scroll Up');
      zoomSlider.addEventListener('input', () => {
        const lift = valueToLift(Number(zoomSlider.value));
        view.yLift = lift;
      });
    }
    // SETTINGS PANEL WIRES
    function openSettings() {
      settingsOpen = true;
      settingsPanel.style.display = 'block';
      try { settingsContent.appendChild(paparazziBtn); paparazziBtn.style.display = ''; } catch(_){ }
      try { settingsContent.appendChild(scrollWrap); scrollWrap.style.display = ''; } catch(_){ }
      try { settingsContent.appendChild(musicWrap); musicWrap.style.display = ''; } catch(_){ }
      try { if (window.bgAudioControls && window.bgAudioControls.wireSlider) window.bgAudioControls.wireSlider(); } catch(_){}
    }
    function closeSettings() {
      settingsOpen = false;
      settingsPanel.style.display = 'none';
      // Keep controls inside panel; hidden when closed
    }
    if (settingsBtn) settingsBtn.addEventListener('click', () => { settingsOpen ? closeSettings() : openSettings(); });
    const settingsClose = document.getElementById('settingsClose');
    if (settingsClose) settingsClose.addEventListener('click', () => closeSettings());
    // Hide controls by default until settings opened
    try { paparazziBtn.style.display = 'none'; } catch(_){ }
    try { scrollWrap.style.display = 'none'; } catch(_){ }

    // CLICKABLE DOOR HEADERS (open by clicking the marquee header)
    function screenToScene(x, y) {
      // Use the exact scale currently applied to the canvas (view.scale * view.globalScale)
      const s = (Number(view && view.scale) || 1) * (Number(view && view.globalScale) || 1);
      const tx = Number(view && view._tx) || 0;
      const ty = Number(view && view._ty) || 0;
      const ox = Number(view && view.offsetX) || 0;
      return { x: (x - tx) / s - ox, y: (y - ty) / s };
    }
    function sceneToScreen(x, y) {
      const s = (Number(view && view.scale) || 1) * (Number(view && view.globalScale) || 1);
      const tx = Number(view && view._tx) || 0;
      const ty = Number(view && view._ty) || 0;
      const ox = Number(view && view.offsetX) || 0;
      return { x: (x + ox) * s + tx, y: y * s + ty };
    }
    function sectionHeaderAt(sceneX, sceneY) {
      const y = world.runwayY();
      const headerTop = y - 220;
      const headerBottom = y - 140;
      for (const sec of sections) {
        const screenX = (stage.leftOffset + sec.x) - camera.x;
        const x1 = screenX + 18;
        const x2 = x1 + (sec.w - 36);
        const y1 = headerTop;
        const y2 = headerBottom;
        if (sceneX >= x1 && sceneX <= x2 && sceneY >= y1 && sceneY <= y2) return sec;
      }
      return null;
    }
    canvas.addEventListener('click', (e) => {
      if (modalWrap && modalWrap.style.display === 'grid') return; // ignore when modal open
      const pt = screenToScene(e.offsetX, e.offsetY);
      // If clicking the branding at spawn or endcap, open the external experience page
      const r1 = view._spawnBrandRect, r2 = view._endcapBrandRect;
      const inRect = (r) => r && pt.x >= r.x && pt.x <= r.x + r.w && pt.y >= r.y && pt.y <= r.y + r.h;
      if (inRect(r1) || inRect(r2)) {
        window.open('https://www.sandbox.game/en/experiences/The%20Sandbox%20-%20Fashion%20Show/e157abb3-bda0-44c5-a769-8f797f1ebbd4/page/', '_blank', 'noopener');
        return;
      }
      const sec = sectionHeaderAt(pt.x, pt.y);
      if (sec) { openModal(sec.title, sec.content); }
    });
    // Click-and-walk on the red carpet (left mouse button)
    canvas.addEventListener('mousedown', (e) => {
      if (e.button !== 0) return; // left click only
      if (modalWrap && modalWrap.style.display === 'grid') return;
      const pt = screenToScene(e.offsetX, e.offsetY);
      const y = world.runwayY();
      // Detect clicks on/near the red carpet band
      if (pt.y >= y - 8 && pt.y <= y + 28) {
        // Start walking toward current mouse X in scene space
        startMouseWalk(pt.x);
      }
    });
    // While holding, update the target as the mouse moves
    window.addEventListener('mousemove', (e) => {
      if (!mouseWalk.active) return;
      const rect = canvas.getBoundingClientRect();
      const sx = e.clientX - rect.left;
      const sy = e.clientY - rect.top;
      const pt = screenToScene(sx, sy);
      mouseWalk.targetX = pt.x; // update target; movement resolved in update()
    });
    window.addEventListener('mouseup', () => { if (mouseWalk.active) stopMouseWalk(); });
    
    // Touch support (iOS Safari): tap/hold on carpet to walk, slide to steer, lift to stop
    let activeTouchId = null;
    function getTouchById(touchList, id) {
      for (let i = 0; i < touchList.length; i++) if (touchList[i].identifier === id) return touchList[i];
      return null;
    }
    canvas.addEventListener('touchstart', (e) => {
      if (modalWrap && modalWrap.style.display === 'grid') return;
      const t = e.changedTouches && e.changedTouches[0];
      if (!t) return;
      const rect = canvas.getBoundingClientRect();
      const sx = t.clientX - rect.left;
      const sy = t.clientY - rect.top;
      const pt = screenToScene(sx, sy);
      const y = world.runwayY();
      if (pt.y >= y - 8 && pt.y <= y + 28) {
        e.preventDefault(); // prevent page scroll
        activeTouchId = t.identifier;
        startMouseWalk(pt.x);
      }
    }, { passive: false });
    window.addEventListener('touchmove', (e) => {
      if (activeTouchId == null || !mouseWalk.active) return;
      const t = getTouchById(e.changedTouches || [], activeTouchId) || (e.touches && getTouchById(e.touches, activeTouchId));
      if (!t) return;
      const rect = canvas.getBoundingClientRect();
      const sx = t.clientX - rect.left;
      const sy = t.clientY - rect.top;
      const pt = screenToScene(sx, sy);
      mouseWalk.targetX = pt.x;
      e.preventDefault();
    }, { passive: false });
    function endTouchWalk(e) {
      if (activeTouchId == null) return;
      const t = getTouchById(e.changedTouches || [], activeTouchId);
      if (t) { activeTouchId = null; stopMouseWalk(); }
    }
    window.addEventListener('touchend', endTouchWalk, { passive: true });
    window.addEventListener('touchcancel', endTouchWalk, { passive: true });
    canvas.addEventListener('mousemove', (e) => {
      const pt = screenToScene(e.offsetX, e.offsetY);
      const r1 = view._spawnBrandRect, r2 = view._endcapBrandRect;
      const inRect = (r) => r && pt.x >= r.x && pt.x <= r.x + r.w && pt.y >= r.y && pt.y <= r.y + r.h;
      const sec = sectionHeaderAt(pt.x, pt.y);
      const overBrand = inRect(r1) || inRect(r2);
      const overHeader = !!sec;
      const hover = overBrand || overHeader;
      canvas.style.cursor = hover ? 'pointer' : 'default';
      if (hover) {
        const text = overBrand ? 'Fashion Show Experience Page' : 'Open “' + sec.title + '”';
        showHoverTip(e.clientX, e.clientY, text);
      } else {
        hideHoverTip();
      }
    });
    canvas.addEventListener('mouseleave', () => hideHoverTip());
    // MODAL
    const modalWrap = document.getElementById('modalWrap'); // Overlay element
    const modalTitle = document.getElementById('modalTitle'); // Title node inside modal
    const modalContent = document.getElementById('modalContent'); // Content container
    document.getElementById('closeModal').addEventListener('click', closeModal); // Close on button
    modalWrap.addEventListener('click', (e) => { if (e.target === modalWrap) closeModal(); }); // Close when clicking backdrop
    function openModal(title, html) { // Show modal with given title/content
      modalTitle.textContent = title; // Set title text
      modalContent.innerHTML = html; // Inject provided HTML content
      modalWrap.style.display = 'grid'; // Reveal overlay (CSS grid centers modal)
    }
    function closeModal() { // Hide the modal overlay
      modalWrap.style.display = 'none';
    }

    // Allow CTA links inside modals to cross-open sections or close
    const TROUBLESHOOTING_HTML = `
      <h4>Quick fixes (most issues)</h4>
      <ul>
        <li><b>Hard refresh:</b> Ctrl/Cmd + Shift + R</li>
        <li><b>Rotate device:</b> try landscape on mobile</li>
        <li><b>Close other tabs:</b> free a bit of memory/CPU</li>
      </ul>
      <h4>If Enter doesn’t open doors</h4>
      <ul>
        <li>Make sure the avatar is centered under the door</li>
        <li>Try the on-screen Enter button</li>
        <li>Click the page once to give it focus, then press Enter</li>
      </ul>
      <h4>If you can’t move</h4>
      <ul>
        <li>Click the page, then use ← / → or the on-screen arrows</li>
        <li>On mobile, tap the arrows; long-press to keep walking</li>
      </ul>
      <h4>If popups look cut off</h4>
      <ul>
        <li>Zoom 100% (Ctrl/Cmd + 0)</li>
        <li>On mobile, rotate to landscape</li>
      </ul>
      <h4>If it feels slow</h4>
      <ul>
        <li>Close heavy apps/tabs, then reload</li>
        <li>Older phones: give it a few seconds after load</li>
      </ul>
      <h4>Blank page or errors</h4>
      <ul>
        <li>Try another browser (Chrome/Edge recommended)</li>
        <li>Check your connection and reload</li>
      </ul>
      <h4>Need help?</h4>
      <p>Join our Discord for live support.</p>
      <div class="ctaRow">
        <a class="navBtn" href="https://discord.gg/fCMD3NkXMZ" target="_blank" rel="noopener">Join Discord</a>
        <a class="navBtn" href="#" data-close>Back to Site</a>
      </div>
    `;
    const SERVER_RULES_HTML = `
      <p><strong>Be kind, be creative, be safe.</strong></p>
      <ul>
        <li><strong>Respect first.</strong> No harassment, hate speech, or personal attacks.</li>
        <li><strong>Keep it show-safe.</strong> No NSFW, gore, or infringing content.</li>
        <li><strong>Credit creators.</strong> Share only work you own or have permission to post.</li>
        <li><strong>Stay on topic.</strong> Use the right channels (announcements, WIP, help, etc.).</li>
        <li><strong>No spam/scams.</strong> No ads, token shills, or unsolicited DMs.</li>
        <li><strong>Follow staff directions.</strong> Moderators’ decisions keep things safe and fair.</li>
      </ul>
      <p>Questions or issues? Open Ask a Question here or ping a mod in <code>#help-desk</code> once you join.</p>
      <div class="ctaRow">
        <a class="navBtn" href="https://discord.gg/fCMD3NkXMZ" target="_blank" rel="noopener">Join Discord</a>
        <a class="navBtn" href="#" data-close>Back</a>
      </div>
    `;
    const ASK_HTML = `
      <p><strong>Need help fast?</strong></p>
      <ul>
        <li><strong>Tech or setup questions:</strong> join and post in <code>#help-desk</code>.</li>
        <li><strong>Artist logistics (raffle, deadlines, specs):</strong> ask in <code>#artist-signup</code>.</li>
        <li><strong>Private matters or reports:</strong> DM a moderator once you’re in.</li>
      </ul>
      <p>If you don’t use Discord, you can still reach us at <em>[your email here]</em>.</p>
      <div class="ctaRow">
        <a class="navBtn" href="https://discord.gg/fCMD3NkXMZ" target="_blank" rel="noopener">Join Discord</a>
        <a class="navBtn" href="#" data-close>Back</a>
      </div>
    `;
    function openSectionByKey(key) {
      const sec = sections.find(s => s.key === key);
      if (sec) openModal(sec.title, sec.content);
    }
    modalContent.addEventListener('click', (e) => {
      const closeA = e.target.closest('a[data-close]');
      if (closeA) { e.preventDefault(); closeModal(); return; }
      const modalA = e.target.closest('a[data-modal]');
      if (modalA) {
        e.preventDefault();
        const which = modalA.getAttribute('data-modal');
        if (which === 'troubleshooting') openModal('Troubleshooting', TROUBLESHOOTING_HTML);
        else if (which === 'rules') openModal('Server Rules', SERVER_RULES_HTML);
        else if (which === 'ask') openModal('Ask a Question', ASK_HTML);
        return;
      }
      const a = e.target.closest('a[data-open]');
      if (a) { e.preventDefault(); openSectionByKey(a.getAttribute('data-open')); }
    });

    // Build top navigation from sections
    const topNav = document.getElementById('topNav'); // Nav container in top bar
    function buildTopNav() { // Create a button per section
      if (!topNav) return; // Safety: no-op if nav missing
      topNav.innerHTML = ''; // Clear previous items
      sections.forEach(sec => { // For each section, add a button
        const btn = document.createElement('button'); // Create button element
        btn.type = 'button'; // Explicit type to avoid form defaults
        btn.className = 'navBtn';
        btn.textContent = sec.title; // Button label shows section title
        btn.addEventListener('click', () => {
          openModal(sec.title, sec.content); // Clicking opens its modal directly
        });
        topNav.appendChild(btn); // Add to nav bar
      });
    }
    buildTopNav(); // Build the nav at startup

    // Legend dismiss (non-persistent: always shows again on reload)
    (function setupLegendDismiss(){
      const legend = document.getElementById('legend');
      if (!legend) return;
      // Always show on page load (ignore any previous persistence)
      legend.style.display = '';
      // Clean up any old persistent flag that might have been set earlier
      try { localStorage.removeItem('legendDismissed'); } catch(_) {}
      const btn = legend.querySelector('.legendClose');
      if (btn) {
        btn.addEventListener('click', () => {
          legend.style.display = 'none';
        });
      }
    })();

    // TOOLTIP
    const tooltip = document.getElementById('tooltip'); // Tooltip element
    function showTooltip(scrX, scrY, text, openKey) { // Position and show tooltip
      tooltip.textContent = text; // Set text
      tooltip.style.left = scrX + 'px'; // Horizontal position
      tooltip.style.top = scrY + 'px'; // Vertical position
      if (openKey) {
        tooltip.dataset.openKey = openKey;
        tooltip.style.pointerEvents = 'auto';
        tooltip.style.cursor = 'pointer';
        tooltip.title = 'Click to open';
      } else {
        delete tooltip.dataset.openKey;
        tooltip.style.pointerEvents = 'none';
        tooltip.style.cursor = 'default';
        tooltip.removeAttribute('title');
      }
      tooltip.style.display = 'block'; // Make visible
    }
    function hideTooltip() {
      tooltip.style.display = 'none';
      delete tooltip.dataset.openKey;
      tooltip.style.pointerEvents = 'none';
      tooltip.style.cursor = 'default';
      tooltip.removeAttribute('title');
    } // Hide tooltip
    // Click the tooltip to open its target section (if any)
    tooltip.addEventListener('click', () => {
      const key = tooltip.dataset.openKey;
      if (key) { openSectionByKey(key); }
    });

    // Hover tip near pointer for clickable areas (headers/branding)
    const hoverTipEl = document.getElementById('hoverTip');
    function showHoverTip(scrX, scrY, text) {
      if (!hoverTipEl) return;
      hoverTipEl.textContent = text;
      hoverTipEl.style.left = scrX + 'px';
      hoverTipEl.style.top = scrY + 'px';
      hoverTipEl.style.display = 'block';
    }
    function hideHoverTip() { if (hoverTipEl) hoverTipEl.style.display = 'none'; }

    // OPEN section when near
    // Shared proximity threshold to open a door (in px)
    const OPEN_DISTANCE = 80;

    function tryOpen() { // Attempts to open the nearest section if close
      const near = nearestSection(); // Find nearest
      if (near && near.dist < OPEN_DISTANCE) openModal(near.sec.title, near.sec.content); // Open if within threshold
    }

    function nearestSection() { // Returns nearest section to player.x
      let best = null; let bestDist = Infinity; let which = null; // Track best match
      for (const sec of sections) { // Check each section
        const center = stage.leftOffset + sec.x + sec.w/2; // Section center x (shifted by stage offset)
        const d = Math.abs(center - player.x); // Distance to player
        if (d < bestDist) { bestDist = d; which = sec; } // Keep if nearer
      }
      return which ? { sec: which, dist: bestDist } : null; // Return object or null
    }

    // DRAW helpers
    function drawSpotlights() { // Moving soft spotlights to mimic stage lights (warm tone)
      const baseY = world.runwayY() - 180; // Height above runway
      const t = performance.now() * 0.001; // Time in seconds
      // Anchor to visual screen center; compensate for scene nudge so lights stay centered
      const centerX = vw * 0.5 - (view.offsetX || 0);
      const spacing = 240; // distance between spot centers
      const amp = 60;      // side-to-side oscillation amplitude
      const rx = 180, ry = 36; // ellipse radii
      const altDrop = 46;  // vertical drop for every other spotlight
      for (let i = -2; i <= 2; i++) { // Create multiple spot ellipses
        const cx = centerX + i * spacing + Math.sin(t + i) * amp;
        const cy = baseY + (Math.abs(i) % 2 ? altDrop : 0); // stagger alternate lights lower
        ctx.fillStyle = 'rgba(255,220,180,0.06)'; // Warm white
        ctx.beginPath();
        ctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI*2); // Wide, shallow ellipse
        ctx.fill();
      }
    }

    function drawCurtains() { // Big red curtains framing the stage
      const topH = Math.max(60, world.runwayY() - (220 + CURTAIN_LIFT)); // Height of top valance (raised)
      // Extend width beyond screen so edges are never visible when zoomed out
      const s = Number(view && view.scale) > 0 ? Number(view.scale) : 1;
      const bleed = Math.max(200, Math.ceil((1/s - 1) * vw) + 200); // extra draw width on both sides
      const fullW = vw + bleed * 2;
      // Top valance with scalloped bottom edge
      const grdTop = ctx.createLinearGradient(0, 0, 0, topH);
      grdTop.addColorStop(0, '#7e0a16');
      grdTop.addColorStop(1, '#d0142e');
      ctx.fillStyle = grdTop;
      ctx.beginPath();
      ctx.moveTo(-bleed, 0);
      ctx.lineTo(vw + bleed, 0);
      ctx.lineTo(vw + bleed, topH);
      // scallops along the bottom across extended width
      const scallops = 8; const amp = 16; const baseY = topH - 8;
      for (let i = scallops; i >= 0; i--) {
        const x = (i / scallops) * fullW - bleed;
        const cx = x + fullW / scallops / 2;
        const y = baseY + Math.sin(i) * 2; // tiny irregularity
        ctx.quadraticCurveTo(cx, baseY + amp, x - 1, y);
      }
      ctx.closePath();
      ctx.fill();

      // Extend valance far beyond the top so no background shows when zoomed/panned
      const extraTop = Math.max(800, Math.ceil((Number(view && view._ty) || 0) + 400));
      if (extraTop > 0) {
        ctx.fillStyle = grdTop;
        ctx.fillRect(-bleed, -extraTop, vw + bleed * 2, extraTop);
      }

      // Subtle vertical fold texture on the top valance
      ctx.save();
      // Clip to the same valance shape
      ctx.beginPath();
      ctx.moveTo(-bleed, 0);
      ctx.lineTo(vw + bleed, 0);
      ctx.lineTo(vw + bleed, topH);
      const scallops2 = 8; const amp2 = 16; const baseY2 = topH - 8;
      for (let i = scallops2; i >= 0; i--) {
        const x = (i / scallops2) * fullW - bleed;
        const cx = x + fullW / scallops2 / 2;
        const y = baseY2 + Math.sin(i) * 2;
        ctx.quadraticCurveTo(cx, baseY2 + amp2, x - 1, y);
      }
      ctx.closePath();
      ctx.clip();

      // Very subtle vertical folds for texture (low alpha, half-pixel to reduce shimmer)
      ctx.strokeStyle = 'rgba(0,0,0,0.18)';
      ctx.lineWidth = 1;
      for (let x = -bleed + 12; x < vw + bleed - 12; x += 26) {
        const x1 = Math.round(x) + 0.5;
        ctx.beginPath(); ctx.moveTo(x1, 2); ctx.lineTo(x1 - 4, topH - 2); ctx.stroke();
      }
      ctx.strokeStyle = 'rgba(255,255,255,0.06)';
      for (let x = -bleed + 24; x < vw + bleed - 12; x += 26) {
        const x1 = Math.round(x) + 0.5;
        ctx.beginPath(); ctx.moveTo(x1, 2); ctx.lineTo(x1 - 4, topH - 2); ctx.stroke();
      }
      ctx.restore();

      // Side curtains
      const sideW = 120; const sideH = Math.max(120, world.runwayY() - 80);
      const grdSide = ctx.createLinearGradient(0, 0, sideW, 0);
      grdSide.addColorStop(0, '#660812');
      grdSide.addColorStop(0.5, '#c4122b');
      grdSide.addColorStop(1, '#8f0d1b');

      // Left (extend beyond screen)
      ctx.fillStyle = grdSide;
      ctx.fillRect(-bleed, -extraTop, sideW + bleed, sideH + extraTop);
      // Right (mirror)
      const grdSideR = ctx.createLinearGradient(vw - sideW, 0, vw, 0);
      grdSideR.addColorStop(0, '#8f0d1b');
      grdSideR.addColorStop(0.5, '#c4122b');
      grdSideR.addColorStop(1, '#660812');
      ctx.fillStyle = grdSideR;
      ctx.fillRect(vw - sideW, -extraTop, sideW + bleed, sideH + extraTop);

      // Fold lines on side curtains
      ctx.strokeStyle = 'rgba(0,0,0,0.25)';
      ctx.lineWidth = 1.2;
      for (let x = 12; x < sideW; x += 16) {
        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x - 4, sideH); ctx.stroke();
      }
      for (let x = vw - sideW + 4; x < vw - 4; x += 16) {
        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x + 4, sideH); ctx.stroke();
      }

      // (branding moved to spawn area; old top placement disabled)
    }

    function drawRunway() { // Draw runway, edges, and center stripes
      const y = world.runwayY(); // Y coordinate for runway
      const w = world.runwayW(); // Visual runway width (currently not used directly)
      // edges (dark floor beyond runway) — extend beyond screen edges like curtains
      ctx.fillStyle = '#1b1b24';
      {
        const s = Number(view && view.scale) > 0 ? Number(view.scale) : 1;
        const bleed = Math.max(400, Math.ceil((1/s - 1) * vw) + 400);
        ctx.fillRect(-bleed, y + 18, vw + bleed*2, vh - y); // Large rect covering bottom area
      }
      // Overlay a subtle gradient and ensure it reaches the bottom edge
      {
        const sCombined = ((Number(view && view.scale) || 1) * (Number(view && view.globalScale) || 1));
        const bleed2 = Math.max(400, Math.ceil((1/sCombined - 1) * vw) + 400);
        const yTop2 = y + 12;
        const overBottom2 = 300;
        const g2 = ctx.createLinearGradient(0, yTop2, 0, vh + overBottom2);
        g2.addColorStop(0.00, '#1b1b24');
        g2.addColorStop(0.50, '#151820');
        g2.addColorStop(1.00, '#0d0f14');
        ctx.fillStyle = g2;
        ctx.fillRect(-bleed2, yTop2, vw + bleed2*2, (vh + overBottom2) - yTop2);
      }
      // Rope stanchions along the carpet sides (draw BEFORE carpet so carpet is in front)
      const postStep = 140; // distance between posts
      const topY = y - 6;   // near top edge of carpet
      const botY = y + 28;  // near bottom edge of carpet
      const gold = getComputedStyle(document.documentElement).getPropertyValue('--runway-edge') || '#f1cf63';

      // Build screen-space openings where rope should not cross
      const openings = [];
      for (const sec of sections) {
        const left = (stage.leftOffset + sec.x) - camera.x + 18; // just inside left pillar (shifted stage)
        const right = (stage.leftOffset + sec.x) - camera.x + sec.w - 18; // just inside right pillar
        if (right < -50 || left > vw + 50) continue; // skip off-screen
        openings.push({ left, right });
      }
      // Also block posts/ropes from the start up through the limo's right edge
      if (limoReady && limoImg && limoImg.naturalWidth) {
        const isSmallScreenLR = (vw < 900) || (vh < 600);
        const targetHLR = Math.min(448, Math.max(80, Math.floor(vh * (isSmallScreenLR ? 0.22 : 0.18) * 1.6)));
        const scaleLR = targetHLR / limoImg.naturalHeight;
        const dwLR = Math.max(20, Math.round(limoImg.naturalWidth * scaleLR));
        const centerWorldXLR = (world && typeof world.minX === 'number' ? world.minX : -2000);
        const extraLeftLR = 20; // keep aligned with drawLimoLeft
        const worldXLR = Math.floor(centerWorldXLR - dwLR / 2 - extraLeftLR);
        const screenLeftLR = Math.floor(worldXLR - camera.x);
        const padLR = 24;
        const rightEdge = screenLeftLR + dwLR + padLR;
        // One large opening that removes any posts/rope on or before the limo
        openings.push({ left: -100000, right: rightEdge });
      }

      let prevX_rope = null;
      const OVERSCAN = 220;
      for (let sx = -((camera.x % postStep) + postStep) - OVERSCAN; sx < vw + postStep + OVERSCAN; sx += postStep) {
        const insideOpening = openings.some(o => sx > o.left && sx < o.right);
        // Posts: small vertical poles with a gold cap
        ctx.strokeStyle = '#3a2a2a';
        ctx.lineWidth = 3;
        if (!insideOpening) {
          // top row post (audience side only; no near-side post)
          ctx.beginPath(); ctx.moveTo(sx, topY - 2); ctx.lineTo(sx, topY - 18); ctx.stroke();
          // cap
          ctx.fillStyle = gold;
          ctx.beginPath(); ctx.arc(sx, topY - 20, 3, 0, Math.PI*2); ctx.fill();
        }

        // ropes between this and previous post (slight sag), clipped to openings
        if (prevX_rope !== null) {
          let segments = [[prevX_rope, sx]]; // list of drawable segments
          for (const o of openings) {
            const afterCut = [];
            for (const seg of segments) {
              let a = seg[0], b = seg[1];
              const L = o.left, R = o.right;
              const leftX = Math.min(a,b), rightX = Math.max(a,b);
              if (rightX <= L || leftX >= R) { afterCut.push([a,b]); continue; }
              // Intersection exists: keep parts outside [L,R]
              if (leftX < L) afterCut.push([a < b ? leftX : leftX, a < b ? L : L]);
              if (rightX > R) afterCut.push([a < b ? R : R, a < b ? rightX : rightX]);
            }
            segments = afterCut;
          }
          // Draw remaining segments
          ctx.strokeStyle = gold;
          ctx.lineWidth = 1.6;
          for (const seg of segments) {
            const a = seg[0], b = seg[1];
            if (Math.abs(b - a) < 6) continue; // too short to see
            const midX = (a + b) / 2;
            // top rope (far/audience side only)
            ctx.beginPath();
            ctx.moveTo(a, topY - 18);
            ctx.quadraticCurveTo(midX, topY - 12, b, topY - 18);
            ctx.stroke();
          }
        }
        prevX_rope = sx;
      }
      // runway (red carpet strip)
      ctx.shadowColor = 'rgba(255,180,180,0.35)'; // Soft warm glow
      ctx.shadowBlur = 24;
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--runway'); // Use CSS variable
      // Leave a gap under the limo so it sits BEFORE the catwalk
      if (limoReady && limoImg && limoImg.naturalWidth) {
        const isSmallScreenLR2 = (vw < 900) || (vh < 600);
        const targetHLR2 = Math.min(448, Math.max(80, Math.floor(vh * (isSmallScreenLR2 ? 0.22 : 0.18) * 1.6)));
        const scaleLR2 = targetHLR2 / limoImg.naturalHeight;
        const dwLR2 = Math.max(20, Math.round(limoImg.naturalWidth * scaleLR2));
        const centerWorldXLR2 = (world && typeof world.minX === 'number' ? world.minX : -2000);
        const extraLeftLR2 = 20;
        const worldXLR2 = Math.floor(centerWorldXLR2 - dwLR2 / 2 - extraLeftLR2);
        const screenLeftLR2 = Math.floor(worldXLR2 - camera.x);
        const padLR2 = 24;
        // Do NOT draw any carpet to the left of the limo; only start on the right side
        const gapR = screenLeftLR2 + dwLR2 + padLR2;
        const rightStart = Math.max(-2000, Math.min(vw + 2000, gapR));
        const rightEnd = vw + 2000;
        if (rightEnd > rightStart) ctx.fillRect(rightStart, y - 2, rightEnd - rightStart, 24);
      } else {
        ctx.fillRect(-2000, y - 2, vw + 4000, 24); // full strip when no limo computed
      }
      ctx.shadowBlur = 0; // Reset shadow

      // center studs (small gold circles like carpet tacks)
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--runway-edge'); // Gold
      const studsGap = (() => {
        if (limoReady && limoImg && limoImg.naturalWidth) {
          const isSmallScreenLR3 = (vw < 900) || (vh < 600);
          const targetHLR3 = Math.min(448, Math.max(80, Math.floor(vh * (isSmallScreenLR3 ? 0.22 : 0.18) * 1.6)));
          const scaleLR3 = targetHLR3 / limoImg.naturalHeight;
          const dwLR3 = Math.max(20, Math.round(limoImg.naturalWidth * scaleLR3));
          const centerWorldXLR3 = (world && typeof world.minX === 'number' ? world.minX : -2000);
          const extraLeftLR3 = 20;
          const worldXLR3 = Math.floor(centerWorldXLR3 - dwLR3 / 2 - extraLeftLR3);
          const left = Math.floor(worldXLR3 - camera.x) - 24;
          const right = left + dwLR3 + 48;
          return { left, right, ok: true };
        }
        return { ok: false };
      })();
      for (let x = -((camera.x % 80)+80) - 200; x < vw + 80 + 200; x += 80) {
        // Skip all studs to the left of the carpet start (right edge of limo gap)
        if (studsGap.ok && x < studsGap.right) continue;
        ctx.beginPath();
        ctx.arc(x, y + 26, 2.2, 0, Math.PI*2);
        ctx.fill();
      }

      // (No special first post — all posts are uniform)

      // (rope was drawn before carpet)
    }

    // Backstage props spanning the whole back wall (behind doors)
    function drawBackstageProps() {
      if (!(statueReady || chairReady)) return;
      // Hide in portrait; backstage props look cramped on tall screens
      const isPortrait = vh > vw;
      if (isPortrait) return;
      const y = world.runwayY(); // floor baseline
      // Leave space near side curtains
      const sideMargin = 140; // keep a bit of gap from side curtains
      const left = -0 + sideMargin;
      const right = vw - sideMargin;
      if (right <= left) return;
      const items = ['statue','chair','chair','chair','statue'];
      const n = items.length;
      const availableW = right - left;
      // Pull items a bit closer together by shrinking the group width
      const groupScale = 0.82; // 18% tighter spacing
      const groupW = availableW * groupScale;
      const groupLeft = left + (availableW - groupW) / 2;
      // Drop props by 100px to help landscape layouts on phones
      const baseline = Math.floor(y - 54);
      for (let i = 0; i < n; i++) {
        const kind = items[i];
        const img = (kind === 'statue') ? (statueReady ? statueImg : null) : (chairReady ? chairImg : null);
        if (!img) continue;
        // Target heights tuned for balance under the valance (bigger)
        const maxH = Math.max(60, Math.min(260, Math.round(vh * (kind === 'statue' ? 0.28 : 0.20))));
        const scale = maxH / img.naturalHeight;
        const w = Math.max(1, Math.round(img.naturalWidth * scale));
        const h = Math.max(1, Math.round(img.naturalHeight * scale));
        const cx = groupLeft + ((i + 0.5) * (groupW / n));
        const dx = Math.round(cx - w / 2);
        const dy = Math.round(baseline - h);
        ctx.drawImage(img, dx, dy, w, h);
      }
    }

    // Limo at far left of the catwalk (world-anchored at world.minX)
    function drawLimoLeft() {
      if (!limoReady || !limoImg || !limoImg.naturalWidth) return;
      const y = world.runwayY();
      const isSmallScreen = (vw < 900) || (vh < 600);
      // 60% bigger than baseline (1.6x)
      const targetH = Math.min(448, Math.max(80, Math.floor(vh * (isSmallScreen ? 0.22 : 0.18) * 1.6)));
      const scale = targetH / limoImg.naturalHeight;
      const dw = Math.max(20, Math.round(limoImg.naturalWidth * scale));
      const dh = Math.max(20, Math.round(limoImg.naturalHeight * scale));
      // Place limo so that its center is slightly left of the catwalk edge; positive shift moves it further off-screen
      const centerWorldX = (world && typeof world.minX === 'number' ? world.minX : -2000);
      const extraLeft = 20; // pixels to push left from the exact edge (reduced to move it right ~100px)
      const worldX = Math.floor(centerWorldX - dw / 2 - extraLeft);
      const dx = Math.floor(worldX - camera.x);
      // Move up by 25px relative to prior; keep current natural floor contact
      const baseline = Math.floor(y + 26 + 40);
      const dy = Math.floor(baseline - dh);
      // subtle shadow
      ctx.save();
      ctx.shadowColor = 'rgba(0,0,0,0.35)';
      ctx.shadowBlur = 12;
      ctx.drawImage(limoImg, dx, dy, dw, dh);
      ctx.restore();
    }

    function drawMarquee(sec) { // Draw an interactive marquee for a section
      const y = world.runwayY(); // Base Y
      const screenX = (stage.leftOffset + sec.x) - camera.x; // Convert world X to screen X (shifted)
      // Pillars (sides)
      ctx.fillStyle = '#2a2a36';
      ctx.fillRect(screenX, y - 220, 18, 220); // Left pillar
      ctx.fillRect(screenX + sec.w - 18, y - 220, 18, 220); // Right pillar
      // Header panel (screen-like black box)
      const headerTop = y - 220;
      const headerBottom = y - 140;
      // Darker, subtle gradient for the header panel (screen-like)
      const grd = ctx.createLinearGradient(0, headerTop, 0, headerBottom);
      grd.addColorStop(0, '#0d0e12'); // near-black top
      grd.addColorStop(1, '#191a22'); // very dark bottom
      ctx.fillStyle = grd;
      ctx.fillRect(screenX + 18, headerTop, sec.w - 36, 80); // Panel between pillars
      // Title text in the header
      const goldText = getComputedStyle(document.documentElement).getPropertyValue('--accent') || '#f1cf63';
      ctx.fillStyle = goldText;
      ctx.font = '700 20.8px system-ui'; // 30% larger than 16px
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(sec.title, screenX + sec.w/2, y - 180); // Centered label
      // Accent underglow strip
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent');
      ctx.globalAlpha = 0.4; // Semi transparent
      ctx.fillRect(screenX + 20, headerBottom + 2, sec.w - 40, 4); // Thin bar under header
      ctx.globalAlpha = 1; // Restore alpha

      // Flashing bulbs around clickable header panel (door button)
      (function drawHeaderLights(){
        // Round all geometry to whole pixels to avoid subpixel shimmer while panning
        const hx = Math.round(screenX + 18); // header box x
        const hy = Math.round(headerTop);    // header box y
        const hw = Math.round(sec.w - 36);   // header box width
        const hh = 80;                       // header box height
        const gold = getComputedStyle(document.documentElement).getPropertyValue('--accent') || '#f1cf63';
        ctx.save();
        // Twinkling bulbs along the frame (no outline)
        const t = performance.now() * 0.001;
        const bulbSpacing = 20;
        const sprite = ensureBulbSprite();
        const r = sprite.width >> 1; // half size
        // Bring bulbs slightly closer to the header (less up/out)
        const outside = Math.max(2, r - 6);
        ctx.globalCompositeOperation = 'screen';
        // Top edge bulbs (inside panel to avoid clipping)
        for (let x = hx + 8; x <= hx + hw - 8; x += bulbSpacing) {
          const i = Math.floor((x - hx) / bulbSpacing);
          const phase = i * 0.55;
          const pulse = Math.max(0, Math.sin(t * 3.2 + phase));
          const a = 0.16 + Math.pow(pulse, 6) * 0.84;
          // Place bulbs centered on the outside of the top edge
          const gx = Math.round(x), gy = Math.round(hy - outside);
          ctx.globalAlpha = Math.min(1, a);
          ctx.drawImage(sprite, gx - r, gy - r);
        }
        // Left/right edges bulbs (sparser) — no bottom-row bulbs to avoid clipping
        for (let y2 = hy + 12; y2 <= hy + hh - 12; y2 += bulbSpacing * 1.05) {
          const i = Math.floor((y2 - hy) / bulbSpacing);
          const phase = i * 0.6;
          const pulse = Math.max(0, Math.sin(t * 3.2 + phase));
          const a = 0.12 + Math.pow(pulse, 6) * 0.78;
          // Place bulbs centered on the outside of the left/right edges
          const gx1 = Math.round(hx - outside), gy1 = Math.round(y2);
          const gx2 = Math.round(hx + hw + outside), gy2 = Math.round(y2);
          ctx.globalAlpha = Math.min(1, a);
          ctx.drawImage(sprite, gx1 - r, gy1 - r);
          ctx.globalAlpha = Math.min(1, a * 0.9);
          ctx.drawImage(sprite, gx2 - r, gy2 - r);
        }
        ctx.globalAlpha = 1;
        ctx.restore();
      })();

      // Entrance curtains per section: fully open at center, close as you walk away
      const gold = getComputedStyle(document.documentElement).getPropertyValue('--accent') || '#f1cf63';
      const boxX = screenX + 18; const boxW = sec.w - 36; // between the pillars
      // Taller curtains only on mobile landscape so header text is covered there,
      // but keep desktop browsers at the original height.
      const isMobileLandscape = (vw > vh) && IS_TOUCH;
      // Keep curtains above the red carpet (stop right at carpet top)
      const curtainBottomY = Math.floor(world.runwayY() - 2);
      const boxTop = headerBottom; // attach directly to header bottom regardless of zoom
      const boxH = Math.max(12, curtainBottomY - boxTop); // extend down to carpet edge

      // Backdrop image behind the curtains (visible through the opening)
      // Prefer per-door backdrop if available, otherwise fall back to the default image
      const bi = sec._backdropIndex;
      const setEntry = (bi && doorBackdropSet && doorBackdropSet[bi] && doorBackdropSet[bi].ready) ? doorBackdropSet[bi] : null;
      const useImg = setEntry ? setEntry.img : (doorBackdropReady ? doorBackdropImg : null);
      if (useImg && useImg.naturalWidth) {
        ctx.save();
        // Clip to the area between pillars and below the header
        ctx.beginPath();
        ctx.rect(boxX, boxTop, boxW, boxH);
        ctx.clip();
        // Cover-fit the image within the box, preserving aspect ratio
        const iw = useImg.naturalWidth;
        const ih = useImg.naturalHeight;
        const scale = Math.max(boxW / iw, boxH / ih);
        const dw = Math.ceil(iw * scale);
        const dh = Math.ceil(ih * scale);
        const dx = Math.floor(boxX + (boxW - dw) / 2);
        const dy = Math.floor(boxTop + (boxH - dh) / 2);
        ctx.drawImage(useImg, dx, dy, dw, dh);

        ctx.restore();
      }
      const centerXWorld = stage.leftOffset + sec.x + sec.w/2; // world center with stage offset
      const dist = Math.abs(player.x - centerXWorld); // distance from player to center
      // Scale opening radius with zoom so curtains don't open too early when zoomed in
      const radius = 220 * Math.max(1, Number(view && view.scale) || 1); // distance at which curtains fully closed
      const open = Math.max(0, Math.min(1, 1 - dist / radius)); // 0..1
      const minCurtain = 10; // min width of each curtain when fully open
      const overlap = 6; // small overlap so no sliver shows through
      const gap = Math.max(0, open * (boxW - minCurtain*2) - overlap);
      const half = boxW / 2;
      const leftRight = boxX + half - gap/2; // right edge of left curtain
      const rightLeft = boxX + half + gap/2; // left edge of right curtain

      // Curtain gradients (deep red)
      const redL = ctx.createLinearGradient(boxX, boxTop, boxX + half, boxTop);
      redL.addColorStop(0, '#660812'); redL.addColorStop(0.5, '#c4122b'); redL.addColorStop(1, '#8f0d1b');
      const redR = ctx.createLinearGradient(boxX + half, boxTop, boxX + boxW, boxTop);
      redR.addColorStop(0, '#8f0d1b'); redR.addColorStop(0.5, '#c4122b'); redR.addColorStop(1, '#660812');

      // Left curtain
      ctx.fillStyle = redL;
      ctx.fillRect(boxX, boxTop, Math.max(minCurtain, leftRight - boxX), boxH);
      // Right curtain
      ctx.fillStyle = redR;
      ctx.fillRect(rightLeft, boxTop, Math.max(minCurtain, boxX + boxW - rightLeft), boxH);

      // Fold lines for gentle curtain texture (aligned to half-pixels to avoid flicker)
      (function drawFoldLines(){
        const y1 = Math.round(boxTop) + 0.5;
        const y2 = Math.round(boxTop + boxH) + 0.5;
        ctx.strokeStyle = 'rgba(0,0,0,0.22)';
        ctx.lineWidth = 1;
        for (let x = Math.ceil(boxX + 8); x < leftRight; x += 14) {
          const x1 = Math.round(x) + 0.5;
          const x2 = Math.round(x - 3) + 0.5;
          ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();
        }
        for (let x = Math.ceil(rightLeft + 4); x < boxX + boxW - 4; x += 14) {
          const x1 = Math.round(x) + 0.5;
          const x2 = Math.round(x + 3) + 0.5;
          ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();
        }
      })();

      // (Removed gold tiebacks to avoid visual confusion)
      // Instruction bubble if player is close — position just above the avatar's head
      const d = Math.abs(player.x - (stage.leftOffset + sec.x + sec.w/2)); // Distance from player to center
      // Only show the hint when you're firmly inside the open zone
      if (d < Math.max(10, (OPEN_DISTANCE - 10))) { // a little tighter than open distance
        // Anchor tooltip near the avatar's feet (runway level), so it hovers around the shoes
        const footSceneX = (player.x - camera.x) + 16; // player center column
        const footSceneY = y - 6; // just above the carpet baseline
        const pt = sceneToScreen(footSceneX, footSceneY);
        showTooltip(Math.round(pt.x), Math.round(pt.y), 'Press Up or Enter to open', sec.key);
      }
    }
    

    function drawPlayer() { // Avatar (sprite sheet if available; fallback to blocky)
      // Raise the avatar 5px to better center on the catwalk
      const baseY = world.runwayY() - 5;           // Ground baseline (nudged up)
      const px = player.x - camera.x;               // Player X on screen
      const facing = player.facing || 1;            // 1 or -1

      // Shadow
      ctx.fillStyle = 'rgba(0,0,0,0.35)';
      ctx.beginPath();
      // Nudge shadow up a bit to sit tighter under the feet
      ctx.ellipse(px + 16, baseY + 14, 22, 6, 0, 0, Math.PI*2);
      ctx.fill();

      // Prefer sprite sheet rendering when available
      if (AVATAR && AVATAR.ready) {
        const seq = AVATAR.seq[player.anim && player.anim.key] || AVATAR.seq.idleRight;
        const frame = (player.anim && Number.isFinite(player.anim.frame)) ? (player.anim.frame % seq.len) : 0;
        const sx = frame * AVATAR.fw;
        const sy = seq.row * AVATAR.fh;

        // Scale sprite relative to viewport so the figure reads well on all screens
        const isSmallScreen = (vw < 900) || (vh < 600);
        const targetHBase = Math.max(80, Math.min(160, Math.floor(vh * 0.26)));
        const targetH = isSmallScreen ? Math.floor(targetHBase * 1.05) : targetHBase;
        const targetHScaled = Math.floor(targetH * (AVATAR.sizeMul || 1));
        const scale = targetHScaled / AVATAR.fh;
        const dw = Math.floor(AVATAR.fw * scale);
        const dh = Math.floor(AVATAR.fh * scale);

        // Center on player column; anchor feet to carpet
        const dx = Math.floor(px + 16 - dw / 2);
        // Anchor the soles to the carpet using footInset pixels from bottom of source frame
        let dy = Math.floor(baseY - (dh - Math.floor((AVATAR.footInset||0) * scale)));
        // Apply screen-space nudge to push the sprite down/up relative to the carpet
        dy += Math.floor(AVATAR.yNudge || 0);

        // Draw with crisp pixels if the art is low-res
        const prevSmooth = ctx.imageSmoothingEnabled;
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(AVATAR.img, sx, sy, AVATAR.fw, AVATAR.fh, dx, dy, dw, dh);
        ctx.imageSmoothingEnabled = prevSmooth;
        return; // sprite drawn; skip fallback
      }

      // Walk cycle params
      const cadence = 5.2;                          // steps per second-ish
      const phase = player.t * cadence;             // phase angle
      const gait = Math.sin(phase);
      const bob = 0;                                // keep anchors fixed; no vertical bob

      // Model proportions (in pixels)
      const torsoW = 18, torsoH = 24;
      const headS = 14;
      const upperArm = 14, foreArm = 12, armT = 5;
      const thigh = 18, shin = 18, legT = 6;

      // Anchor (hips) and shoulders
      const hips = { x: px + 16, y: baseY - 22 - bob }; // lowered ~10px to sit on carpet
      const shoulders = { x: hips.x, y: hips.y - torsoH + 2 };

      // No canvas flip; keep anchors absolutely fixed to prevent any jumping

      // Helper: draw a rotated rectangle segment anchored at (ax,ay)
      // Adds a small overlap into the parent joint to avoid gaps and draws an outline.
      function segment(ax, ay, len, thick, angleRad, color) {
        const overlap = 2; // pixels to bury into the parent joint to hide seams
        ctx.save();
        ctx.translate(ax, ay);
        ctx.rotate(angleRad);
        ctx.fillStyle = color;
        ctx.fillRect(-thick/2, -overlap, thick, len + overlap);
        // outline for consistency with head/torso
        ctx.strokeStyle = '#101218';
        ctx.lineWidth = 1;
        ctx.strokeRect(Math.round(-thick/2)+0.5, Math.round(-overlap)+0.5, thick, len + overlap);
        ctx.restore();
        // return end point of the segment (for chaining)
        return {
          x: ax + Math.sin(angleRad) * len,
          y: ay + Math.cos(angleRad) * len,
        };
      }

      // Determine limb angles for a normal gait
      const thighAmp = 0.55;  // radians swing ~31°
      const shinBase = 0.25;  // base knee bend
      const armAmp = 0.45;    // arm swing ~26°

      // Back vs front decision so we render depth correctly
      // When gait>0, left leg forward, right back (arbitrary); draw back limb first
      const drawBackFirst = gait > 0; // simplifies ordering

      // Colors (slight depth shading for back limbs)
      const frontCol = '#e6e9ef';
      const backCol  = '#c9cdd6';
      const bodyCol  = '#e9ecf3';
      const outline  = '#101218';

      // Legs
      function drawLeg(side) { // side: -1 = left, +1 = right
        const swing = (side === -1 ? gait : -gait);
        const legAng = swing * thighAmp + 0.03; // single solid limb angle
        const color = (swing < 0 ? backCol : frontCol);
        // Compute length so ankle hits the carpet regardless of angle
        const startX = hips.x + side*6, startY = hips.y - 2;
        const dy = (baseY - startY);
        const cosA = Math.max(0.6, Math.cos(legAng)); // avoid extreme lengths near 90°
        const legLen = Math.max(thigh + shin - 2, dy / cosA);
        segment(startX, startY, legLen, legT, legAng, color);
        // no feet: legs meet the carpet directly
      }

      // Arms (counter-swing to legs)
      function drawArm(side) { // side: -1 = left, +1 = right
        const swing = (side === -1 ? -gait : gait);
        const armAng = swing * armAmp - 0.1; // single solid arm angle
        const color = (swing > 0 ? backCol : frontCol);
        // Anchor stays fixed at torso edge; prevents any lateral 'teleporting'
        const torsoLeft  = shoulders.x - torsoW/2;
        const torsoRight = shoulders.x + torsoW/2;
        const anchorX = (side === -1) ? (torsoLeft + 2) : (torsoRight - 2);
        const anchorY = shoulders.y + 4;
        segment(anchorX, anchorY, upperArm + foreArm, armT, armAng, color);
      }

      // Draw order: back leg, back arm, torso+head, front arm, front leg
      if (drawBackFirst) { drawLeg(+1); drawArm(+1); } else { drawLeg(-1); drawArm(-1); }

      // Torso (block)
      ctx.save();
      ctx.fillStyle = bodyCol;
      ctx.strokeStyle = outline;
      ctx.lineWidth = 1.2;
      ctx.fillRect(shoulders.x - torsoW/2, shoulders.y, torsoW, torsoH);
      ctx.strokeRect(shoulders.x - torsoW/2, shoulders.y, torsoW, torsoH);
      ctx.restore();

      // Head (square)
      ctx.save();
      ctx.fillStyle = bodyCol;
      ctx.strokeStyle = outline;
      ctx.lineWidth = 1.2;
      const headX = shoulders.x - headS/2;
      const headY = shoulders.y - headS - 4;
      ctx.fillRect(headX, headY, headS, headS);
      ctx.strokeRect(headX, headY, headS, headS);
      ctx.restore();

      // Front limbs on top
      if (drawBackFirst) { drawArm(-1); drawLeg(-1); } else { drawArm(+1); drawLeg(+1); }
    }

    function drawBackgroundParallax() { // Rows of audience dots moving slower than foreground (parallax)
      const yBase = world.runwayY(); // Base y near runway level
      const rows = 3; // Number of audience rows
      for (let r = 0; r < rows; r++) { // For each row
        const rowY = yBase - 50 - r*26; // Higher for further rows
        const density = 0.002 * (r+1); // More sparse further back
        for (let x = -100; x < vw + 100; x += 12) { // Across the screen
          const wx = Math.floor((x + camera.x * (0.3 + r*0.15))); // World-ish x for randomization
          // pseudo-random scatter using a simple LCG-like hash
          if (((wx * 1103515245 + 12345) >>> 0) % Math.floor(1/density) === 0) {
            ctx.fillStyle = 'rgba(255,255,255,' + (0.12 + r*0.06) + ')'; // light dots for dark background
            ctx.fillRect(x, rowY + ((wx>>3)%5), 2, 2); // Tiny audience dot
          }
        }
      }
    }

    // FOREGROUND PAPARAZZI (blocky silhouettes with occasional camera flashes)
    function drawPaparazziForeground(layer) {
      const y = world.runwayY();                     // runway baseline
      // Keep silhouettes lower in landscape so they don't sit mid-screen
      const isLandscape = vw > vh;
      // Position feet depending on layer: 'back' sits further down and dimmer; default is foreground
      const footBase = (layer === 'back')
        ? (isLandscape ? (vh - 120) : (vh - 220))
        : (isLandscape ? (vh - 50) : (vh - 160));
      const t = performance.now() * 0.001;
      const spacing = layer === 'back' ? 260 : 220;          // base spacing; back row a bit wider
      const rx = layer === 'back' ? 140 : 180, ry = 36;      // flash halo size

      // simple deterministic pseudo-random
      const rnd = (n) => { const s = Math.sin(n) * 43758.5453; return s - Math.floor(s); };

      for (let pass = 0; pass < 2; pass++) { // second pass doubles count
        const xOffset = pass ? spacing / 2 : 0;   // stagger horizontally
        const yDrop   = 0;                         // keep feet aligned at the bottom
        // Iterate over world-space positions so figures are stationary in the world
        const worldStart = Math.floor((camera.x - 160) / spacing) * spacing;
        const worldEnd = camera.x + vw + 160;
        for (let wx = worldStart; wx < worldEnd; wx += spacing) {
          const cell = Math.floor((wx + xOffset) / spacing) + pass * 997;
          const seed = cell * 918273 + 13579;
          const jitter = (rnd(seed) - 0.5) * 80; // +/- 40px in screen space
          const rawH = 72 + Math.floor(rnd(seed + 1) * 44); // 72..116
          const w = 22 + Math.floor(rnd(seed + 2) * 10); // 22..32
          const sx = Math.floor((wx - camera.x) + xOffset + jitter);
          const footY = footBase + yDrop;
          // Ensure silhouettes never overlap the carpet: clamp height to foreground space
          const maxH = Math.max(24, footY - (y + 48));
          const h = Math.min(rawH, maxH);

          // Silhouette body (blocky / voxel-like)
          ctx.save();
          // compute camera/face params regardless of layer so flashes have anchors
          const head = 16 + Math.floor(rnd(seed + 3) * 4);
          const camW = 14, camH = 8;
          const camY = footY - h - Math.floor(head * 0.5);
          const faceRight = (cell % 2) === 0; // every other paparazzi faces left
          const camX = faceRight ? (sx + w + 6) : (sx - 6 - camW);
          if (layer !== 'back') {
            ctx.fillStyle = 'rgba(8,10,14,0.88)';
            // body
            ctx.fillRect(sx, footY - h, w, h);
            // head (square)
            ctx.fillRect(sx + Math.floor(w/2 - head/2), footY - h - head - 2, head, head);
            // camera box
            ctx.fillRect(camX, camY, camW, camH);
            // lens nub
            if (faceRight) {
              ctx.fillRect(camX + camW - 4, camY + 2, 4, 4);
            } else {
              ctx.fillRect(camX, camY + 2, 4, 4);
            }
            // arm to camera
            if (faceRight) {
              ctx.fillRect(sx + w - 3, camY + 2, 6, 6);
            } else {
              ctx.fillRect(sx - 3, camY + 2, 6, 6);
            }
          }

          // occasional flash
          const period = 2.5 + rnd(seed + 4) * 2.0;        // 2.5..4.5s
          const phase = (t + rnd(seed + 5) * period) % period;
          // paparazzi flash (softened)
          if (phase < 0.12) {
            const fx = faceRight ? (camX + camW) : camX;
            const fy = camY + camH / 2;
            const g = ctx.createRadialGradient(fx, fy, 0, fx, fy, rx);
            g.addColorStop(0, (layer === 'back') ? 'rgba(255,255,220,0.12)' : 'rgba(255,255,220,0.18)');
            g.addColorStop(1, 'rgba(255,255,220,0)');
            ctx.fillStyle = g;
            ctx.beginPath(); ctx.arc(fx, fy, rx, 0, Math.PI * 2); ctx.fill();
            // bright sparkle
            ctx.fillStyle = (layer === 'back') ? 'rgba(255,250,200,0.4)' : 'rgba(255,250,200,0.6)';
            ctx.beginPath(); ctx.arc(fx, fy, layer === 'back' ? 3 : 4, 0, Math.PI * 2); ctx.fill();
          }
          ctx.restore();
        }
      }
    }

    function update(dt) { // Update simulation for one frame
      player.walking = false; // Reset walking flag
      const runMul = keys.run ? 3.6 : 1; // Shift to run (doubled sprint speed)

      // When holding mouse, continuously steer based on mouse X vs avatar center
      if (mouseWalk.active && mouseWalk.targetX != null) {
        const centerScene = (player.x - camera.x) + 16;
        const d = mouseWalk.targetX - centerScene;
        const moving = (keys.left || keys.right);
        const thresh = moving ? MOUSE_DEAD_IN : MOUSE_DEAD_OUT;
        if (Math.abs(d) <= thresh) {
          // In dead zone: idle but face toward mouse side if offset exists
          keys.left = false; keys.right = false;
          if (d > 0) player.facing = 1; else if (d < 0) player.facing = -1;
        } else if (d > thresh) {
          keys.left = false; keys.right = true; player.facing = 1;
        } else if (d < -thresh) {
          keys.left = true; keys.right = false; player.facing = -1;
        }
      }
      if (keys.left)  { player.x -= world.speed * runMul * 60 * dt; player.facing = -1; player.walking = true; } // Move left
      if (keys.right) { player.x += world.speed * runMul * 60 * dt; player.facing = 1;  player.walking = true; } // Move right
      player.x = Math.max(world.minX, Math.min(world.maxX, player.x)); // Clamp player within world bounds
      if (player.walking) player.t += dt * (keys.run ? 3.0 : 1); else player.t *= 0.8; // Faster gait when running (doubled)

      // Update avatar sprite animation (idle/walk + facing)
      if (!player.anim) player.anim = { key: 'idleRight', frame: 0, accum: 0 };
      const prevKey = player.anim.key;
      let nextKey;
      if (player.walking) {
        if (keys.run && AVATAR && AVATAR.seq && (AVATAR.seq.sprintRight && AVATAR.seq.sprintLeft)) {
          nextKey = (player.facing === 1) ? 'sprintRight' : 'sprintLeft';
        } else {
          nextKey = (player.facing === 1) ? 'walkRight' : 'walkLeft';
        }
      } else {
        nextKey = (player.facing === 1) ? 'idleRight' : 'idleLeft';
      }
      if (nextKey !== prevKey) { player.anim.key = nextKey; player.anim.accum = 0; player.anim.frame = 0; }
      const seq = (AVATAR && AVATAR.seq[player.anim.key]) ? AVATAR.seq[player.anim.key] : { len: 1, fps: 1 };
      player.anim.accum += dt * seq.fps;
      player.anim.frame = Math.floor(player.anim.accum) % seq.len;

      // camera follows with smoothing, while keeping player on-screen with margins
      // Bias a bit more to the left so the camera pans left sooner (shows more of left side)
      const baseTarget = player.x - vw * 0.55;
      // Screen margin constraints (pixels) accounting for scene nudge
      const margin = { left: 60, right: 60 };
      const pxNudge = (view.offsetX || 0);
      const lowerBound = player.x + pxNudge - (vw - margin.right); // min camera.x so player not off right
      const upperBound = player.x + pxNudge - margin.left;          // max camera.x so player not off left
      // World bounds for camera, using extended walk space
      const worldMin = world.minX;
      const worldMax = Math.max(0, world.maxX - vw);
      // Valid camera range intersection
      const camMin = Math.max(worldMin, lowerBound);
      const camMax = Math.min(worldMax, upperBound);
      // Clamp target into valid range
      let target = Math.max(camMin, Math.min(camMax, baseTarget));
      camera.x += (target - camera.x) * 0.12; // Ease camera towards target
      // Hard-ensure player remains within on-screen margins after easing
      const playerScreenX = player.x - camera.x;
      if (playerScreenX < margin.left) {
        camera.x = player.x - margin.left;
      } else if (playerScreenX > (vw - margin.right)) {
        camera.x = player.x - (vw - margin.right);
      }
      // Clamp to world bounds
      camera.x = Math.max(worldMin, Math.min(worldMax, camera.x));
    }

    let last = performance.now(); // Timestamp of previous frame
    function frame(now) { // Main animation loop
      const dt = Math.min(0.05, (now - last) / 1000); // Delta time in seconds (clamped)
      last = now; // Store current time for next frame
      update(dt); // Step the simulation

      // Clear entire canvas in device pixels regardless of transform
      ctx.save();
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.restore();

      // Apply view zoom (uniform scale) with slight upward bias on zoom-out
      const baseScale = Number(view.baseScale) || 1.5;
      const s0 = Number(view.scale) > 0 ? Number(view.scale) : baseScale;
      const g = Number(view.globalScale) > 0 ? Number(view.globalScale) : 1;
      const s = s0 * g; // apply global scale-down (e.g., 0.7 for ~30% smaller)
      const minS = (Number(window.zoomMinScale || 0.6)) * g;
      const xAnchor = vw * 0.5;           // anchor horizontally at screen center
      const yAnchor = world.runwayY();    // anchor vertically at runway
      const tx = xAnchor * (1 - s);
      const zoomOut = Math.max(0, Math.min(1, (baseScale - s) / Math.max(0.0001, baseScale - minS)));
      const tyCenter = yAnchor * (1 - s);
      const extraUp = 160 * zoomOut;      // move scene up as you zoom out (more headroom above doors)
      const tyCap = -yAnchor * 0.92;      // do not overshoot the very top
      // Apply additional manual lift from slider (move scene DOWN to reveal more of the TOP)
      // Positive values shift the scene downward; clamp to a max of +250px
      const lift = Math.max(0, Math.min(250, Number(view.yLift) || 0));
      const ty = Math.max(tyCap, Math.min(250, (tyCenter - extraUp) + lift));
      view._tx = tx; view._ty = ty; // expose current transform for input mapping
      ctx.setTransform(DPR * s, 0, 0, DPR * s, DPR * tx, DPR * ty);
      // Optional extra nudge (not used by default; stage.leftOffset handles layout)
      if (view.offsetX) ctx.translate(view.offsetX, 0);

      // ambient background with subtle marble texture
      const bgCol = getComputedStyle(document.documentElement).getPropertyValue('--bg') || '#12090c';
      const OVERSCAN = 220; // extend drawing beyond edges to avoid slivers at 100% zoom
      ctx.fillStyle = bgCol;
      ctx.fillRect(-OVERSCAN, -OVERSCAN, vw + OVERSCAN*2, vh + OVERSCAN*2);
      if (marbleTex) {
        ctx.save();
        ctx.globalAlpha = 0.55; // slightly stronger to keep marble visible
        // Draw with overscan so edges never reveal gaps
        ctx.drawImage(marbleTex, -OVERSCAN, -OVERSCAN, vw + OVERSCAN*2, vh + OVERSCAN*2);
        ctx.restore();
      }

      // drawBackgroundParallax(); // Disabled to remove tiny background speckle dots
      
      drawCurtains();           // Big red curtains framing the stage
      drawSpotlights();         // Moving soft lights (in front of curtains)

      drawRunway();             // Ground and runway
      drawLimoLeft();           // Limo at far left edge
      drawBackstageProps();     // Statues and chairs across the back wall

      // Draw branding/billboard in front of backstage props
      drawSpawnBranding();      // Branding at spawn, stays put as you walk away
      drawEndcapBranding(ENDCAP_X); // Second branding after last door for a visual endcap
      if (window.paparazziOn !== false) drawPaparazziStrip(); // PNG robots row
      try { updatePaparazziBtnPosition(); } catch (_) {}

      // sections
      hideTooltip(); // Hide tooltip before possibly showing it for a nearby section
      for (const sec of sections) { // Render visible marquees
        const scrX = (stage.leftOffset + sec.x) - camera.x; // Screen x for culling (shifted)
        if (scrX + sec.w < -50 || scrX > vw + 50) continue; // Skip if far off-screen
        drawMarquee(sec); // Draw this marquee
      }
      
       // Foreground silhouettes and flashes (behind player)
      drawPlayer(); // Draw the model/figure

      // edge fades to soften edges (disabled by default to avoid visible side bands)
      const bgCol2 = getComputedStyle(document.documentElement).getPropertyValue('--bg') || '#12090c';
      const isLandscape = vw > vh;
      if (view.edgeFades && (!isLandscape || view.edgeFadesInLandscape)) {
        ctx.save();
        if (view.offsetX) ctx.translate(-view.offsetX, 0); // undo scene nudge for fades
        const g = ctx.createLinearGradient(0,0,80,0); g.addColorStop(0,bgCol2); g.addColorStop(1,'transparent'); // Left fade
        ctx.fillStyle = g; ctx.fillRect(0,0,80,vh);
        const g2 = ctx.createLinearGradient(vw,0,vw-80,0); g2.addColorStop(0,bgCol2); g2.addColorStop(1,'transparent'); // Right fade
        ctx.fillStyle = g2; ctx.fillRect(vw-80,0,80,vh);
        ctx.restore();
      }

      requestAnimationFrame(frame); // Queue next frame
    }
    requestAnimationFrame(frame); // Kick off animation loop
  })(); // End IIFE
  </script>
  <!-- Background music: loops and autoplays; volume controlled via settings -->
  <audio id="bgAudio" src="fashion_show_song_0.wav" preload="auto" loop muted playsinline></audio>
  <script>
    (function () {
      const audio = document.getElementById('bgAudio');
      if (!audio) return;
      let ctx = null, source = null, gain = null;
      const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
      const getPct = () => {
        const v = Number(localStorage.getItem('musicVolPct'));
        return Number.isFinite(v) ? clamp(v, 0, 150) : 60; // default 60%
      };
      const ensureGraph = () => {
        if (ctx) return;
        try { ctx = new (window.AudioContext || window.webkitAudioContext)(); } catch(_) { ctx = null; }
        // Try to build routing graph; if not possible, we will fall back to element volume
        if (ctx) {
          try { source = ctx.createMediaElementSource(audio); } catch(_) { source = null; }
          try {
            gain = ctx.createGain();
            gain.gain.value = clamp(getPct()/100, 0, 1.5);
            if (source) source.connect(gain);
            gain.connect(ctx.destination);
            // mute element's direct output to avoid double audio only if we have a routed graph
            if (source) audio.volume = 0;
          } catch(_) { ctx = null; gain = null; source = null; }
        }
        // If WebAudio not available, fallback to element volume immediately
        if (!ctx || !gain) {
          audio.volume = clamp(getPct()/100, 0, 1);
        }
      };
      function setVolumePct(pct) {
        pct = clamp(Number(pct)||0, 0, 150);
        localStorage.setItem('musicVolPct', String(pct));
        if (gain) gain.gain.value = pct/100;
        // Always set element volume as a fallback (caps at 1.0)
        audio.volume = Math.min(1, pct/100);
      }
      function wireSlider() {
        const slider = document.getElementById('musicSlider');
        const label = document.getElementById('musicLabel');
        if (!slider) return;
        slider.min = '0'; slider.max = '150'; slider.step = '1';
        const val = getPct();
        slider.value = String(val);
        if (label) label.textContent = val + '%';
        const applyVolumeFromUI = () => {
          const v = Number(slider.value)||0;
          if (label) label.textContent = v + '%';
          setVolumePct(v);
          ensureGraph();
          if (ctx && ctx.state === 'suspended') { try { ctx.resume(); } catch(_) {} }
          // Unmute and play when volume > 0 so users hear changes immediately
          if (v > 0) {
            audio.muted = false;
            // Start playback in response to this gesture
            audio.play().catch(() => {});
          } else {
            // Keep audible path at 0 but also mute element for clarity
            if (gain) gain.gain.value = 0;
            audio.muted = true;
          }
        };
        slider.addEventListener('input', applyVolumeFromUI);
        slider.addEventListener('change', applyVolumeFromUI);
      }
      const unlock = () => {
        ensureGraph();
        if (ctx && ctx.state === 'suspended') { try { ctx.resume(); } catch(_) {} }
        // Apply stored volume and unmute
        setVolumePct(getPct());
        audio.muted = false;
        audio.play().catch(() => {});
        window.removeEventListener('pointerdown', unlock);
        window.removeEventListener('keydown', unlock);
      };
      // Start muted; route through Web Audio once unlocked
      audio.volume = 0;
      audio.play().catch(() => {});
      window.addEventListener('pointerdown', unlock);
      window.addEventListener('keydown', unlock);
      // Wire slider if present and expose controls for settings
      wireSlider();
      window.bgAudioControls = {
        setVolumePct,
        getVolumePct: getPct,
        wireSlider,
        ensure: ensureGraph,
        kick: () => { unlock(); }
      };
    })();
  </script>
</body>
</html>






