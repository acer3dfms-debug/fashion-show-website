<!DOCTYPE html> <!-- Tell the browser this is an HTML5 document -->
<html lang="en"> <!-- Root element with language set to English -->
<head>
  <meta charset="utf-8" /> <!-- Use UTF-8 character encoding -->
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" /> <!-- Responsive + use full safe area on iOS -->
  <!-- Make the browser UI bars match the dark theme (iOS Safari honors media-specific theme-color) -->
  <meta name="theme-color" media="(prefers-color-scheme: light)" content="#15171c" />
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#15171c" />
  <meta name="color-scheme" content="dark" />
  <!-- The following two affect iOS only when added to Home Screen (PWA mode) -->
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  <title>Fashion Show</title> <!-- Browser tab title -->
  <style>
    :root { /* CSS variables for theme colors used throughout */
      --bg: #15171c;            /* Dark grey marble base background */
      --runway: #b60c2f;        /* Red carpet color */
      --runway-edge: #f1cf63;   /* Gold accents */
      --accent: #f1cf63;        /* Gold accents for UI */
      --ui: #ffffff;            /* General UI text color */
      --spot: rgba(255,255,255,0.06); /* Soft spotlight color */
      --modal-bg: rgba(0,0,0,0.6);    /* Dim background behind modal */
    }
    html, body {
      margin: 0; height: 100%; background: var(--bg); color: var(--ui); /* Full-height dark background */
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; /* Nice default font stack */
      overflow: hidden; /* Hide scrollbars; camera handles movement */
    }
    #uiBar { /* Top translucent UI bar (fully disabled) */
      position: fixed; left: 0; right: 0; top: 0; height: 0; padding: 0; z-index: 0;
      background: transparent !important;
      display: none !important; /* Completely hide bar and its gradient */
      pointer-events: none;
    }
    #topNav, #uiBar .chip { display: none !important; }
    #uiBar .chip { pointer-events: auto; background: rgba(255,255,255,0.1); border: 1px solid rgba(255,255,255,0.2); padding: 6px 10px; border-radius: 999px; backdrop-filter: blur(8px); } /* Small pill badges */
    /* Top navigation (click to open sections) */
    #topNav { position: absolute; left: 50%; transform: translateX(-50%); top: 10px; display: flex; gap: 8px; align-items: center; justify-content: center; pointer-events: auto; overflow-x: auto; max-width: 92vw; padding: 2px 6px; } /* Centered, scrollable menu */
    #topNav::-webkit-scrollbar { display: none; } /* Hide   WebKit */
    .navBtn { appearance: none; background: rgba(255,255,255,0.1); color: var(--ui); border: 1px solid rgba(255,255,255,0.2); border-radius: 999px; padding: 6px 10px; white-space: nowrap; cursor: pointer; backdrop-filter: blur(8px); } /* Button styling */
    .navBtn:hover { background: rgba(255,255,255,0.18); } /* Hover state */
    #legend { position: fixed; bottom: 10px; left: 10px; z-index: 5; font-size: 12px; opacity: 0.85; line-height: 1.4; background: rgba(0,0,0,0.35); padding: 8px 10px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.1); max-width: min(92vw, 420px); overflow-wrap: anywhere; } /* On-screen help */
    #tooltip { position: fixed; padding: 8px 10px; background: rgba(20,20,30,0.9); color: var(--ui); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; pointer-events: none; transform: translate(-50%, -120%); white-space: nowrap; z-index: 4; display: none; } /* Floating hint bubble */
    #hoverTip { position: fixed; padding: 6px 8px; background: rgba(20,20,30,0.9); color: var(--ui); border: 1px solid rgba(255,255,255,0.2); border-radius: 6px; pointer-events: none; transform: translate(10px, -10px); white-space: nowrap; z-index: 6; display: none; font-size: 12px; }
    #modalWrap { position: fixed; inset: 0; display: none; place-items: center; background: var(--modal-bg); backdrop-filter: blur(6px); z-index: 10; } /* Fullscreen modal overlay */
    #modal { width: min(720px, 92vw); max-height: 80vh; overflow: auto; background: #121219; border: 1px solid rgba(255,255,255,0.15); border-radius: 16px; box-shadow: 0 20px 60px rgba(0,0,0,0.6); } /* Modal panel */
    #modal header { display:flex; align-items:center; justify-content:space-between; padding: 14px 16px; border-bottom: 1px solid rgba(255,255,255,0.1); position: sticky; top:0; background:#121219; } /* Sticky modal header */
    #modal .content { padding: 16px; } /* Modal content area */
    #closeModal { appearance: none; background: rgba(255,255,255,0.1); color: var(--ui); border: 1px solid rgba(255,255,255,0.2); border-radius: 10px; padding: 6px 10px; cursor: pointer; } /* Close button */

    /* Mobile controls (optional) */
    #controls { position: fixed; right: 12px; bottom: 12px; display: grid; gap: 8px; z-index: 6; } /* Docked control cluster */
    #controls button { appearance: none; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.08); color: var(--ui); border-radius: 12px; font-size: 14px; padding: 10px 12px; min-width: 44px; backdrop-filter: blur(6px); } /* Tappable buttons */

    /* Paparazzi toggle button (world-anchored near spawn) */
    #paparazziBtn { position: fixed; z-index: 7; appearance: none; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.08); color: var(--ui); border-radius: 999px; font-size: 12px; padding: 6px 10px; backdrop-filter: blur(6px); cursor: pointer; }
    #zoomSlider { position: fixed; z-index: 7; width: 90px; accent-color: var(--accent); }
    #zoomSlider, #zoomSlider::-webkit-slider-runnable-track { height: 16px; }
    #zoomSlider::-webkit-slider-thumb { -webkit-appearance: none; width: 28px; height: 28px; border-radius: 50%; background: var(--accent); border: 1px solid rgba(255,255,255,0.2); margin-top: -2px; }
    #zoomSlider::-moz-range-track { height: 16px; }
    #zoomSlider::-moz-range-thumb { width: 28px; height: 28px; border-radius: 50%; background: var(--accent); border: 1px solid rgba(255,255,255,0.2); }

    /* Prevent text selection / callout on touch for on-screen controls and HUD */
    #controls, #controls button, #uiBar, #legend, #tooltip, canvas, .navBtn {
      user-select: none;
      -webkit-user-select: none;
      -ms-user-select: none;
      -webkit-touch-callout: none;
      -webkit-user-drag: none;
      -khtml-user-select: none;
    }
    /* Remove blue tap highlight on mobile for interactive chrome */
    #controls button, .navBtn, #closeModal {
      -webkit-tap-highlight-color: transparent;
    }
    /* Keep modal content selectable for copy/paste */
    #modal .content { user-select: text; -webkit-user-select: text; }
    /* CTA row and small notes inside modal */
    .ctaRow { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 8px; }
    .assetNote { opacity: 0.85; font-size: 13px; margin-top: 6px; }
    .muted { opacity: 0.8; }
    /* Keep the instruction box from spanning too wide in portrait mobile */
    @media (orientation: portrait) and (max-width: 640px) {
      #legend { max-width: min(88vw, 320px); }
    }
  </style>
</head>
<body> <!-- Page content -->
  <div id="uiBar"> <!-- Top translucent bar with quick nav and badges -->
    <nav id="topNav" aria-label="Quick Navigation"></nav> <!-- Buttons to jump to sections -->
    <div class="chip">Fashion Show</div> <!-- Left badge text -->
    <div class="chip">Arrows/WASD to walk · Up/Enter=open · Down=close</div> <!-- Short usage hint -->
  </div>
  <div id="legend"> <!-- Bottom-left legend with instructions -->
    Walk to the left or right to explore sections. Stand under a marquee and press <b>Enter</b> or <b>Up</b> to open it. Press <b>Down</b> to close.
  </div>
  
  <div id="tooltip"></div> <!-- Floating tooltip that appears when close to a section -->
  <div id="hoverTip" aria-hidden="true"></div> <!-- Pointer hover hint for clickable areas -->
  <button id="paparazziBtn" title="Toggle paparazzi" aria-pressed="true">Paparazzi: On</button>
  <input id="zoomSlider" type="range" min="0" max="100" step="1" aria-label="Zoom" />
  <div id="modalWrap" aria-hidden="true"> <!-- Fullscreen modal overlay -->
    <div id="modal" role="dialog" aria-modal="true"> <!-- Modal container -->
      <header> <!-- Modal header with title and close action -->
        <strong id="modalTitle">Section</strong> <!-- Title is filled in dynamically -->
        <button id="closeModal" aria-label="Close">Close</button> <!-- Closes the modal -->
      </header>
      <div class="content" id="modalContent"> <!-- Container for section HTML content -->
        <!-- populated dynamically -->
      </div>
    </div>
  </div>
  <canvas id="stage"></canvas> <!-- Fullscreen canvas used to draw the runway and avatar -->

  <div id="controls" aria-hidden="false"> <!-- On-screen control buttons for touch/mobile -->
    <button id="btnLeft"  title="Walk left" aria-label="Walk left">◀</button> <!-- Walk left -->
    <button id="btnRight" title="Walk right" aria-label="Walk right">▶</button> <!-- Walk right -->
    <button id="btnUp"    title="Open (Up)" aria-label="Open (Up)">▲</button> <!-- Open section -->
    <button id="btnDown"  title="Close (Down)" aria-label="Close (Down)">▼</button> <!-- Close modal -->
    <button id="btnEnter" title="Open section" aria-label="Open (Enter)">Enter</button> <!-- Open nearest section -->
  </div>

  <script>
  (() => { // IIFE: wrap all logic to avoid leaking variables to global scope
    // Minimal error overlay to surface runtime errors quickly
    window.addEventListener('error', (e) => {
      const el = document.createElement('div');
      el.style.position = 'fixed'; el.style.bottom = '6px'; el.style.left = '6px';
      el.style.zIndex = '9999'; el.style.background = 'rgba(200,0,0,0.9)'; el.style.color = '#fff';
      el.style.padding = '6px 8px'; el.style.borderRadius = '6px'; el.style.fontSize = '12px';
      el.textContent = 'Error: ' + (e?.message || 'unknown');
      document.body.appendChild(el);
    }, { once: true });

    // Basic touch capability hint (used for mobile-only layout tweaks)
    const IS_TOUCH = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0);

    // On touch devices, prevent long-press text selection/callout on HUD and canvas
    if ('ontouchstart' in window) {
      document.addEventListener('contextmenu', (e) => {
        if (e.target.closest('#controls, canvas, #uiBar, #legend')) {
          e.preventDefault();
        }
      }, { capture: true });
    }
    const canvas = document.getElementById('stage'); // Grab the canvas element
    const ctx = canvas.getContext('2d'); // 2D drawing context for canvas

    // High-DPI handling: recompute DPR on every resize/zoom for crisp rendering
    let DPR = window.devicePixelRatio || 1; // Will be updated inside resize()
    const DPR_CAP = 3; // cap for performance; increase if you want extra sharpness
    let vw = window.innerWidth, vh = window.innerHeight; // Current viewport width/height in CSS pixels
    let marbleTex = null; // Offscreen canvas for full-screen marble texture
    let brandingImg = null; // Branding image (drawn on the main curtain)
    let brandingReady = false; // Loaded flag
    let doorBackdropImg = null; // Image shown behind door curtains when they open
    let doorBackdropReady = false; // Loaded flag for door backdrop

    // Helper to choose a reasonable zoom for small screens
    function autoScaleForWidth(width) {
      let s = 1.75;
      if (width <= 420) s = 1.15;      // small phones
      else if (width <= 640) s = 1.25; // phones / small phablets
      else if (width <= 900) s = 1.5;  // tablets / small laptops
      return s;
    }

    function resize() { // Resize handler to keep canvas in sync with window (and zoom)
      vw = window.innerWidth; vh = window.innerHeight; // Update viewport size
      // Update DPR on every resize/zoom so the backing store stays crisp
      DPR = Math.min(DPR_CAP, window.devicePixelRatio || 1);
      canvas.width = Math.floor(vw * DPR); // Set canvas backing width in device pixels
      canvas.height = Math.floor(vh * DPR); // Set canvas backing height in device pixels
      canvas.style.width = vw + 'px'; // Match CSS size
      canvas.style.height = vh + 'px'; // Match CSS size
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0); // Scale drawing so 1 unit = 1 CSS pixel
      // Prefer crisp rendering for raster steps
      if ('imageSmoothingEnabled' in ctx) ctx.imageSmoothingEnabled = false;
      // Responsive zoom: on small screens, step back the camera a bit (use window.view to avoid TDZ)
      if (window.view && window.view.autoScale) {
        window.view.scale = autoScaleForWidth(vw);
      }
      // Landscape tweak: zoom out a bit when width > height
      if (window.view && window.view.autoScaleLandscape) {
        const isLandscape = vw > vh;
        if (isLandscape) {
          window.view.scale = (window.view.landscapeScale || 0.9); // pull back further in landscape
        }
      }
      buildMarblePattern(); // Rebuild background texture for new size/theme
    }
    window.addEventListener('resize', resize); // Re-run on window resize
    window.addEventListener('orientationchange', () => setTimeout(resize, 100));
    resize(); // Initialize canvas size immediately

    // Load branding image helper (call once; safe to call again to change src)
    function loadBranding(src) {
      brandingReady = false;
      brandingImg = new Image();
      brandingImg.onload = () => { brandingReady = true; };
      brandingImg.onerror = () => { brandingReady = false; };
      brandingImg.src = src;
    }
    // Default expected filename (place this image next to index.html)
    loadBranding('fashion-show-branding.png');
    // Expose a setter for quick swaps via console if needed
    window.setBrandingImage = (url) => loadBranding(url);

    // Load per-door backdrop image (displayed behind opening curtains)
    function loadDoorBackdrop(src) {
      doorBackdropReady = false;
      doorBackdropImg = new Image();
      doorBackdropImg.onload = () => { doorBackdropReady = true; };
      doorBackdropImg.onerror = () => { doorBackdropReady = false; };
      doorBackdropImg.src = src;
    }
    // Default filename expected alongside index.html; safe to replace at runtime
    loadDoorBackdrop('door-backdrop.png');
    
    // Load paparazzi strip images (alternate left/right across the bottom)
    let paparazziLeftImg = new Image();
    let paparazziRightImg = new Image();
    let paparazziLeftReady = false;
    let paparazziRightReady = false;

    function loadPaparazziPair(leftSrc, rightSrc) {
      paparazziLeftReady = paparazziRightReady = false;
      paparazziLeftImg.onload = () => { paparazziLeftReady = true; };
      paparazziRightImg.onload = () => { paparazziRightReady = true; };
      paparazziLeftImg.onerror = () => { paparazziLeftReady = false; };
      paparazziRightImg.onerror = () => { paparazziRightReady = false; };
      paparazziLeftImg.src = leftSrc;
      paparazziRightImg.src = rightSrc;
    }
    // Default pair (files should exist next to index.html)
    loadPaparazziPair('paparazzi_left.png', 'paparazzi_right.png');
    window.setPaparazziImages = (l, r) => loadPaparazziPair(l, r);

    // Draw alternating paparazzi tiles under the runway
    function drawPaparazziStrip() {
      if (!(paparazziLeftReady || paparazziRightReady)) return;
      const yRunway = world.runwayY();
      // Base target height; scale to be 1/3 smaller than current doubled size
      const targetHBase = Math.max(36, Math.min(120, Math.floor(vh * 0.14)));
      const targetH = Math.floor(targetHBase * (4/3)); // previously 2x; now 2/3 of that → 4/3x base
      const hL = paparazziLeftReady ? paparazziLeftImg.naturalHeight : (paparazziRightReady ? paparazziRightImg.naturalHeight : 100);
      const hR = paparazziRightReady ? paparazziRightImg.naturalHeight : hL;
      const scaleL = targetH / hL;
      const scaleR = targetH / hR;
      const tileWL = paparazziLeftReady ? Math.ceil(paparazziLeftImg.naturalWidth * scaleL) : Math.ceil(paparazziRightImg.naturalWidth * scaleR);
      const tileWR = paparazziRightReady ? Math.ceil(paparazziRightImg.naturalWidth * scaleR) : tileWL;
      // Position row: previously runwayY + 230; move up by 50px → +180 total
      const yTop = Math.floor(yRunway + 180);
      const baseTile = Math.max(1, Math.min(tileWL, tileWR));
      const start = Math.floor((camera.x - vw) / baseTile) * baseTile;
      const end = camera.x + vw + baseTile;
      const t = performance.now() * 0.001;
      // deterministic pseudo-random helper for per-tile variance
      const rnd = (n) => { const s = Math.sin(n) * 43758.5453; return s - Math.floor(s); };
      let tileIndex = 0;
      ctx.save();
      ctx.globalAlpha = 0.98;
      let useLeft = true;
      for (let wx = start; wx < end; ) {
        const img = (useLeft && paparazziLeftReady) ? paparazziLeftImg : (paparazziRightReady ? paparazziRightImg : paparazziLeftImg);
        const isLeft = (img === paparazziLeftImg);
        const scale = isLeft ? scaleL : scaleR;
        const dw = Math.ceil(img.naturalWidth * scale);
        const dh = Math.ceil(img.naturalHeight * scale);
        const sx = Math.floor(wx - camera.x);
        // Draw the paparazzi tile
        ctx.drawImage(img, sx, yTop, dw, dh);

        // Camera flash effect near the camera position on each tile
        // Compute a per-tile flashing pattern
        const seed = tileIndex * 101 + (isLeft ? 1 : 2);
        const freq = 0.8 + rnd(seed + 1) * 1.4;     // 0.8..2.2 Hz
        const phase = rnd(seed + 2) * Math.PI * 2;   // 0..2π
        // Short bright pop using a steep power curve
        let pulse = Math.sin(t * freq + phase);
        pulse = pulse > 0.92 ? Math.pow((pulse - 0.92) / 0.08, 2) : 0; // only top 8% of the wave
        if (pulse > 0) {
          // Position near the camera: UL for left-facing, UR for right-facing
          const cx = isLeft ? (sx + Math.round(dw * 0.18)) : (sx + Math.round(dw * (1 - 0.18)));
          const cy = yTop + Math.round(dh * 0.16);
          // Make flashes 5x larger than before
          const baseInner = Math.max(6, Math.round(Math.min(dw, dh) * 0.08));
          const rInner = Math.max(6, Math.round(baseInner * 5));
          const rOuter = Math.max(14, Math.round(rInner * 2.2));
          const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, rOuter);
          // Make flashes ~1.2x brighter than before (with a higher cap)
          let a = Math.min(0.65, 0.25 + pulse * 0.5);
          a = Math.min(0.78, a * 1.2); // boost and cap
          g.addColorStop(0.0, `rgba(255,255,255,${a})`);
          g.addColorStop(0.3, `rgba(255,255,255,${a*0.7})`);
          g.addColorStop(1.0, 'rgba(255,255,255,0)');
          ctx.save();
          ctx.globalCompositeOperation = 'screen'; // brighten without blowing out blacks
          ctx.fillStyle = g;
          ctx.beginPath();
          ctx.arc(cx, cy, rOuter, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }

        wx += dw;
        useLeft = !useLeft;
        tileIndex++;
      }
      ctx.restore();
    }

    // Build a subtle marble texture as a repeated pattern
    function buildMarblePattern() {
      const cw = Math.max(1, Math.floor(vw));
      const ch = Math.max(1, Math.floor(vh));
      const off = document.createElement('canvas');
      off.width = cw; off.height = ch;
      const c = off.getContext('2d');
      const bgCol = getComputedStyle(document.documentElement).getPropertyValue('--bg') || '#15171c';
      c.fillStyle = bgCol; c.fillRect(0,0,cw,ch);

      const area = cw * ch;
      const diag = Math.hypot(cw, ch);

      // cloudy areas for dark marble (soft lightening)
      const cloudCount = Math.max(6, Math.floor(area / 180000));
      for (let i = 0; i < cloudCount; i++) {
        const x = Math.random()*cw;
        const y = Math.random()*ch;
        const r = diag * (0.10 + Math.random()*0.18);
        const g = c.createRadialGradient(x,y,0,x,y,r);
        g.addColorStop(0, 'rgba(255,255,255,0.10)');
        g.addColorStop(1, 'rgba(255,255,255,0)');
        c.fillStyle = g;
        c.beginPath(); c.arc(x,y,r,0,Math.PI*2); c.fill();
      }

      // subtle warm/cool tints for depth
      const warmCount = Math.max(3, Math.floor(area / 350000));
      for (let i = 0; i < warmCount; i++) {
        const x = Math.random()*cw, y = Math.random()*ch, r = diag * (0.10 + Math.random()*0.14);
        const tintWarm = c.createRadialGradient(x,y,0,x,y,r);
        tintWarm.addColorStop(0, 'rgba(180,160,140,0.05)');
        tintWarm.addColorStop(1, 'rgba(180,160,140,0)');
        c.fillStyle = tintWarm; c.beginPath(); c.arc(x,y,r,0,Math.PI*2); c.fill();
      }
      const coolCount = Math.max(2, Math.floor(area / 480000));
      for (let i = 0; i < coolCount; i++) {
        const x = Math.random()*cw, y = Math.random()*ch, r = diag * (0.10 + Math.random()*0.14);
        const tintCool = c.createRadialGradient(x,y,0,x,y,r);
        tintCool.addColorStop(0, 'rgba(140,160,180,0.05)');
        tintCool.addColorStop(1, 'rgba(140,160,180,0)');
        c.fillStyle = tintCool; c.beginPath(); c.arc(x,y,r,0,Math.PI*2); c.fill();
      }

      // faint veins: subtle criss-cross lines for marble texture
      c.lineCap = 'round';
      const veinCount = Math.max(14, Math.floor(area / 220000));
      for (let i = 0; i < veinCount; i++) {
        const ang = (-25 + Math.random()*50) * Math.PI/180;
        const len = diag * (0.5 + Math.random()*0.6);
        const cx = Math.random()*cw;
        const cy = Math.random()*ch;
        const dx = Math.cos(ang)*len/2;
        const dy = Math.sin(ang)*len/2;
        c.strokeStyle = 'rgba(220,220,220,0.10)';
        c.lineWidth = 1 + Math.random()*1.5;
        c.shadowColor = 'rgba(0,0,0,0.10)';
        c.shadowBlur = 2;
        c.beginPath();
        c.moveTo(cx-dx, cy-dy);
        c.quadraticCurveTo(cx + (Math.random()-0.5)*60, cy + (Math.random()-0.5)*60, cx+dx, cy+dy);
        c.stroke();
        if (Math.random() < 0.4) {
          c.beginPath(); c.moveTo(cx, cy);
          c.quadraticCurveTo(cx + (Math.random()-0.5)*40, cy + (Math.random()-0.5)*40, cx+dx*0.35, cy+dy*0.35);
          c.stroke();
        }
        // highlight
        c.strokeStyle = 'rgba(255,255,255,0.12)';
        c.shadowBlur = 0;
        c.beginPath(); c.moveTo(cx-dx, cy-dy);
        c.quadraticCurveTo(cx + (Math.random()-0.5)*50, cy + (Math.random()-0.5)*50, cx+dx, cy+dy);
        c.stroke();
      }
      c.shadowBlur = 0;

      // speckles (disabled for a cleaner background)
      const speckCount = 0;
      for (let i = 0; i < speckCount; i++) {
        const x = Math.random()*cw;
        const y = Math.random()*ch;
        c.fillStyle = Math.random() < 0.5 ? 'rgba(255,255,255,0.07)' : 'rgba(0,0,0,0.08)';
        c.fillRect(x, y, 1, 1);
      }

      marbleTex = off; // store full-screen texture
    }

    // Draw branding image at spawn area behind the carpet (world-anchored)
    function drawSpawnBranding() {
      if (!(brandingReady && brandingImg && brandingImg.naturalWidth)) return;
      const curtainTop = Math.max(60, world.runwayY() - (220 + CURTAIN_LIFT));
      const carpetTop = world.runwayY() - 2; // top edge of carpet
      const padAboveCarpet = 18;            // keep a gap above the carpet
      const maxW = Math.min(520, vw * 0.5);
      const maxH = Math.min(240, Math.max(60, carpetTop - padAboveCarpet - curtainTop));
      const scale = Math.min(maxW / brandingImg.naturalWidth, maxH / brandingImg.naturalHeight);
      const dw = Math.floor(brandingImg.naturalWidth * scale);
      const dh = Math.floor(brandingImg.naturalHeight * scale);

      // Center on the spawn X in world space
      const dx = Math.floor(((SPAWN_X + BRAND_OFFSET_X) - camera.x) - dw / 2);
      const dy = Math.floor(carpetTop - padAboveCarpet - dh);

      ctx.save();
      // very soft shadow so it sits on the wall behind
      ctx.shadowColor = 'rgba(0,0,0,0.25)';
      ctx.shadowBlur = 8;
      ctx.drawImage(brandingImg, dx, dy, dw, dh);
      // store clickable rect for spawn branding
      view._spawnBrandRect = { x: dx, y: dy, w: dw, h: dh };
      ctx.restore();
    }
    // Draw a second stationary branding at the far right endcap (after last door)
    function drawEndcapBranding(endX) {
      if (!(brandingReady && brandingImg && brandingImg.naturalWidth)) return;
      const curtainTop = Math.max(60, world.runwayY() - (220 + CURTAIN_LIFT));
      const carpetTop = world.runwayY() - 2;
      const padAboveCarpet = 18;
      const maxW = Math.min(520, vw * 0.5);
      const maxH = Math.min(240, Math.max(60, carpetTop - padAboveCarpet - curtainTop));
      const scale = Math.min(maxW / brandingImg.naturalWidth, maxH / brandingImg.naturalHeight);
      const dw = Math.floor(brandingImg.naturalWidth * scale);
      const dh = Math.floor(brandingImg.naturalHeight * scale);
      const dx = Math.floor((endX - camera.x) - dw / 2);
      const dy = Math.floor(carpetTop - padAboveCarpet - dh);
      ctx.save();
      ctx.shadowColor = 'rgba(0,0,0,0.25)';
      ctx.shadowBlur = 8;
      ctx.drawImage(brandingImg, dx, dy, dw, dh);
      // store clickable rect for endcap branding
      view._endcapBrandRect = { x: dx, y: dy, w: dw, h: dh };
      ctx.restore();
    }

    // WORLD CONFIG
    const world = {
      width: 6000, // total catwalk length in px (world width)
      runwayY: () => Math.floor(vh * 0.62), // Y position of runway relative to viewport
      runwayW: () => Math.min(800, Math.max(420, vw * 0.6)), // Runway visual width
      speed: 2.2, // Base movement speed factor
      ambient: 0.25, // Ambient light factor (not used heavily here)
    };

    // PLAYER (blocky voxel-like avatar with normal gait)
    const SPAWN_X = 360; // anchor for spawn area and branding placement
    const player = {
      x: SPAWN_X, y: 0, vy: 0, facing: 1, walking: false, t: 0, // position, velocity, facing, walk state, walk time
      width: 32, height: 64, // player dimensions for drawing/placement
    };

    // CAMERA
    const camera = { x: 0 }; // Camera x scroll position (y is fixed by design)
    // Safe default zoom to avoid any auto-scale edge cases causing a blank scene
    const view = { scale: 1.5, offsetX: 0, yLift: 0, autoScale: false, autoScaleLandscape: true, landscapeScale: 0.9, edgeFades: false, edgeFadesInLandscape: false }; // You can tweak with setViewScale()/setViewOffset()
    // Expose quick tuning via console: setViewScale(1.2..1.6)
    window.view = view;
    if (view.baseScale == null) view.baseScale = view.scale; // store base scale
    // Paparazzi toggle (global)
    window.paparazziOn = true;
    window.setViewScale = (s) => { view.autoScale = false; view.scale = Math.max(1, Math.min(2, Number(s)||1)); };
    // Optional: adjust horizontal nudge via console: setViewOffset(px)
    window.setViewOffset = (x) => { view.offsetX = Math.max(-200, Math.min(200, Number(x)||0)); };
    // Optional: lock/unlock landscape auto zoom and set amount
    window.setLandscapeAutoZoom = (on) => { view.autoScaleLandscape = !!on; if (on) resize(); };
    window.setLandscapeZoom = (s) => { view.landscapeScale = Math.max(0.8, Math.min(2, Number(s)||0.9)); resize(); };
    // Optional: toggle edge fades (disabled by default)
    window.setEdgeFades = (on) => { view.edgeFades = !!on; };
    window.setEdgeFadesLandscape = (on) => { view.edgeFadesInLandscape = !!on; };
    // Stage layout: shift all marquees and carpet to the right to create a left entry area
    const stage = { leftOffset: 600 };
    // Raise the top valance a bit (in pixels). Increase to move it up more.
    const CURTAIN_LIFT = 30;
    // Branding horizontal offset relative to spawn (move image to the right)
    const BRAND_OFFSET_X = 280;
    // Ensure the avatar spawns centered on the branding image
    try { player.x = SPAWN_X + BRAND_OFFSET_X; } catch (_) {}
    // Ensure sizing applies with the now-defined view
    try { resize(); } catch (_) {}

    // INTERACTIVE SECTIONS (marquees along the runway)
    /**
     * Each section defines: x position, width, title, and content (HTML).
     * The `x` is in world space; we subtract `camera.x` to get screen position.
     */
    // Sections will be defined below; remove placeholders to avoid confusion
    // Single source of truth: sections are defined later with final content
    let sections = [];

    // Define sections used by the seven doors (final content)
    sections = [
      // Quick Sign-Up door near spawn (to the left)
      { x: -615, w: 340, key: 'signup', title: 'Artist Quick Sign-Up', content: `
        <p>Show your style on the runway. Enter the raffle to become a featured artist for an upcoming monthly show.</p>
        <h4>What you’ll make</h4>
        <ul>
          <li>Full VoxEdit gear set: Headpiece, Chest, Arms, Legs</li>
          <li>Optional: Main-hand and Off-hand equipment</li>
          <li>Original, show-safe voxel work created in VoxEdit</li>
        </ul>
        <h4>How selection works</h4>
        <ul>
          <li>New artists enter the primary raffle</li>
          <li>If slots remain, past artists enter a secondary raffle</li>
          <li>After draws, we announce the theme and the deadline</li>
        </ul>
        <h4>Timeline</h4>
        <ul>
          <li>Theme drop → ~3 weeks to finish your gear set</li>
          <li>Submit 3–5 hero images, a short description, and your display name/socials</li>
          <li>Quick tech check before showtime</li>
        </ul>
        <h4>Ready checklist</h4>
        <ul>
          <li>&#9633; VoxEdit installed</li>
          <li>&#9633; Time for ~3 weeks of build/polish</li>
        </ul>
        <p><strong>Need help?</strong> Join Discord for Q&amp;A, feedback, and tech checks.</p>
        <div class="ctaRow">
          <a class="navBtn" href="https://docs.google.com/forms/d/e/1FAIpQLSejCyO7RukrV90BhihqQB3vkTJEC29arEzdcdXc1HONIPfXNQ/viewform?usp=send_form" target="_blank" rel="noopener">Open Artist Raffle Form</a>
          <a class="navBtn" href="https://www.sandbox.game/en/create/vox-edit/" target="_blank" rel="noopener">Download VoxEdit</a>
          <a class="navBtn" href="https://discord.gg/fCMD3NkXMZ" target="_blank" rel="noopener">Join Discord</a>
          <a class="navBtn" href="#" data-close>Back to Runway</a>
        </div>
      `},
      // Door 1 — About This Website
      { x: 400, w: 360, key: 'about', title: 'The Fashion Show Website', content: `
        <p>Step onto the stage. Walk the runway and stop under a door to open a short popup about the show.</p>
        <h4>Controls</h4>
        <ul>
          <li><strong>Move:</strong> &larr; / &rarr; or A / D, or use the on-screen arrows</li>
          <li><strong>Open a door:</strong> Enter or &uarr; / W, or tap the on-screen Enter</li>
          <li><strong>Close a popup:</strong> Esc or &darr; / S, click outside the popup, or tap the X</li>
        </ul>
        <h4>Quick tips</h4>
        <ul>
          <li>Works on desktop and mobile (best in Chrome/Edge/Safari/Firefox)</li>
          <li>If keys don’t respond, click the page once to give it focus</li>
          <li>If layout looks off, rotate your device or hard refresh (Ctrl/Cmd + Shift + R)</li>
        </ul>
        <div class="ctaRow">
          <a class="navBtn" href="#" data-close>Start Walking</a>
          <a class="navBtn" href="#" data-modal="troubleshooting">Troubleshooting</a>
        </div>
      `},
      // Door 2 — The Show
      { x: 1100, w: 360, key: 'show', title: 'The Fashion Show Origin', content: `
        <p>This show was seeded by a community grant from The Sandbox DAO—funding creators to experiment, tell stories, and put voxel fashion in the spotlight. What began as an idea to showcase voxel artists on a catwalk prototype became a full showcase thanks to DAO support and feedback from builders like you. We’re committed to transparency, community credit, and sharing what we learn so more creators can ship bold ideas.</p>
        <div class="ctaRow">
          <a class="navBtn" href="https://www.sandboxdao.com/" target="_blank" rel="noopener">Open The Sandbox DAO</a>
          <a class="navBtn" href="https://forum.sandboxdao.com/t/sandbox-fashion-show/2744" target="_blank" rel="noopener">Read the Proposal</a>
          <a class="navBtn" href="https://discord.gg/fCMD3NkXMZ" target="_blank" rel="noopener">Get Updates (Discord)</a>
        </div>
      `},
      // Door 3 — How the Show Works (In The Sandbox)
      { x: 1900, w: 360, key: 'origin', title: 'What is the Fashion Show', content: `
        <p>Each month, four featured artists present a themed gearset on a playable catwalk inside The Sandbox. Artists walk the runway for live judging, while the audience joins in from the stands.</p>
        <p>During the show, attendees earn Catwalk Coins (CWK) by exploring, dancing, and other ways. Then they spend CWK to vote for their favorite creations. Judges' scores and audience votes are tallied together to spotlight the monthly winner.</p>
        <ul>
          <li>One main show every month</li>
          <li>Four artists compete per show</li>
          <li>Live panel scores: craft, originality, theme fit</li>
          <li>Audience voting with CWK during timed windows (in-experience)</li>
          <li>Live leaderboard moments</li>
        </ul>
        <div class="ctaRow">
          <a class="navBtn" href="https://www.sandbox.game/en/experiences/The%20Sandbox%20-%20Fashion%20Show/e157abb3-bda0-44c5-a769-8f797f1ebbd4/page/" target="_blank" rel="noopener">Visit Experience Page</a>
          <a class="navBtn" href="https://www.sandbox.game/en/create/vox-edit/" target="_blank" rel="noopener">Get VoxEdit (Create Gear)</a>
          <a class="navBtn" href="https://www.sandbox.game/en/create/game-maker/" target="_blank" rel="noopener">Get Game Maker (Build Experiences)</a>
        </div>
      `},
      // Door 4 — Being an Artist on the Show
      { x: 2700, w: 360, key: 'artists', title: 'Being an Artist', content: `
        <p><strong>Build a full voxel gear set in VoxEdit and bring it to the runway.</strong></p>
        <h4>What you make</h4>
        <ul>
          <li><strong>Required:</strong> Headpiece, Chest, Arms, Legs</li>
          <li><strong>Optional:</strong> Main-hand and Off-hand equipment</li>
          <li>Original work, show-safe, and created in VoxEdit</li>
        </ul>
        <h4>How selection works</h4>
        <ul>
          <li>Sign up on the Google Form to enter the primary raffle (new artists first).</li>
          <li>If slots remain, a secondary raffle includes returning artists from past shows.</li>
        </ul>
        <h4>Timeline</h4>
        <ul>
          <li>A theme is announced after the raffle.</li>
          <li>You have ~3 weeks to finish your gear set.</li>
          <li>Deliverables: 3–5 hero images, short description, display name/socials (asset files for tech check).</li>
        </ul>
        <p><strong>Need help?</strong> Join Discord for Q&amp;A, feedback, and tech checks.</p>
        <div class="ctaRow">
          <a class="navBtn" href="https://docs.google.com/forms/d/e/1FAIpQLSejCyO7RukrV90BhihqQB3vkTJEC29arEzdcdXc1HONIPfXNQ/viewform?usp=send_form" target="_blank" rel="noopener">Artist Raffle Form</a>
          <a class="navBtn" href="https://www.sandbox.game/en/create/vox-edit/" target="_blank" rel="noopener">Download VoxEdit</a>
          <a class="navBtn" href="https://discord.gg/fCMD3NkXMZ" target="_blank" rel="noopener">Join Discord</a>
        </div>
      `},
      // Door 5 — Judging & How to Join
      { x: 3500, w: 360, key: 'judging', title: 'Judging', content: `
        <p>Artists show a gearset on the live runway while a panel scores each look and the audience adds momentum.</p>
        <h4>Scoring (how winners are chosen)</h4>
        <p><strong>Panel score (1–5 per judge):</strong> three judges each pick a number from 1–5.</p>
        <p>Criteria the judges consider:</p>
        <ul>
          <li><strong>Craft &amp; Build Quality</strong> — clean geometry, detail, polish</li>
          <li><strong>Originality &amp; Concept</strong> — idea strength, voice, inventiveness</li>
          <li><strong>Runway Readability &amp; Presence</strong> — silhouette, staging, “reads” at a glance</li>
          <li><strong>Theme Fit</strong> — how well it matches the show’s theme/prompt</li>
        </ul>
        <p><strong>Audience bonus (0–1):</strong> adds 0.0 → 1.0 based on Catwalk Coins (CWK) supporting a look during the voting window.<br>
        <small>(Scaled per show; typically requires &gt; 5,000 CWK for the full +1.0 bonus.)</small></p>
        <p><strong>Final tally</strong> = average panel score + audience bonus. Tie-breaks go to panel discussion.</p>
      `},
      // Door 6 — Join the Community
      { x: 4300, w: 380, key: 'community', title: 'Join the Community', content: `
        <p>Backstage passes live on Discord. Get announcements, submission windows, tech checks, WIP feedback, and post-show recaps. Meet other creators, share progress, and help shape what comes next.</p>
        <h4>What you\u2019ll find</h4>
        <ul>
          <li><code>#announcements</code> &mdash; dates, themes, results</li>
          <li><code>#artist-signup</code> &mdash; raffle reminders &amp; guidelines</li>
          <li><code>#wip-critique</code> &mdash; share progress, get feedback</li>
          <li><code>#tech-help</code> &mdash; VoxEdit/GameMaker setup help</li>
          <li><code>#show-chat</code> &mdash; watch parties &amp; discussion</li>
        </ul>
        <h4>Roles &amp; pings</h4>
        <ul>
          <li>Artist / Judge / Audience roles</li>
          <li>Opt-in @Showtime and @ThemeDrop alerts</li>
        </ul>
        <p>Friendly, modded, PG-13 space. Zero harassment. Bring good vibes.</p>
        <div class="ctaRow">
          <a class="navBtn" href="https://discord.gg/fCMD3NkXMZ" target="_blank" rel="noopener">Join Discord</a>
          <a class="navBtn" href="#" data-modal="rules">Read Server Rules</a>
          <a class="navBtn" href="#" data-modal="ask">Ask a Question</a>
        </div>
      `},
      // Door 7 — Schedule & Following Along
      { x: 5200, w: 380, key: 'schedule', title: 'Schedule & Following Along', content: `
        <p>We run one main show every month on the <strong>fredandferd</strong> Twitch channel—live runway, judges on mic, and chat energy. Between shows, follow updates and theme drops on our Impossible Dream Studio X account, or hop into Discord for reminders and Q&amp;A.</p>
        <p><em>Want to help between live shows?</em> Try the Discord judging bot: preview gear sets, score them, and earn a raffle ticket for each valid vote. Tickets are pulled during “Fun Stream Nights” on Twitch.</p>
        <div class="ctaRow">
          <a class="navBtn" href="https://www.twitch.tv/fredandferd" target="_blank" rel="noopener">Follow on Twitch</a>
          <a class="navBtn" href="https://x.com/ImDream_Studio" target="_blank" rel="noopener">Follow on X</a>
          <a class="navBtn" href="https://discord.gg/fCMD3NkXMZ" target="_blank" rel="noopener">Join Discord</a>
        </div>
      `}
    ];

    // Compute a little extra world to the right of the last door and position the endcap logo
    const lastRightEdge = stage.leftOffset + Math.max.apply(null, sections.map(s => s.x + s.w));
    const TAIL_GAP = 800; // space after last door
    const ENDCAP_X = lastRightEdge + Math.floor(TAIL_GAP * 0.5); // center branding in the tail gap
    // Ensure the world is wide enough to walk past the last door and see the endcap comfortably
    world.width = Math.max(world.width, lastRightEdge + TAIL_GAP);

    // INPUT
    const keys = { left: false, right: false, run: false }; // Track walking directions and run modifier
    window.addEventListener('keydown', e => { // Keyboard controls
      const k = e.key;
      if (k === 'ArrowLeft' || k === 'a' || k === 'A') { keys.left = true; e.preventDefault(); }
      if (k === 'ArrowRight' || k === 'd' || k === 'D') { keys.right = true; e.preventDefault(); }
      if (k === 'Enter' || k === 'ArrowUp' || k === 'w' || k === 'W') { tryOpen(); e.preventDefault(); }
      if (k === 'ArrowDown' || k === 's' || k === 'S' || k === 'Escape' || k === 'Esc') { closeModal(); e.preventDefault(); }
      if (k === 'Shift') { keys.run = true; }
    });
    window.addEventListener('keyup', e => { // Stop walking when keys released
      const k = e.key;
      if (k === 'ArrowLeft' || k === 'a' || k === 'A') keys.left = false; // Stop left
      if (k === 'ArrowRight' || k === 'd' || k === 'D') keys.right = false; // Stop right
      if (k === 'Shift') keys.run = false; // Stop running
    });

    // Mobile buttons
    const btnLeft  = document.getElementById('btnLeft'); // Left button element
    const btnRight = document.getElementById('btnRight'); // Right button element
    const btnUp    = document.getElementById('btnUp'); // Up/open button
    const btnDown  = document.getElementById('btnDown'); // Down/close button
    const btnEnter = document.getElementById('btnEnter'); // Enter action button
    const paparazziBtn = document.getElementById('paparazziBtn');
    const zoomSlider = document.getElementById('zoomSlider');
    const press = (k, v) => { keys[k] = v; }; // Helper to set key state
    btnLeft.addEventListener('pointerdown', () => press('left', true)); // Hold left
    btnLeft.addEventListener('pointerup',   () => press('left', false)); // Release left
    btnLeft.addEventListener('pointerleave',() => press('left', false)); // Stop if pointer leaves
    btnRight.addEventListener('pointerdown',() => press('right', true)); // Hold right
    btnRight.addEventListener('pointerup',  () => press('right', false)); // Release right
    btnRight.addEventListener('pointerleave',() => press('right', false)); // Stop if pointer leaves
    btnUp.addEventListener('click', () => tryOpen()); // Tap up to open
    btnDown.addEventListener('click', () => closeModal()); // Tap down to close
    btnEnter.addEventListener('click', () => tryOpen()); // Tap to open
    function updatePaparazziBtnPosition() {
      if (!paparazziBtn) return;
      const s = Number(view && view.scale) || 1;
      const tx = Number(view && view._tx) || 0;
      const ty = Number(view && view._ty) || 0;
      const ox = Number(view && view.offsetX) || 0;
      // Place 120px to the right of the spawn avatar and 40px below the runway baseline
      const sx = (SPAWN_X + 120 - camera.x + ox) * s + tx;
      const sy = (world.runwayY() + 40) * s + ty; // slightly below avatar feet
      paparazziBtn.style.left = Math.round(sx) + 'px';
      paparazziBtn.style.top = Math.round(sy) + 'px';
      if (zoomSlider) {
        const zx = (SPAWN_X + 260 - camera.x + ox) * s + tx; // moved 25px further right
        const zy = (world.runwayY() + 53) * s + ty; // moved 10px further down
        zoomSlider.style.left = Math.round(zx) + 'px';
        zoomSlider.style.top = Math.round(zy) + 'px';
      }
    }
    if (paparazziBtn) {
      paparazziBtn.addEventListener('click', () => {
        window.paparazziOn = !window.paparazziOn;
        paparazziBtn.setAttribute('aria-pressed', String(window.paparazziOn));
        paparazziBtn.textContent = 'Paparazzi: ' + (window.paparazziOn ? 'On' : 'Off');
      });
    }
    if (zoomSlider) {
      // Repurpose slider: move camera DOWN to reveal more of the TOP (no zoom)
      // Map 0..100 -> 0..250 px of downward scene shift
      const valueToLift = (v) => Math.max(0, Math.min(250, Math.round(250 * (v/100))));
      // Start with no lift (0)
      zoomSlider.value = '0';
      view.yLift = 0;
      view.autoScale = false; // ensure auto zoom doesn’t fight manual lift
      zoomSlider.setAttribute('aria-label', 'View Down');
      zoomSlider.addEventListener('input', () => {
        const lift = valueToLift(Number(zoomSlider.value));
        view.yLift = lift;
      });
    }

    // CLICKABLE DOOR HEADERS (open by clicking the marquee header)
    function screenToScene(x, y) {
      const s = Number(view && view.scale) || 1;
      const tx = Number(view && view._tx) || 0;
      const ty = Number(view && view._ty) || 0;
      const ox = Number(view && view.offsetX) || 0;
      return { x: (x - tx) / s - ox, y: (y - ty) / s };
    }
    function sceneToScreen(x, y) {
      const s = Number(view && view.scale) || 1;
      const tx = Number(view && view._tx) || 0;
      const ty = Number(view && view._ty) || 0;
      const ox = Number(view && view.offsetX) || 0;
      return { x: (x + ox) * s + tx, y: y * s + ty };
    }
    function sectionHeaderAt(sceneX, sceneY) {
      const y = world.runwayY();
      const headerTop = y - 220;
      const headerBottom = y - 140;
      for (const sec of sections) {
        const screenX = (stage.leftOffset + sec.x) - camera.x;
        const x1 = screenX + 18;
        const x2 = x1 + (sec.w - 36);
        const y1 = headerTop;
        const y2 = headerBottom;
        if (sceneX >= x1 && sceneX <= x2 && sceneY >= y1 && sceneY <= y2) return sec;
      }
      return null;
    }
    canvas.addEventListener('click', (e) => {
      if (modalWrap && modalWrap.style.display === 'grid') return; // ignore when modal open
      const pt = screenToScene(e.offsetX, e.offsetY);
      // If clicking the branding at spawn or endcap, open the external experience page
      const r1 = view._spawnBrandRect, r2 = view._endcapBrandRect;
      const inRect = (r) => r && pt.x >= r.x && pt.x <= r.x + r.w && pt.y >= r.y && pt.y <= r.y + r.h;
      if (inRect(r1) || inRect(r2)) {
        window.open('https://www.sandbox.game/en/experiences/The%20Sandbox%20-%20Fashion%20Show/e157abb3-bda0-44c5-a769-8f797f1ebbd4/page/', '_blank', 'noopener');
        return;
      }
      const sec = sectionHeaderAt(pt.x, pt.y);
      if (sec) { openModal(sec.title, sec.content); }
    });
    canvas.addEventListener('mousemove', (e) => {
      const pt = screenToScene(e.offsetX, e.offsetY);
      const r1 = view._spawnBrandRect, r2 = view._endcapBrandRect;
      const inRect = (r) => r && pt.x >= r.x && pt.x <= r.x + r.w && pt.y >= r.y && pt.y <= r.y + r.h;
      const sec = sectionHeaderAt(pt.x, pt.y);
      const overBrand = inRect(r1) || inRect(r2);
      const overHeader = !!sec;
      const hover = overBrand || overHeader;
      canvas.style.cursor = hover ? 'pointer' : 'default';
      if (hover) {
        const text = overBrand ? 'Fashion Show Experience Page' : 'Open “' + sec.title + '”';
        showHoverTip(e.clientX, e.clientY, text);
      } else {
        hideHoverTip();
      }
    });
    canvas.addEventListener('mouseleave', () => hideHoverTip());
    // MODAL
    const modalWrap = document.getElementById('modalWrap'); // Overlay element
    const modalTitle = document.getElementById('modalTitle'); // Title node inside modal
    const modalContent = document.getElementById('modalContent'); // Content container
    document.getElementById('closeModal').addEventListener('click', closeModal); // Close on button
    modalWrap.addEventListener('click', (e) => { if (e.target === modalWrap) closeModal(); }); // Close when clicking backdrop
    function openModal(title, html) { // Show modal with given title/content
      modalTitle.textContent = title; // Set title text
      modalContent.innerHTML = html; // Inject provided HTML content
      modalWrap.style.display = 'grid'; // Reveal overlay (CSS grid centers modal)
    }
    function closeModal() { // Hide the modal overlay
      modalWrap.style.display = 'none';
    }

    // Allow CTA links inside modals to cross-open sections or close
    const TROUBLESHOOTING_HTML = `
      <h4>Quick fixes (most issues)</h4>
      <ul>
        <li><b>Hard refresh:</b> Ctrl/Cmd + Shift + R</li>
        <li><b>Rotate device:</b> try landscape on mobile</li>
        <li><b>Close other tabs:</b> free a bit of memory/CPU</li>
      </ul>
      <h4>If Enter doesn’t open doors</h4>
      <ul>
        <li>Make sure the avatar is centered under the door</li>
        <li>Try the on-screen Enter button</li>
        <li>Click the page once to give it focus, then press Enter</li>
      </ul>
      <h4>If you can’t move</h4>
      <ul>
        <li>Click the page, then use ← / → or the on-screen arrows</li>
        <li>On mobile, tap the arrows; long-press to keep walking</li>
      </ul>
      <h4>If popups look cut off</h4>
      <ul>
        <li>Zoom 100% (Ctrl/Cmd + 0)</li>
        <li>On mobile, rotate to landscape</li>
      </ul>
      <h4>If it feels slow</h4>
      <ul>
        <li>Close heavy apps/tabs, then reload</li>
        <li>Older phones: give it a few seconds after load</li>
      </ul>
      <h4>Blank page or errors</h4>
      <ul>
        <li>Try another browser (Chrome/Edge recommended)</li>
        <li>Check your connection and reload</li>
      </ul>
      <h4>Need help?</h4>
      <p>Join our Discord for live support.</p>
      <div class="ctaRow">
        <a class="navBtn" href="https://discord.gg/fCMD3NkXMZ" target="_blank" rel="noopener">Join Discord</a>
        <a class="navBtn" href="#" data-close>Back to Site</a>
      </div>
    `;
    const SERVER_RULES_HTML = `
      <p><strong>Be kind, be creative, be safe.</strong></p>
      <ul>
        <li><strong>Respect first.</strong> No harassment, hate speech, or personal attacks.</li>
        <li><strong>Keep it show-safe.</strong> No NSFW, gore, or infringing content.</li>
        <li><strong>Credit creators.</strong> Share only work you own or have permission to post.</li>
        <li><strong>Stay on topic.</strong> Use the right channels (announcements, WIP, help, etc.).</li>
        <li><strong>No spam/scams.</strong> No ads, token shills, or unsolicited DMs.</li>
        <li><strong>Follow staff directions.</strong> Moderators’ decisions keep things safe and fair.</li>
      </ul>
      <p>Questions or issues? Open Ask a Question here or ping a mod in <code>#help-desk</code> once you join.</p>
      <div class="ctaRow">
        <a class="navBtn" href="https://discord.gg/fCMD3NkXMZ" target="_blank" rel="noopener">Join Discord</a>
        <a class="navBtn" href="#" data-close>Back</a>
      </div>
    `;
    const ASK_HTML = `
      <p><strong>Need help fast?</strong></p>
      <ul>
        <li><strong>Tech or setup questions:</strong> join and post in <code>#help-desk</code>.</li>
        <li><strong>Artist logistics (raffle, deadlines, specs):</strong> ask in <code>#artist-signup</code>.</li>
        <li><strong>Private matters or reports:</strong> DM a moderator once you’re in.</li>
      </ul>
      <p>If you don’t use Discord, you can still reach us at <em>[your email here]</em>.</p>
      <div class="ctaRow">
        <a class="navBtn" href="https://discord.gg/fCMD3NkXMZ" target="_blank" rel="noopener">Join Discord</a>
        <a class="navBtn" href="#" data-close>Back</a>
      </div>
    `;
    function openSectionByKey(key) {
      const sec = sections.find(s => s.key === key);
      if (sec) openModal(sec.title, sec.content);
    }
    modalContent.addEventListener('click', (e) => {
      const closeA = e.target.closest('a[data-close]');
      if (closeA) { e.preventDefault(); closeModal(); return; }
      const modalA = e.target.closest('a[data-modal]');
      if (modalA) {
        e.preventDefault();
        const which = modalA.getAttribute('data-modal');
        if (which === 'troubleshooting') openModal('Troubleshooting', TROUBLESHOOTING_HTML);
        else if (which === 'rules') openModal('Server Rules', SERVER_RULES_HTML);
        else if (which === 'ask') openModal('Ask a Question', ASK_HTML);
        return;
      }
      const a = e.target.closest('a[data-open]');
      if (a) { e.preventDefault(); openSectionByKey(a.getAttribute('data-open')); }
    });

    // Build top navigation from sections
    const topNav = document.getElementById('topNav'); // Nav container in top bar
    function buildTopNav() { // Create a button per section
      if (!topNav) return; // Safety: no-op if nav missing
      topNav.innerHTML = ''; // Clear previous items
      sections.forEach(sec => { // For each section, add a button
        const btn = document.createElement('button'); // Create button element
        btn.type = 'button'; // Explicit type to avoid form defaults
        btn.className = 'navBtn';
        btn.textContent = sec.title; // Button label shows section title
        btn.addEventListener('click', () => {
          openModal(sec.title, sec.content); // Clicking opens its modal directly
        });
        topNav.appendChild(btn); // Add to nav bar
      });
    }
    buildTopNav(); // Build the nav at startup

    // TOOLTIP
    const tooltip = document.getElementById('tooltip'); // Tooltip element
    function showTooltip(scrX, scrY, text) { // Position and show tooltip
      tooltip.textContent = text; // Set text
      tooltip.style.left = scrX + 'px'; // Horizontal position
      tooltip.style.top = scrY + 'px'; // Vertical position
      tooltip.style.display = 'block'; // Make visible
    }
    function hideTooltip() { tooltip.style.display = 'none'; } // Hide tooltip

    // Hover tip near pointer for clickable areas (headers/branding)
    const hoverTipEl = document.getElementById('hoverTip');
    function showHoverTip(scrX, scrY, text) {
      if (!hoverTipEl) return;
      hoverTipEl.textContent = text;
      hoverTipEl.style.left = scrX + 'px';
      hoverTipEl.style.top = scrY + 'px';
      hoverTipEl.style.display = 'block';
    }
    function hideHoverTip() { if (hoverTipEl) hoverTipEl.style.display = 'none'; }

    // OPEN section when near
    function tryOpen() { // Attempts to open the nearest section if close
      const near = nearestSection(); // Find nearest
      if (near && near.dist < 80) openModal(near.sec.title, near.sec.content); // Open if within 80px
    }

    function nearestSection() { // Returns nearest section to player.x
      let best = null; let bestDist = Infinity; let which = null; // Track best match
      for (const sec of sections) { // Check each section
        const center = stage.leftOffset + sec.x + sec.w/2; // Section center x (shifted by stage offset)
        const d = Math.abs(center - player.x); // Distance to player
        if (d < bestDist) { bestDist = d; which = sec; } // Keep if nearer
      }
      return which ? { sec: which, dist: bestDist } : null; // Return object or null
    }

    // DRAW helpers
    function drawSpotlights() { // Moving soft spotlights to mimic stage lights (warm tone)
      const baseY = world.runwayY() - 180; // Height above runway
      const t = performance.now() * 0.001; // Time in seconds
      // Anchor to visual screen center; compensate for scene nudge so lights stay centered
      const centerX = vw * 0.5 - (view.offsetX || 0);
      const spacing = 240; // distance between spot centers
      const amp = 60;      // side-to-side oscillation amplitude
      const rx = 180, ry = 36; // ellipse radii
      const altDrop = 46;  // vertical drop for every other spotlight
      for (let i = -2; i <= 2; i++) { // Create multiple spot ellipses
        const cx = centerX + i * spacing + Math.sin(t + i) * amp;
        const cy = baseY + (Math.abs(i) % 2 ? altDrop : 0); // stagger alternate lights lower
        ctx.fillStyle = 'rgba(255,220,180,0.06)'; // Warm white
        ctx.beginPath();
        ctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI*2); // Wide, shallow ellipse
        ctx.fill();
      }
    }

    function drawCurtains() { // Big red curtains framing the stage
      const topH = Math.max(60, world.runwayY() - (220 + CURTAIN_LIFT)); // Height of top valance (raised)
      // Extend width beyond screen so edges are never visible when zoomed out
      const s = Number(view && view.scale) > 0 ? Number(view.scale) : 1;
      const bleed = Math.max(200, Math.ceil((1/s - 1) * vw) + 200); // extra draw width on both sides
      const fullW = vw + bleed * 2;
      // Top valance with scalloped bottom edge
      const grdTop = ctx.createLinearGradient(0, 0, 0, topH);
      grdTop.addColorStop(0, '#7e0a16');
      grdTop.addColorStop(1, '#d0142e');
      ctx.fillStyle = grdTop;
      ctx.beginPath();
      ctx.moveTo(-bleed, 0);
      ctx.lineTo(vw + bleed, 0);
      ctx.lineTo(vw + bleed, topH);
      // scallops along the bottom across extended width
      const scallops = 8; const amp = 16; const baseY = topH - 8;
      for (let i = scallops; i >= 0; i--) {
        const x = (i / scallops) * fullW - bleed;
        const cx = x + fullW / scallops / 2;
        const y = baseY + Math.sin(i) * 2; // tiny irregularity
        ctx.quadraticCurveTo(cx, baseY + amp, x - 1, y);
      }
      ctx.closePath();
      ctx.fill();

      // Extend valance far beyond the top so no background shows when zoomed/panned
      const extraTop = Math.max(800, Math.ceil((Number(view && view._ty) || 0) + 400));
      if (extraTop > 0) {
        ctx.fillStyle = grdTop;
        ctx.fillRect(-bleed, -extraTop, vw + bleed * 2, extraTop);
      }

      // Subtle vertical fold texture on the top valance
      ctx.save();
      // Clip to the same valance shape
      ctx.beginPath();
      ctx.moveTo(-bleed, 0);
      ctx.lineTo(vw + bleed, 0);
      ctx.lineTo(vw + bleed, topH);
      const scallops2 = 8; const amp2 = 16; const baseY2 = topH - 8;
      for (let i = scallops2; i >= 0; i--) {
        const x = (i / scallops2) * fullW - bleed;
        const cx = x + fullW / scallops2 / 2;
        const y = baseY2 + Math.sin(i) * 2;
        ctx.quadraticCurveTo(cx, baseY2 + amp2, x - 1, y);
      }
      ctx.closePath();
      ctx.clip();

      // Very subtle vertical folds for texture (low alpha, half-pixel to reduce shimmer)
      ctx.strokeStyle = 'rgba(0,0,0,0.18)';
      ctx.lineWidth = 1;
      for (let x = -bleed + 12; x < vw + bleed - 12; x += 26) {
        const x1 = Math.round(x) + 0.5;
        ctx.beginPath(); ctx.moveTo(x1, 2); ctx.lineTo(x1 - 4, topH - 2); ctx.stroke();
      }
      ctx.strokeStyle = 'rgba(255,255,255,0.06)';
      for (let x = -bleed + 24; x < vw + bleed - 12; x += 26) {
        const x1 = Math.round(x) + 0.5;
        ctx.beginPath(); ctx.moveTo(x1, 2); ctx.lineTo(x1 - 4, topH - 2); ctx.stroke();
      }
      ctx.restore();

      // Side curtains
      const sideW = 120; const sideH = Math.max(120, world.runwayY() - 80);
      const grdSide = ctx.createLinearGradient(0, 0, sideW, 0);
      grdSide.addColorStop(0, '#660812');
      grdSide.addColorStop(0.5, '#c4122b');
      grdSide.addColorStop(1, '#8f0d1b');

      // Left (extend beyond screen)
      ctx.fillStyle = grdSide;
      ctx.fillRect(-bleed, -extraTop, sideW + bleed, sideH + extraTop);
      // Right (mirror)
      const grdSideR = ctx.createLinearGradient(vw - sideW, 0, vw, 0);
      grdSideR.addColorStop(0, '#8f0d1b');
      grdSideR.addColorStop(0.5, '#c4122b');
      grdSideR.addColorStop(1, '#660812');
      ctx.fillStyle = grdSideR;
      ctx.fillRect(vw - sideW, -extraTop, sideW + bleed, sideH + extraTop);

      // Fold lines on side curtains
      ctx.strokeStyle = 'rgba(0,0,0,0.25)';
      ctx.lineWidth = 1.2;
      for (let x = 12; x < sideW; x += 16) {
        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x - 4, sideH); ctx.stroke();
      }
      for (let x = vw - sideW + 4; x < vw - 4; x += 16) {
        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x + 4, sideH); ctx.stroke();
      }

      // (branding moved to spawn area; old top placement disabled)
    }

    function drawRunway() { // Draw runway, edges, and center stripes
      const y = world.runwayY(); // Y coordinate for runway
      const w = world.runwayW(); // Visual runway width (currently not used directly)
      // edges (dark floor beyond runway) — extend beyond screen edges like curtains
      ctx.fillStyle = '#1b1b24';
      {
        const s = Number(view && view.scale) > 0 ? Number(view.scale) : 1;
        const bleed = Math.max(400, Math.ceil((1/s - 1) * vw) + 400);
        ctx.fillRect(-bleed, y + 18, vw + bleed*2, vh - y); // Large rect covering bottom area
      }
      // Rope stanchions along the carpet sides (draw BEFORE carpet so carpet is in front)
      const postStep = 140; // distance between posts
      const topY = y - 6;   // near top edge of carpet
      const botY = y + 28;  // near bottom edge of carpet
      const gold = getComputedStyle(document.documentElement).getPropertyValue('--runway-edge') || '#f1cf63';

      // Build screen-space openings where rope should not cross
      const openings = [];
      for (const sec of sections) {
        const left = (stage.leftOffset + sec.x) - camera.x + 18; // just inside left pillar (shifted stage)
        const right = (stage.leftOffset + sec.x) - camera.x + sec.w - 18; // just inside right pillar
        if (right < -50 || left > vw + 50) continue; // skip off-screen
        openings.push({ left, right });
      }

      let prevX_rope = null;
      for (let sx = -((camera.x % postStep) + postStep); sx < vw + postStep; sx += postStep) {
        const insideOpening = openings.some(o => sx > o.left && sx < o.right);
        // Posts: small vertical poles with a gold cap
        ctx.strokeStyle = '#3a2a2a';
        ctx.lineWidth = 3;
        if (!insideOpening) {
          // top row post (audience side only; no near-side post)
          ctx.beginPath(); ctx.moveTo(sx, topY - 2); ctx.lineTo(sx, topY - 18); ctx.stroke();
          // cap
          ctx.fillStyle = gold;
          ctx.beginPath(); ctx.arc(sx, topY - 20, 3, 0, Math.PI*2); ctx.fill();
        }

        // ropes between this and previous post (slight sag), clipped to openings
        if (prevX_rope !== null) {
          let segments = [[prevX_rope, sx]]; // list of drawable segments
          for (const o of openings) {
            const afterCut = [];
            for (const seg of segments) {
              let a = seg[0], b = seg[1];
              const L = o.left, R = o.right;
              const leftX = Math.min(a,b), rightX = Math.max(a,b);
              if (rightX <= L || leftX >= R) { afterCut.push([a,b]); continue; }
              // Intersection exists: keep parts outside [L,R]
              if (leftX < L) afterCut.push([a < b ? leftX : leftX, a < b ? L : L]);
              if (rightX > R) afterCut.push([a < b ? R : R, a < b ? rightX : rightX]);
            }
            segments = afterCut;
          }
          // Draw remaining segments
          ctx.strokeStyle = gold;
          ctx.lineWidth = 1.6;
          for (const seg of segments) {
            const a = seg[0], b = seg[1];
            if (Math.abs(b - a) < 6) continue; // too short to see
            const midX = (a + b) / 2;
            // top rope (far/audience side only)
            ctx.beginPath();
            ctx.moveTo(a, topY - 18);
            ctx.quadraticCurveTo(midX, topY - 12, b, topY - 18);
            ctx.stroke();
          }
        }
        prevX_rope = sx;
      }
      // runway (red carpet strip)
      ctx.shadowColor = 'rgba(255,180,180,0.35)'; // Soft warm glow
      ctx.shadowBlur = 24;
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--runway'); // Use CSS variable
      ctx.fillRect(-1000, y - 2, vw + 2000, 24); // Extend fully to left
      ctx.shadowBlur = 0; // Reset shadow

      // center studs (small gold circles like carpet tacks)
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--runway-edge'); // Gold
      for (let x = -((camera.x % 80)+80); x < vw + 80; x += 80) {
        ctx.beginPath();
        ctx.arc(x, y + 26, 2.2, 0, Math.PI*2);
        ctx.fill();
      }

      // (rope was drawn before carpet)
    }

    function drawMarquee(sec) { // Draw an interactive marquee for a section
      const y = world.runwayY(); // Base Y
      const screenX = (stage.leftOffset + sec.x) - camera.x; // Convert world X to screen X (shifted)
      // Pillars (sides)
      ctx.fillStyle = '#2a2a36';
      ctx.fillRect(screenX, y - 220, 18, 220); // Left pillar
      ctx.fillRect(screenX + sec.w - 18, y - 220, 18, 220); // Right pillar
      // Header light box (top panel)
      const headerTop = y - 220;
      const headerBottom = y - 140;
      const grd = ctx.createLinearGradient(0, headerTop, 0, headerBottom); // Vertical gradient
      grd.addColorStop(0, '#3a3a4a');
      grd.addColorStop(1, '#1c1c26');
      ctx.fillStyle = grd;
      ctx.fillRect(screenX + 18, headerTop, sec.w - 36, 80); // Panel between pillars
      // Title text in the header
      ctx.fillStyle = '#ffffff';
      ctx.font = '700 16px system-ui'; // Bold 16px
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(sec.title, screenX + sec.w/2, y - 180); // Centered label
      // Accent underglow strip
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent');
      ctx.globalAlpha = 0.4; // Semi transparent
      ctx.fillRect(screenX + 20, headerBottom + 2, sec.w - 40, 4); // Thin bar under header
      ctx.globalAlpha = 1; // Restore alpha

      // Entrance curtains per section: fully open at center, close as you walk away
      const gold = getComputedStyle(document.documentElement).getPropertyValue('--accent') || '#f1cf63';
      const boxX = screenX + 18; const boxW = sec.w - 36; // between the pillars
      // Taller curtains only on mobile landscape so header text is covered there,
      // but keep desktop browsers at the original height.
      const isMobileLandscape = (vw > vh) && IS_TOUCH;
      // Keep curtains above the red carpet (stop right at carpet top)
      const curtainBottomY = Math.floor(world.runwayY() - 2);
      const boxTop = headerBottom; // attach directly to header bottom regardless of zoom
      const boxH = Math.max(12, curtainBottomY - boxTop); // extend down to carpet edge

      // Backdrop image behind the curtains (visible through the opening)
      if (doorBackdropReady && doorBackdropImg && doorBackdropImg.naturalWidth) {
        ctx.save();
        // Clip to the area between pillars and below the header
        ctx.beginPath();
        ctx.rect(boxX, boxTop, boxW, boxH);
        ctx.clip();
        // Cover-fit the image within the box, preserving aspect ratio
        const iw = doorBackdropImg.naturalWidth;
        const ih = doorBackdropImg.naturalHeight;
        const scale = Math.max(boxW / iw, boxH / ih);
        const dw = Math.ceil(iw * scale);
        const dh = Math.ceil(ih * scale);
        const dx = Math.floor(boxX + (boxW - dw) / 2);
        const dy = Math.floor(boxTop + (boxH - dh) / 2);
        ctx.drawImage(doorBackdropImg, dx, dy, dw, dh);
        ctx.restore();
      }
      const centerXWorld = stage.leftOffset + sec.x + sec.w/2; // world center with stage offset
      const dist = Math.abs(player.x - centerXWorld); // distance from player to center
      // Scale opening radius with zoom so curtains don't open too early when zoomed in
      const radius = 220 * Math.max(1, Number(view && view.scale) || 1); // distance at which curtains fully closed
      const open = Math.max(0, Math.min(1, 1 - dist / radius)); // 0..1
      const minCurtain = 10; // min width of each curtain when fully open
      const overlap = 6; // small overlap so no sliver shows through
      const gap = Math.max(0, open * (boxW - minCurtain*2) - overlap);
      const half = boxW / 2;
      const leftRight = boxX + half - gap/2; // right edge of left curtain
      const rightLeft = boxX + half + gap/2; // left edge of right curtain

      // Curtain gradients (deep red)
      const redL = ctx.createLinearGradient(boxX, boxTop, boxX + half, boxTop);
      redL.addColorStop(0, '#660812'); redL.addColorStop(0.5, '#c4122b'); redL.addColorStop(1, '#8f0d1b');
      const redR = ctx.createLinearGradient(boxX + half, boxTop, boxX + boxW, boxTop);
      redR.addColorStop(0, '#8f0d1b'); redR.addColorStop(0.5, '#c4122b'); redR.addColorStop(1, '#660812');

      // Left curtain
      ctx.fillStyle = redL;
      ctx.fillRect(boxX, boxTop, Math.max(minCurtain, leftRight - boxX), boxH);
      // Right curtain
      ctx.fillStyle = redR;
      ctx.fillRect(rightLeft, boxTop, Math.max(minCurtain, boxX + boxW - rightLeft), boxH);

      // Fold lines for gentle curtain texture (aligned to half-pixels to avoid flicker)
      (function drawFoldLines(){
        const y1 = Math.round(boxTop) + 0.5;
        const y2 = Math.round(boxTop + boxH) + 0.5;
        ctx.strokeStyle = 'rgba(0,0,0,0.22)';
        ctx.lineWidth = 1;
        for (let x = Math.ceil(boxX + 8); x < leftRight; x += 14) {
          const x1 = Math.round(x) + 0.5;
          const x2 = Math.round(x - 3) + 0.5;
          ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();
        }
        for (let x = Math.ceil(rightLeft + 4); x < boxX + boxW - 4; x += 14) {
          const x1 = Math.round(x) + 0.5;
          const x2 = Math.round(x + 3) + 0.5;
          ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();
        }
      })();

      // (Removed gold tiebacks to avoid visual confusion)
      // Instruction bubble if player is close — position just above the avatar's head
      const d = Math.abs(player.x - (stage.leftOffset + sec.x + sec.w/2)); // Distance from player to center
      if (d < 120) { // Show hint when near
        // Player head in scene space -> convert to screen for DOM tooltip
        const headSceneX = (player.x - camera.x) + 16;
        const headSceneY = y - 58;
        const tipSceneY = headSceneY - 24; // above head
        const pt = sceneToScreen(headSceneX, tipSceneY);
        showTooltip(Math.round(pt.x), Math.round(pt.y), 'Press Up or Enter to open');
      }
    }
    

    function drawPlayer() { // Blocky/voxel-like character with normal gait
      const baseY = world.runwayY();                // Ground baseline (runway level)
      const px = player.x - camera.x;               // Player X on screen
      const facing = player.facing || 1;            // 1 or -1

      // Shadow
      ctx.fillStyle = 'rgba(0,0,0,0.35)';
      ctx.beginPath();
      ctx.ellipse(px + 16, baseY + 10, 22, 6, 0, 0, Math.PI*2);
      ctx.fill();

      // Walk cycle params
      const cadence = 5.2;                          // steps per second-ish
      const phase = player.t * cadence;             // phase angle
      const gait = Math.sin(phase);
      const bob = 0;                                // keep anchors fixed; no vertical bob

      // Model proportions (in pixels)
      const torsoW = 18, torsoH = 24;
      const headS = 14;
      const upperArm = 14, foreArm = 12, armT = 5;
      const thigh = 18, shin = 18, legT = 6;

      // Anchor (hips) and shoulders
      const hips = { x: px + 16, y: baseY - 22 - bob }; // lowered ~10px to sit on carpet
      const shoulders = { x: hips.x, y: hips.y - torsoH + 2 };

      // No canvas flip; keep anchors absolutely fixed to prevent any jumping

      // Helper: draw a rotated rectangle segment anchored at (ax,ay)
      // Adds a small overlap into the parent joint to avoid gaps and draws an outline.
      function segment(ax, ay, len, thick, angleRad, color) {
        const overlap = 2; // pixels to bury into the parent joint to hide seams
        ctx.save();
        ctx.translate(ax, ay);
        ctx.rotate(angleRad);
        ctx.fillStyle = color;
        ctx.fillRect(-thick/2, -overlap, thick, len + overlap);
        // outline for consistency with head/torso
        ctx.strokeStyle = '#101218';
        ctx.lineWidth = 1;
        ctx.strokeRect(Math.round(-thick/2)+0.5, Math.round(-overlap)+0.5, thick, len + overlap);
        ctx.restore();
        // return end point of the segment (for chaining)
        return {
          x: ax + Math.sin(angleRad) * len,
          y: ay + Math.cos(angleRad) * len,
        };
      }

      // Determine limb angles for a normal gait
      const thighAmp = 0.55;  // radians swing ~31°
      const shinBase = 0.25;  // base knee bend
      const armAmp = 0.45;    // arm swing ~26°

      // Back vs front decision so we render depth correctly
      // When gait>0, left leg forward, right back (arbitrary); draw back limb first
      const drawBackFirst = gait > 0; // simplifies ordering

      // Colors (slight depth shading for back limbs)
      const frontCol = '#e6e9ef';
      const backCol  = '#c9cdd6';
      const bodyCol  = '#e9ecf3';
      const outline  = '#101218';

      // Legs
      function drawLeg(side) { // side: -1 = left, +1 = right
        const swing = (side === -1 ? gait : -gait);
        const legAng = swing * thighAmp + 0.03; // single solid limb angle
        const color = (swing < 0 ? backCol : frontCol);
        // Compute length so ankle hits the carpet regardless of angle
        const startX = hips.x + side*6, startY = hips.y - 2;
        const dy = (baseY - startY);
        const cosA = Math.max(0.6, Math.cos(legAng)); // avoid extreme lengths near 90°
        const legLen = Math.max(thigh + shin - 2, dy / cosA);
        segment(startX, startY, legLen, legT, legAng, color);
        // no feet: legs meet the carpet directly
      }

      // Arms (counter-swing to legs)
      function drawArm(side) { // side: -1 = left, +1 = right
        const swing = (side === -1 ? -gait : gait);
        const armAng = swing * armAmp - 0.1; // single solid arm angle
        const color = (swing > 0 ? backCol : frontCol);
        // Anchor stays fixed at torso edge; prevents any lateral 'teleporting'
        const torsoLeft  = shoulders.x - torsoW/2;
        const torsoRight = shoulders.x + torsoW/2;
        const anchorX = (side === -1) ? (torsoLeft + 2) : (torsoRight - 2);
        const anchorY = shoulders.y + 4;
        segment(anchorX, anchorY, upperArm + foreArm, armT, armAng, color);
      }

      // Draw order: back leg, back arm, torso+head, front arm, front leg
      if (drawBackFirst) { drawLeg(+1); drawArm(+1); } else { drawLeg(-1); drawArm(-1); }

      // Torso (block)
      ctx.save();
      ctx.fillStyle = bodyCol;
      ctx.strokeStyle = outline;
      ctx.lineWidth = 1.2;
      ctx.fillRect(shoulders.x - torsoW/2, shoulders.y, torsoW, torsoH);
      ctx.strokeRect(shoulders.x - torsoW/2, shoulders.y, torsoW, torsoH);
      ctx.restore();

      // Head (square)
      ctx.save();
      ctx.fillStyle = bodyCol;
      ctx.strokeStyle = outline;
      ctx.lineWidth = 1.2;
      const headX = shoulders.x - headS/2;
      const headY = shoulders.y - headS - 4;
      ctx.fillRect(headX, headY, headS, headS);
      ctx.strokeRect(headX, headY, headS, headS);
      ctx.restore();

      // Front limbs on top
      if (drawBackFirst) { drawArm(-1); drawLeg(-1); } else { drawArm(+1); drawLeg(+1); }
    }

    function drawBackgroundParallax() { // Rows of audience dots moving slower than foreground (parallax)
      const yBase = world.runwayY(); // Base y near runway level
      const rows = 3; // Number of audience rows
      for (let r = 0; r < rows; r++) { // For each row
        const rowY = yBase - 50 - r*26; // Higher for further rows
        const density = 0.002 * (r+1); // More sparse further back
        for (let x = -100; x < vw + 100; x += 12) { // Across the screen
          const wx = Math.floor((x + camera.x * (0.3 + r*0.15))); // World-ish x for randomization
          // pseudo-random scatter using a simple LCG-like hash
          if (((wx * 1103515245 + 12345) >>> 0) % Math.floor(1/density) === 0) {
            ctx.fillStyle = 'rgba(255,255,255,' + (0.12 + r*0.06) + ')'; // light dots for dark background
            ctx.fillRect(x, rowY + ((wx>>3)%5), 2, 2); // Tiny audience dot
          }
        }
      }
    }

    // FOREGROUND PAPARAZZI (blocky silhouettes with occasional camera flashes)
    function drawPaparazziForeground(layer) {
      const y = world.runwayY();                     // runway baseline
      // Keep silhouettes lower in landscape so they don't sit mid-screen
      const isLandscape = vw > vh;
      // Position feet depending on layer: 'back' sits further down and dimmer; default is foreground
      const footBase = (layer === 'back')
        ? (isLandscape ? (vh - 120) : (vh - 220))
        : (isLandscape ? (vh - 50) : (vh - 160));
      const t = performance.now() * 0.001;
      const spacing = layer === 'back' ? 260 : 220;          // base spacing; back row a bit wider
      const rx = layer === 'back' ? 140 : 180, ry = 36;      // flash halo size

      // simple deterministic pseudo-random
      const rnd = (n) => { const s = Math.sin(n) * 43758.5453; return s - Math.floor(s); };

      for (let pass = 0; pass < 2; pass++) { // second pass doubles count
        const xOffset = pass ? spacing / 2 : 0;   // stagger horizontally
        const yDrop   = 0;                         // keep feet aligned at the bottom
        // Iterate over world-space positions so figures are stationary in the world
        const worldStart = Math.floor((camera.x - 160) / spacing) * spacing;
        const worldEnd = camera.x + vw + 160;
        for (let wx = worldStart; wx < worldEnd; wx += spacing) {
          const cell = Math.floor((wx + xOffset) / spacing) + pass * 997;
          const seed = cell * 918273 + 13579;
          const jitter = (rnd(seed) - 0.5) * 80; // +/- 40px in screen space
          const rawH = 72 + Math.floor(rnd(seed + 1) * 44); // 72..116
          const w = 22 + Math.floor(rnd(seed + 2) * 10); // 22..32
          const sx = Math.floor((wx - camera.x) + xOffset + jitter);
          const footY = footBase + yDrop;
          // Ensure silhouettes never overlap the carpet: clamp height to foreground space
          const maxH = Math.max(24, footY - (y + 48));
          const h = Math.min(rawH, maxH);

          // Silhouette body (blocky / voxel-like)
          ctx.save();
          // compute camera/face params regardless of layer so flashes have anchors
          const head = 16 + Math.floor(rnd(seed + 3) * 4);
          const camW = 14, camH = 8;
          const camY = footY - h - Math.floor(head * 0.5);
          const faceRight = (cell % 2) === 0; // every other paparazzi faces left
          const camX = faceRight ? (sx + w + 6) : (sx - 6 - camW);
          if (layer !== 'back') {
            ctx.fillStyle = 'rgba(8,10,14,0.88)';
            // body
            ctx.fillRect(sx, footY - h, w, h);
            // head (square)
            ctx.fillRect(sx + Math.floor(w/2 - head/2), footY - h - head - 2, head, head);
            // camera box
            ctx.fillRect(camX, camY, camW, camH);
            // lens nub
            if (faceRight) {
              ctx.fillRect(camX + camW - 4, camY + 2, 4, 4);
            } else {
              ctx.fillRect(camX, camY + 2, 4, 4);
            }
            // arm to camera
            if (faceRight) {
              ctx.fillRect(sx + w - 3, camY + 2, 6, 6);
            } else {
              ctx.fillRect(sx - 3, camY + 2, 6, 6);
            }
          }

          // occasional flash
          const period = 2.5 + rnd(seed + 4) * 2.0;        // 2.5..4.5s
          const phase = (t + rnd(seed + 5) * period) % period;
          // paparazzi flash (softened)
          if (phase < 0.12) {
            const fx = faceRight ? (camX + camW) : camX;
            const fy = camY + camH / 2;
            const g = ctx.createRadialGradient(fx, fy, 0, fx, fy, rx);
            g.addColorStop(0, (layer === 'back') ? 'rgba(255,255,220,0.12)' : 'rgba(255,255,220,0.18)');
            g.addColorStop(1, 'rgba(255,255,220,0)');
            ctx.fillStyle = g;
            ctx.beginPath(); ctx.arc(fx, fy, rx, 0, Math.PI * 2); ctx.fill();
            // bright sparkle
            ctx.fillStyle = (layer === 'back') ? 'rgba(255,250,200,0.4)' : 'rgba(255,250,200,0.6)';
            ctx.beginPath(); ctx.arc(fx, fy, layer === 'back' ? 3 : 4, 0, Math.PI * 2); ctx.fill();
          }
          ctx.restore();
        }
      }
    }

    function update(dt) { // Update simulation for one frame
      player.walking = false; // Reset walking flag
      const runMul = keys.run ? 3.6 : 1; // Shift to run (doubled sprint speed)
      if (keys.left)  { player.x -= world.speed * runMul * 60 * dt; player.facing = -1; player.walking = true; } // Move left
      if (keys.right) { player.x += world.speed * runMul * 60 * dt; player.facing = 1;  player.walking = true; } // Move right
      player.x = Math.max(0, Math.min(world.width, player.x)); // Clamp player within world bounds
      if (player.walking) player.t += dt * (keys.run ? 3.0 : 1); else player.t *= 0.8; // Faster gait when running (doubled)

      // camera follows with smoothing, while keeping player on-screen with margins
      const baseTarget = player.x - vw * 0.4; // original follow bias
      // Screen margin constraints (pixels) accounting for scene nudge
      const margin = { left: 60, right: 60 };
      const pxNudge = (view.offsetX || 0);
      const lowerBound = player.x + pxNudge - (vw - margin.right); // min camera.x so player not off right
      const upperBound = player.x + pxNudge - margin.left;          // max camera.x so player not off left
      // World bounds
      const worldMin = 0;
      const worldMax = Math.max(0, world.width - vw);
      // Valid camera range intersection
      const camMin = Math.max(worldMin, lowerBound);
      const camMax = Math.min(worldMax, upperBound);
      // Clamp target into valid range
      const target = Math.max(camMin, Math.min(camMax, baseTarget));
      camera.x += (target - camera.x) * 0.12; // Ease camera towards target
    }

    let last = performance.now(); // Timestamp of previous frame
    function frame(now) { // Main animation loop
      const dt = Math.min(0.05, (now - last) / 1000); // Delta time in seconds (clamped)
      last = now; // Store current time for next frame
      update(dt); // Step the simulation

      // Clear entire canvas in device pixels regardless of transform
      ctx.save();
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.restore();

      // Apply view zoom (uniform scale) with slight upward bias on zoom-out
      const baseScale = Number(view.baseScale) || 1.5;
      const s = Number(view.scale) > 0 ? Number(view.scale) : baseScale;
      const minS = Number(window.zoomMinScale || 0.6);
      const xAnchor = vw * 0.5;           // anchor horizontally at screen center
      const yAnchor = world.runwayY();    // anchor vertically at runway
      const tx = xAnchor * (1 - s);
      const zoomOut = Math.max(0, Math.min(1, (baseScale - s) / Math.max(0.0001, baseScale - minS)));
      const tyCenter = yAnchor * (1 - s);
      const extraUp = 160 * zoomOut;      // move scene up as you zoom out (more headroom above doors)
      const tyCap = -yAnchor * 0.92;      // do not overshoot the very top
      // Apply additional manual lift from slider (move scene DOWN to reveal more of the TOP)
      // Positive values shift the scene downward; clamp to a max of +250px
      const lift = Math.max(0, Math.min(250, Number(view.yLift) || 0));
      const ty = Math.max(tyCap, Math.min(250, (tyCenter - extraUp) + lift));
      view._tx = tx; view._ty = ty; // expose current transform for input mapping
      ctx.setTransform(DPR * s, 0, 0, DPR * s, DPR * tx, DPR * ty);
      // Optional extra nudge (not used by default; stage.leftOffset handles layout)
      if (view.offsetX) ctx.translate(view.offsetX, 0);

      // ambient background with subtle marble texture
      const bgCol = getComputedStyle(document.documentElement).getPropertyValue('--bg') || '#12090c';
      ctx.fillStyle = bgCol;
      ctx.fillRect(0, 0, vw, vh);
      if (marbleTex) {
        ctx.save();
        ctx.globalAlpha = 0.55; // slightly stronger to keep marble visible
        ctx.drawImage(marbleTex, 0, 0, vw, vh); // single, seamless texture
        ctx.restore();
      }

      // drawBackgroundParallax(); // Disabled to remove tiny background speckle dots
      
      drawCurtains();           // Big red curtains framing the stage
      drawSpotlights();         // Moving soft lights (in front of curtains)
      drawSpawnBranding();      // Branding at spawn, stays put as you walk away
      drawEndcapBranding(ENDCAP_X); // Second branding after last door for a visual endcap
      
      drawRunway();             // Ground and runway
      if (window.paparazziOn !== false) drawPaparazziStrip(); // PNG robots row
      try { updatePaparazziBtnPosition(); } catch (_) {}

      // sections
      hideTooltip(); // Hide tooltip before possibly showing it for a nearby section
      for (const sec of sections) { // Render visible marquees
        const scrX = (stage.leftOffset + sec.x) - camera.x; // Screen x for culling (shifted)
        if (scrX + sec.w < -50 || scrX > vw + 50) continue; // Skip if far off-screen
        drawMarquee(sec); // Draw this marquee
      }
      
       // Foreground silhouettes and flashes (behind player)
      drawPlayer(); // Draw the model/figure

      // edge fades to soften edges (disabled by default to avoid visible side bands)
      const bgCol2 = getComputedStyle(document.documentElement).getPropertyValue('--bg') || '#12090c';
      const isLandscape = vw > vh;
      if (view.edgeFades && (!isLandscape || view.edgeFadesInLandscape)) {
        ctx.save();
        if (view.offsetX) ctx.translate(-view.offsetX, 0); // undo scene nudge for fades
        const g = ctx.createLinearGradient(0,0,80,0); g.addColorStop(0,bgCol2); g.addColorStop(1,'transparent'); // Left fade
        ctx.fillStyle = g; ctx.fillRect(0,0,80,vh);
        const g2 = ctx.createLinearGradient(vw,0,vw-80,0); g2.addColorStop(0,bgCol2); g2.addColorStop(1,'transparent'); // Right fade
        ctx.fillStyle = g2; ctx.fillRect(vw-80,0,80,vh);
        ctx.restore();
      }

      requestAnimationFrame(frame); // Queue next frame
    }
    requestAnimationFrame(frame); // Kick off animation loop
  })(); // End IIFE
  </script>
</body>
</html>





