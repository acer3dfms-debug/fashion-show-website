<!DOCTYPE html> <!-- Tell the browser this is an HTML5 document -->
<html lang="en"> <!-- Root element with language set to English -->
<head>
  <meta charset="utf-8" /> <!-- Use UTF-8 character encoding -->
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover" /> <!-- Responsive + use full safe area on iOS -->
  <!-- Make the browser UI bars match the dark theme (iOS Safari honors media-specific theme-color) -->
  <meta name="theme-color" media="(prefers-color-scheme: light)" content="#15171c" />
  <meta name="theme-color" media="(prefers-color-scheme: dark)" content="#15171c" />
  <meta name="color-scheme" content="dark" />
  <!-- The following two affect iOS only when added to Home Screen (PWA mode) -->
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black" />
  <title>Fashion Show</title> <!-- Browser tab title -->
  <style>
    :root { /* CSS variables for theme colors used throughout */
      --bg: #15171c;            /* Dark grey marble base background */
      --runway: #b60c2f;        /* Red carpet color */
      --runway-edge: #f1cf63;   /* Gold accents */
      --accent: #f1cf63;        /* Gold accents for UI */
      --ui: #ffffff;            /* General UI text color */
      --spot: rgba(255,255,255,0.06); /* Soft spotlight color */
      --modal-bg: rgba(0,0,0,0.6);    /* Dim background behind modal */
      --popup-scale: 1;         /* Global scale for popup boxes (modal, settings); range 0.5–1.5 */
    }
    html, body {
      margin: 0; height: 100%; background: var(--bg); color: var(--ui); /* Full-height dark background */
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif; /* Nice default font stack */
      overflow: hidden; /* Hide scrollbars; camera handles movement */
    }
    /* Keep CTA button styling used inside modals */
    .navBtn { appearance: none; background: rgba(255,255,255,0.1); color: var(--ui); border: 1px solid rgba(255,255,255,0.2); border-radius: 999px; padding: 6px 10px; white-space: nowrap; cursor: pointer; backdrop-filter: blur(8px); }
    .navBtn:hover { background: rgba(255,255,255,0.18); }
    #legend { position: fixed; bottom: 10px; left: 10px; z-index: 5; font-size: 12px; opacity: 0.85; line-height: 1.4; background: rgba(0,0,0,0.35); padding: 8px 28px 8px 10px; border-radius: 8px; border: 1px solid rgba(255,255,255,0.1); max-width: min(92vw, 420px); overflow-wrap: anywhere; } /* On-screen help */
    #legend .legendClose { position: absolute; top: 4px; right: 6px; width: 18px; height: 18px; border-radius: 50%; appearance: none; border: 1px solid rgba(255,255,255,0.35); background: rgba(255,255,255,0.12); color: #fff; font-size: 12px; line-height: 16px; padding: 0; cursor: pointer; display: grid; place-items: center; }
    #legend .legendClose:hover { background: rgba(255,255,255,0.2); }
    #tooltip { position: fixed; padding: 8px 10px; background: rgba(20,20,30,0.9); color: var(--ui); border: 1px solid rgba(255,255,255,0.2); border-radius: 8px; pointer-events: none; transform: translate(-50%, -120%); white-space: nowrap; z-index: 4; display: none; } /* Floating hint bubble */
    #hoverTip { position: fixed; padding: 6px 8px; background: rgba(20,20,30,0.9); color: var(--ui); border: 1px solid rgba(255,255,255,0.2); border-radius: 6px; pointer-events: none; transform: translate(calc(-100% - 12px), -10px); white-space: nowrap; z-index: 6; display: none; font-size: 12px; }
    #modalWrap { position: fixed; inset: 0; display: none; place-items: center; background: var(--modal-bg); backdrop-filter: blur(6px); z-index: 10; } /* Fullscreen modal overlay */
    #modal { width: min(720px, 92vw); max-height: 80vh; overflow-y: auto; overflow-x: hidden; background: transparent; border: 0; border-radius: 0; box-shadow: none; } /* Modal scroll container; visual chrome moved to .popupInner */
    #modal header { display:flex; align-items:center; justify-content:space-between; padding: 14px 16px; border-bottom: 1px solid rgba(255,255,255,0.1); position: sticky; top:0; background:#121219; } /* Sticky modal header */
    #modal .content { padding: 16px; } /* Modal content area */
    #closeModal { appearance: none; background: rgba(255,255,255,0.1); color: var(--ui); border: 1px solid rgba(255,255,255,0.2); border-radius: 10px; padding: 6px 10px; cursor: pointer; } /* Close button */

    /* Mobile controls (optional) */
    #controls { position: fixed; right: 12px; bottom: 12px; display: grid; gap: 8px; z-index: 6; } /* Docked control cluster */
    #controls button { appearance: none; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.08); color: var(--ui); border-radius: 12px; font-size: 14px; padding: 10px 12px; min-width: 44px; backdrop-filter: blur(6px); } /* Tappable buttons */

    /* Paparazzi toggle button (world-anchored near spawn) */
    #paparazziBtn { position: fixed; z-index: 7; appearance: none; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.08); color: var(--ui); border-radius: 999px; font-size: 12px; padding: 6px 10px; backdrop-filter: blur(6px); cursor: pointer; }
    #controlsToggleBtn { position: fixed; z-index: 7; appearance: none; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.08); color: var(--ui); border-radius: 999px; font-size: 12px; padding: 6px 10px; backdrop-filter: blur(6px); cursor: pointer; }
    /* Scroll Up control: bubble container with header + slider */
    #scrollWrap { position: fixed; z-index: 7; display: grid; gap: 6px; align-items: center; justify-items: stretch; width: 160px; padding: 10px 12px 12px; border-radius: 14px; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.2); backdrop-filter: blur(6px); }
    #scrollWrap .title { font-size: 11px; color: var(--ui); opacity: 0.95; line-height: 1; }
    #zoomSlider { position: static; width: 100%; accent-color: var(--accent); }
    #zoomSlider, #zoomSlider::-webkit-slider-runnable-track { height: 16px; }
    #zoomSlider::-webkit-slider-runnable-track { border-radius: 999px; background: rgba(255,255,255,0.12); border: 1px solid rgba(255,255,255,0.18); }
    /* Center 28px thumb; nudge slightly down and extend visually with a bottom highlight */
    #zoomSlider::-webkit-slider-thumb { -webkit-appearance: none; width: 28px; height: 28px; border-radius: 50%; background: var(--accent); border: 1px solid rgba(255,255,255,0.2); margin-top: -3px; box-shadow: 0 1px 3px rgba(0,0,0,0.35), 0 2px 0 var(--accent); }
    #zoomSlider::-moz-range-track { height: 16px; border-radius: 999px; background: rgba(255,255,255,0.12); border: 1px solid rgba(255,255,255,0.18); }
    #zoomSlider::-moz-range-thumb { width: 28px; height: 28px; border-radius: 50%; background: var(--accent); border: 1px solid rgba(255,255,255,0.2); box-shadow: 0 1px 3px rgba(0,0,0,0.35); }

    /* Prevent text selection / callout on touch for on-screen controls and HUD */
    #controls, #controls button, #legend, #tooltip, canvas {
      user-select: none;
      -webkit-user-select: none;
      -ms-user-select: none;
      -webkit-touch-callout: none;
      -webkit-user-drag: none;
      -khtml-user-select: none;
    }
    /* Settings button and panel */
    #settingsBtn { position: fixed; left: 10px; top: 10px; z-index: 9; appearance: none; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.1); color: var(--ui); border-radius: 12px; font-size: 14px; padding: 8px 12px; width: 120px; height: 36px; display: grid; place-items: center; backdrop-filter: blur(8px); cursor: pointer; }
    #settingsBtn:hover { background: rgba(255,255,255,0.16); }
    /* Always-visible Help button under Settings */
    #helpBtn { position: fixed; left: 10px; top: 52px; z-index: 9; appearance: none; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.1); color: var(--ui); border-radius: 12px; font-weight: 700; font-size: 16px; line-height: 1; width: 120px; height: 36px; display: grid; place-items: center; backdrop-filter: blur(8px); cursor: pointer; }
    #helpBtn:hover { background: rgba(255,255,255,0.16); }
    #settingsPanel { position: fixed; left: 10px; top: 46px; z-index: 9; width: min(90vw, 260px); max-height: calc(100vh - 60px); overflow-y: auto; overflow-x: hidden; display: none; background: transparent; color: var(--ui); border: 0; border-radius: 0; box-shadow: none; backdrop-filter: blur(10px); scrollbar-gutter: stable both-edges; padding-right: 12px; box-sizing: border-box; }
    #settingsPanel header { position: sticky; top: 0; z-index: 1; display:flex; align-items:center; justify-content: space-between; padding: 8px 10px; border-bottom: 1px solid rgba(255,255,255,0.15); background: rgba(20,20,28,0.95); }
    /* Popup chrome base */
    .popupInner {
      background: #121219;
      border: 1px solid rgba(255,255,255,0.15);
      border-radius: 16px;
      box-shadow: 0 20px 60px rgba(0,0,0,0.6);
      margin: 0 auto; /* keep centered within container */
      box-sizing: border-box;
      padding: 8px 10px;
    }
    /* Uniform scale for Settings (anchor top-left near screen edge) */
    #settingsPanel .popupInner {
      transform: scale(var(--popup-scale));
      transform-origin: top left;
      /* subtract 2px to account for scaled 1px border so right edge doesn't clip */
      width: calc((100% - 2px) / var(--popup-scale));
      will-change: transform;
      contain: layout paint;
    }
    /* Uniform scale for Modal (centered) */
    #modal .popupInner {
      transform: scale(var(--popup-scale));
      transform-origin: top center;
      width: calc((100% - 2px) / var(--popup-scale));
      will-change: transform;
      contain: layout paint;
    }
    #settingsPanel header strong { font-size: 13px; }
    #settingsClose, #settingsReset, #musicPlayBtn { appearance: none; border: 1px solid rgba(255,255,255,0.2); background: rgba(255,255,255,0.1); color: var(--ui); border-radius: 8px; font-size: 12px; padding: 6px 10px; cursor: pointer; }
    #settingsReset { margin-right: 6px; }
    #settingsContent { padding: 10px; display: grid; gap: 10px; }
    /* When inside settings, make controls flow statically */
    #settingsPanel #paparazziBtn { position: static; width: 100%; }
    #settingsPanel #controlsToggleBtn { position: static; width: 100%; }
    #settingsPanel #scrollWrap, #settingsPanel #musicWrap, #settingsPanel #controlsSizeWrap, #settingsPanel #popupSizeWrap, #settingsPanel #pngSizeWrap { position: static; width: auto; max-width: 100%; padding: 8px 10px; border-radius: 999px; background: rgba(255,255,255,0.08); border: 1px solid rgba(255,255,255,0.2); backdrop-filter: none; box-shadow: none; overflow: hidden; display: block; gap: 0; }
    #settingsPanel #scrollWrap .title, #settingsPanel #musicWrap .title, #settingsPanel #controlsSizeWrap .title, #settingsPanel #popupSizeWrap .title, #settingsPanel #pngSizeWrap .title { margin: 0; font-size: 12px; opacity: 0.9; display:flex; align-items:center; justify-content: space-between; gap:8px; }
    #settingsPanel #zoomSlider, #settingsPanel #musicSlider, #settingsPanel #controlsSizeSlider, #settingsPanel #popupSizeSlider, #settingsPanel #pngSizeSlider { width: calc(100% - 4px); margin: 0 2px; display: block; box-sizing: border-box; }
    /* Make both sliders share the same clean bar + thumb styling inside Settings */
    #settingsPanel input[type="range"] { -webkit-appearance: none; appearance: none; background: transparent; }
    #settingsPanel input[type="range"]::-webkit-slider-runnable-track { height: 8px; border-radius: 999px; background: rgba(255,255,255,0.16); border: 1px solid rgba(255,255,255,0.22); }
    #settingsPanel input[type="range"]::-webkit-slider-thumb { -webkit-appearance: none; width: 16px; height: 16px; border-radius: 50%; background: var(--accent); border: 1px solid rgba(255,255,255,0.28); margin-top: -5px; box-shadow: 0 1px 3px rgba(0,0,0,0.35); }
    #settingsPanel input[type="range"]::-moz-range-track { height: 8px; border-radius: 999px; background: rgba(255,255,255,0.16); border: 1px solid rgba(255,255,255,0.22); }
    #settingsPanel input[type="range"]::-moz-range-thumb { width: 16px; height: 16px; border-radius: 50%; background: var(--accent); border: 1px solid rgba(255,255,255,0.28); box-shadow: 0 1px 3px rgba(0,0,0,0.35); }
    /* Remove blue tap highlight on mobile for interactive chrome */
    #controls button, .navBtn, #closeModal {
      -webkit-tap-highlight-color: transparent;
    }
    /* Keep modal content selectable for copy/paste */
    #modal .content { user-select: text; -webkit-user-select: text; }
    /* CTA row and small notes inside modal */
    .ctaRow { display: flex; flex-wrap: wrap; gap: 8px; margin-top: 8px; }
    .assetNote { opacity: 0.85; font-size: 13px; margin-top: 6px; }
    .muted { opacity: 0.8; }
    /* Keep the instruction box from spanning too wide in portrait mobile */
    @media (orientation: portrait) and (max-width: 640px) {
      #legend { max-width: min(88vw, 320px); }
    }
  </style>
</head>
<body> <!-- Page content -->
  <!-- Removed top translucent UI bar and quick navigation to reduce DOM weight -->
  <div id="legend"> <!-- Bottom-left legend with instructions -->
    <button class="legendClose" title="Dismiss" aria-label="Dismiss">&times;</button>
    Walk left or right to explore sections. Stand under a marquee and press <b>Enter</b> or <b>Up</b> to open. Press <b>Esc</b> or <b>Down</b> to close.
  </div>
  
  <!-- Settings launcher and panel -->
  <button id="settingsBtn" aria-haspopup="dialog" aria-controls="settingsPanel">Settings</button>
  <button id="helpBtn" title="Help" aria-label="Help">?</button>
  <button id="controlsToggleBtn" title="Toggle on-screen controls" aria-pressed="true">On-screen Controls: On</button>
  <div id="settingsPanel" role="dialog" aria-modal="false" aria-label="Settings">
    <div class="popupInner">
      <header>
        <strong>Settings</strong>
        <div>
          <button id="settingsReset" aria-label="Reset Settings" title="Reset settings to defaults">Reset</button>
          <button id="settingsClose" aria-label="Close Settings">Close</button>
        </div>
      </header>
      <div id="settingsContent"></div>
    </div>
  </div>
  
  <div id="tooltip"></div> <!-- Floating tooltip that appears when close to a section -->
  <div id="hoverTip" aria-hidden="true"></div> <!-- Pointer hover hint for clickable areas -->
  <button id="paparazziBtn" title="Toggle paparazzi" aria-pressed="true">Paparazzi: On</button>
  <div id="scrollWrap">
    <div class="title">Camera Lift <span id="zoomLabel"></span></div>
    <input id="zoomSlider" type="range" min="0" max="100" step="1" aria-label="Camera Lift" />
  </div>
  <div id="controlsSizeWrap" style="display:none;">
    <div class="title">On-screen Controls Size <span id="controlsSizeLabel"></span></div>
    <input id="controlsSizeSlider" type="range" min="50" max="150" step="5" aria-label="On-screen Controls Size" />
  </div>
  <div id="popupSizeWrap" style="display:none;">
    <div class="title">Popup Zoom <span id="popupSizeLabel"></span></div>
    <input id="popupSizeSlider" type="range" min="50" max="150" step="5" aria-label="Popup Zoom" />
  </div>
  <div id="musicWrap" style="display:none;">
    <div class="title">Music Volume <span id="musicLabel"></span></div>
    <input id="musicSlider" type="range" min="0" max="150" step="1" aria-label="Music Volume" />
  </div>
  <button id="musicPlayBtn" style="display:none;" title="Play music" aria-label="Play music">Play Music</button>
  <div id="pngSizeWrap" style="display:none;">
    <div class="title">Stage Image Size <span id="pngSizeLabel"></span></div>
    <input id="pngSizeSlider" type="range" min="50" max="150" step="5" aria-label="Stage Image Size" />
  </div>
  <div id="modalWrap" aria-hidden="true"> <!-- Fullscreen modal overlay -->
    <div id="modal" role="dialog" aria-modal="true"> <!-- Modal container -->
      <div class="popupInner">
        <header> <!-- Modal header with title and close action -->
          <strong id="modalTitle">Section</strong> <!-- Title is filled in dynamically -->
          <button id="closeModal" aria-label="Close">Close</button> <!-- Closes the modal -->
        </header>
        <div class="content" id="modalContent"> <!-- Container for section HTML content -->
          <!-- populated dynamically -->
        </div>
      </div>
    </div>
  </div>
  <canvas id="stage"></canvas> <!-- Fullscreen canvas used to draw the runway and avatar -->

  <div id="controls" aria-hidden="false"> <!-- On-screen control buttons for touch/mobile -->
    <button id="btnLeft"  title="Walk left" aria-label="Walk left">&larr;</button> <!-- Walk left -->
    <button id="btnRight" title="Walk right" aria-label="Walk right">&rarr;</button> <!-- Walk right -->
    <button id="btnUp"    title="Open (Up/Enter)" aria-label="Open (Up/Enter)">&uarr; / Enter</button> <!-- Open section -->
    <button id="btnSprint" title="Toggle sprint" aria-label="Toggle sprint">Sprint: Off</button> <!-- Sprint toggle -->
  </div>

  <script>
  (() => { // IIFE: wrap all logic to avoid leaking variables to global scope
    // Minimal error overlay to surface runtime errors quickly
    window.addEventListener('error', (e) => {
      const el = document.createElement('div');
      el.style.position = 'fixed'; el.style.bottom = '6px'; el.style.left = '6px';
      el.style.zIndex = '9999'; el.style.background = 'rgba(200,0,0,0.9)'; el.style.color = '#fff';
      el.style.padding = '6px 8px'; el.style.borderRadius = '6px'; el.style.fontSize = '12px';
      el.textContent = 'Error: ' + (e?.message || 'unknown');
      document.body.appendChild(el);
    }, { once: true });

    // Basic touch capability hint (used for mobile-only layout tweaks)
    const IS_TOUCH = ('ontouchstart' in window) || (navigator.maxTouchPoints > 0) || (navigator.msMaxTouchPoints > 0);

    // On touch devices, prevent long-press text selection/callout on HUD and canvas
    if ('ontouchstart' in window) {
      document.addEventListener('contextmenu', (e) => {
        if (e.target.closest('#controls, canvas, #uiBar, #legend')) {
          e.preventDefault();
        }
      }, { capture: true });
    }
    const canvas = document.getElementById('stage'); // Grab the canvas element
    const ctx = canvas.getContext('2d'); // 2D drawing context for canvas

    // High-DPI handling: recompute DPR on every resize/zoom for crisp rendering
    let DPR = window.devicePixelRatio || 1; // Will be updated inside resize()
    const DPR_CAP = 3; // cap for performance; increase if you want extra sharpness
    let vw = window.innerWidth, vh = window.innerHeight; // Current viewport width/height in CSS pixels
    let marbleTex = null; // Offscreen canvas for full-screen marble texture
    let brandingImg = null; // Branding image (drawn on the main curtain)
    let brandingReady = false; // Loaded flag
    let doorBackdropImg = null; // Image shown behind door curtains when they open
    let doorBackdropReady = false; // Loaded flag for door backdrop

    // Helper to choose a reasonable zoom for small screens
    function autoScaleForWidth(width) {
      let s = 1.75;
      if (width <= 420) s = 1.15;      // small phones
      else if (width <= 640) s = 1.25; // phones / small phablets
      else if (width <= 900) s = 1.5;  // tablets / small laptops
      return s;
    }

    function resize() { // Resize handler to keep canvas in sync with window (and zoom)
      vw = window.innerWidth; vh = window.innerHeight; // Update viewport size
      // Update DPR on every resize/zoom so the backing store stays crisp
      DPR = Math.min(DPR_CAP, window.devicePixelRatio || 1);
      canvas.width = Math.floor(vw * DPR); // Set canvas backing width in device pixels
      canvas.height = Math.floor(vh * DPR); // Set canvas backing height in device pixels
      canvas.style.width = vw + 'px'; // Match CSS size
      canvas.style.height = vh + 'px'; // Match CSS size
      ctx.setTransform(DPR, 0, 0, DPR, 0, 0); // Scale drawing so 1 unit = 1 CSS pixel
      // Prefer crisp rendering for raster steps
      if ('imageSmoothingEnabled' in ctx) ctx.imageSmoothingEnabled = false;
      // Responsive zoom: on small screens, step back the camera a bit (use window.view to avoid TDZ)
      if (window.view && window.view.autoScale) {
        window.view.scale = autoScaleForWidth(vw);
      }
      // Orientation tweaks: scale up a bit in landscape (content larger), scale down slightly in portrait
      if (window.view && window.view.autoScaleLandscape) {
        const isLandscape = vw > vh;
        const base = window.view.baseScale || window.view.scale || 1.5;
        if (isLandscape) {
          // Landscape: shrink more on touch devices, and reduce on desktops for wider view
          const factor = (typeof IS_TOUCH !== 'undefined' && IS_TOUCH) ? 0.70 : 0.80; // desktop ~20% smaller
          window.view.scale = Math.max(0.6, Math.min(2, base * factor));
        } else {
          // Portrait: shrink a bit on touch, keep base on desktop
          const factorP = (typeof IS_TOUCH !== 'undefined' && IS_TOUCH) ? 0.90 : 1.0;
          window.view.scale = Math.max(0.6, Math.min(2, base * factorP));
        }
      }
      buildMarblePattern(); // Rebuild background texture for new size/theme
    }
    window.addEventListener('resize', resize); // Re-run on window resize
    window.addEventListener('resize', () => { try { updateSettingsScrollPad(); } catch(_){} });
    window.addEventListener('orientationchange', () => setTimeout(resize, 100));
    resize(); // Initialize canvas size immediately

    // Load branding image helper (call once; safe to call again to change src)
    function loadBranding(src) {
      brandingReady = false;
      brandingImg = new Image();
      brandingImg.onload = () => { brandingReady = true; };
      brandingImg.onerror = () => { brandingReady = false; };
      brandingImg.src = src;
    }
    // Default expected filename (place this image next to index.html)
    loadBranding('assets/images/fashion-show-branding.png');
    // Expose a setter for quick swaps via console if needed

    // Load per-door backdrop image (displayed behind opening curtains)
    function loadDoorBackdrop(src) {
      doorBackdropReady = false;
      doorBackdropImg = new Image();
      doorBackdropImg.onload = () => { doorBackdropReady = true; };
      doorBackdropImg.onerror = () => { doorBackdropReady = false; };
      doorBackdropImg.src = src;
    }
    // Default filename expected alongside index.html; safe to replace at runtime
    loadDoorBackdrop('assets/images/door-backdrop.png');

    // Optional per-door backdrops: door-backdrop_1.png ... door-backdrop_7.png
    const doorBackdropSet = {}; // index -> { img, ready }
    function loadDoorBackdropSet(count) {
      for (let i = 1; i <= count; i++) {
        const img = new Image();
        doorBackdropSet[i] = { img, ready: false };
        img.onload = () => { doorBackdropSet[i].ready = true; };
        img.onerror = () => { doorBackdropSet[i].ready = false; };
        img.src = `assets/images/door-backdrop_${i}.png`;
      }
    }
    loadDoorBackdropSet(7);
    
    // Load paparazzi strip images (alternate left/right across the bottom)
    let paparazziLeftImg = new Image();
    let paparazziRightImg = new Image();
    let paparazziLeftReady = false;
    let paparazziRightReady = false;

    function loadPaparazziPair(leftSrc, rightSrc) {
      paparazziLeftReady = paparazziRightReady = false;
      paparazziLeftImg.onload = () => { paparazziLeftReady = true; };
      paparazziRightImg.onload = () => { paparazziRightReady = true; };
      paparazziLeftImg.onerror = () => { paparazziLeftReady = false; };
      paparazziRightImg.onerror = () => { paparazziRightReady = false; };
      paparazziLeftImg.src = leftSrc;
      paparazziRightImg.src = rightSrc;
    }
    // Default pair (files should exist next to index.html)
    loadPaparazziPair('assets/images/paparazzi_left.png', 'assets/images/paparazzi_right.png');

    // Stage props: Gary statues and judge chairs (drawn behind door curtains)
    let statueImg = new Image();
    let chairImg = new Image();
    let statueReady = false;
    let chairReady = false;
    function loadStageProps(statueSrc, chairSrc) {
      statueReady = chairReady = false;
      statueImg.onload = () => { statueReady = true; };
      statueImg.onerror = () => { statueReady = false; };
      chairImg.onload = () => { chairReady = true; };
      chairImg.onerror = () => { chairReady = false; };
      statueImg.src = statueSrc;
      chairImg.src = chairSrc;
    }
    loadStageProps('assets/images/gary_statue.png', 'assets/images/judge_chair.png');

    // Limo image at far left of the catwalk
    let limoImg = new Image();
    let limoReady = false;
    function loadLimo(src) {
      limoReady = false;
      limoImg = new Image();
      limoImg.onload = () => { limoReady = true; };
      limoImg.onerror = () => { limoReady = false; };
      limoImg.src = src;
    }
    loadLimo('assets/images/limo_0.png');
    // Removed runtime asset swap helpers for leaner API

    // AVATAR SPRITE SHEET (128x128 frames)
    // Rows:
    // 0: idle right (5 frames)
    // 1: idle left  (5 frames)
    // 2: walk right (11 frames)
    // 3: walk left  (11 frames)
    const AVATAR = {
      img: new Image(),
      ready: false,
      fw: 128,
      fh: 128,
      // Number of source pixels from the bottom of the frame to the soles.
      // Increase if feet appear to hover; decrease if they sink into the carpet.
      footInset: 16, // nudged up from 10 to drop avatar slightly
      // Overall size multiplier applied after viewport-based target height
      sizeMul: 0.847, // another +10% (feet remain anchored)
      // Screen-space vertical nudge in pixels (positive moves sprite down)
      yNudge: 10,
      seq: {
        idleRight: { row: 0, len: 5,  fps: 3 },
        idleLeft:  { row: 1, len: 5,  fps: 3 },
        walkRight: { row: 2, len: 11, fps: 12 },
        walkLeft:  { row: 3, len: 11, fps: 12 },
        // New sprint rows (0-based): 4 = sprint right (19 frames), 5 = sprint left (19 frames)
        sprintRight: { row: 4, len: 19, fps: 20 },
        sprintLeft:  { row: 5, len: 19, fps: 20 },
      }
    };
    AVATAR.img.onload = () => { AVATAR.ready = true; };
    AVATAR.img.onerror = () => { AVATAR.ready = false; };
    AVATAR.img.src = 'assets/images/avatar_sprite_sheet.png';
    // Console tuning helpers removed for leaner surface

    // Draw alternating paparazzi tiles under the runway
    function drawPaparazziStrip() {
      if (!(paparazziLeftReady || paparazziRightReady)) return;
      const yRunway = world.runwayY();
      // Base target height; scale to be 1/3 smaller than previous doubled size
      const targetHBase = Math.max(36, Math.min(120, Math.floor(vh * 0.14)));
      const isSmallScreen = (vw < 900) || (vh < 600); // heuristic for phones/smaller tablets
      let targetH = Math.floor(targetHBase * (4/3));   // desktop baseline size (~1.33x base)
      if (isSmallScreen) targetH = Math.floor(targetH * 1.25); // make robots ~25% larger on small screens
      const hL = paparazziLeftReady ? paparazziLeftImg.naturalHeight : (paparazziRightReady ? paparazziRightImg.naturalHeight : 100);
      const hR = paparazziRightReady ? paparazziRightImg.naturalHeight : hL;
      const scaleL = targetH / hL;
      const scaleR = targetH / hR;
      const tileWL = paparazziLeftReady ? Math.ceil(paparazziLeftImg.naturalWidth * scaleL) : Math.ceil(paparazziRightImg.naturalWidth * scaleR);
      const tileWR = paparazziRightReady ? Math.ceil(paparazziRightImg.naturalWidth * scaleR) : tileWL;
      // Position row: move up another 75px on both desktop and small screens
      const yTop = Math.floor(yRunway + (isSmallScreen ? 75 : 105));
      const baseTile = Math.max(1, Math.min(tileWL, tileWR));
      const start = Math.floor((camera.x - vw) / baseTile) * baseTile;
      const end = camera.x + vw + baseTile;
      const t = performance.now() * 0.001;
      // deterministic pseudo-random helper for per-tile variance
      const rnd = (n) => { const s = Math.sin(n) * 43758.5453; return s - Math.floor(s); };
      // Removed unused back row drawing

      // Front row (original)
      let tileIndex = 0;
      ctx.save();
      ctx.globalAlpha = 0.98;
      let useLeft = true;
      for (let wx = start; wx < end; ) {
        const img = (useLeft && paparazziLeftReady) ? paparazziLeftImg : (paparazziRightReady ? paparazziRightImg : paparazziLeftImg);
        const isLeft = (img === paparazziLeftImg);
        const scale = (isLeft ? scaleL : scaleR) * PNG_SCALE;
        const dw = Math.ceil(img.naturalWidth * scale);
        const dh = Math.ceil(img.naturalHeight * scale);
        const sx = Math.floor(wx - camera.x);
        // Draw the paparazzi tile
        ctx.drawImage(img, sx, yTop, dw, dh);

        // Camera flash effect near the camera position on each tile
        // Compute a per-tile flashing pattern
        const seed = tileIndex * 101 + (isLeft ? 1 : 2);
        const freq = 0.8 + rnd(seed + 1) * 1.4;     // 0.8..2.2 Hz
        const phase = rnd(seed + 2) * Math.PI * 2;   // 0..2π
        // Short bright pop using a steep power curve
        let pulse = Math.sin(t * freq + phase);
        pulse = pulse > 0.92 ? Math.pow((pulse - 0.92) / 0.08, 2) : 0; // only top 8% of the wave
        if (pulse > 0) {
          // Position near the camera: UL for left-facing, UR for right-facing
          const cx = isLeft ? (sx + Math.round(dw * 0.18)) : (sx + Math.round(dw * (1 - 0.18)));
          const cy = yTop + Math.round(dh * 0.16);
          // Make flashes 5x larger than before
          const baseInner = Math.max(6, Math.round(Math.min(dw, dh) * 0.08));
          const rInner = Math.max(6, Math.round(baseInner * 5));
          const rOuter = Math.max(14, Math.round(rInner * 2.2));
          const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, rOuter);
          // Make flashes ~1.2x brighter than before (with a higher cap)
          let a = Math.min(0.65, 0.25 + pulse * 0.5);
          a = Math.min(0.78, a * 1.2); // boost and cap
          g.addColorStop(0.0, `rgba(255,255,255,${a})`);
          g.addColorStop(0.3, `rgba(255,255,255,${a*0.7})`);
          g.addColorStop(1.0, 'rgba(255,255,255,0)');
          ctx.save();
          ctx.globalCompositeOperation = 'screen'; // brighten without blowing out blacks
          ctx.fillStyle = g;
          ctx.beginPath();
          ctx.arc(cx, cy, rOuter, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }

        wx += dw;
        useLeft = !useLeft;
        tileIndex++;
      }
      ctx.restore();

      // Back row drawn ON TOP: lower, larger, and horizontally offset; orientation alternates with PNG zoom
      {
        let tileIndexB = 0;
        // Alternate starting flip based on current PNG_SCALE bucket to look good at different zooms
        const zoomBucket = Math.max(5, Math.min(15, Math.round((PNG_SCALE || 1) * 10))); // 0.5..1.5 -> 5..15
        const startLeftB = (zoomBucket % 2) === 1; // odd buckets start with left; even with right
        let useLeftB = startLeftB;
        const yTopBack = yTop + 60;         // lower on screen (further down)
        const scaleMulBack = 1.25;          // larger size
        const startBack = start + Math.floor(baseTile / 2); // half-tile offset
        ctx.save();
        ctx.globalAlpha = 0.96; // slightly brighter since this row is on top
        for (let wx = startBack; wx < end; ) {
          const img = (useLeftB && paparazziLeftReady) ? paparazziLeftImg : (paparazziRightReady ? paparazziRightImg : paparazziLeftImg);
          const isLeft = (img === paparazziLeftImg);
          const scale = (isLeft ? scaleL : scaleR) * scaleMulBack * PNG_SCALE;
          const dw = Math.ceil(img.naturalWidth * scale);
          const dh = Math.ceil(img.naturalHeight * scale);
          const sx = Math.floor(wx - camera.x) + 48; // shift middle row to the right by ~48px (18 + 30)
          ctx.drawImage(img, sx, yTopBack, dw, dh);

          // Subtler flash for back row
          const seed = tileIndexB * 97 + (isLeft ? 3 : 5);
          const freq = 0.8 + rnd(seed + 1) * 1.4;
          const phase = rnd(seed + 2) * Math.PI * 2;
          let pulse = Math.sin(t * freq + phase);
          pulse = pulse > 0.94 ? Math.pow((pulse - 0.94) / 0.06, 2) : 0; // rarer, softer
          if (pulse > 0) {
            const cx = isLeft ? (sx + Math.round(dw * 0.18)) : (sx + Math.round(dw * (1 - 0.18)));
            const cy = yTopBack + Math.round(dh * 0.16);
            const baseInner = Math.max(6, Math.round(Math.min(dw, dh) * 0.08));
            const rInner = Math.max(6, Math.round(baseInner * 4));
            const rOuter = Math.max(14, Math.round(rInner * 2.0));
            const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, rOuter);
            let a = Math.min(0.55, 0.22 + pulse * 0.4);
            g.addColorStop(0.0, `rgba(255,255,255,${a})`);
            g.addColorStop(0.3, `rgba(255,255,255,${a*0.7})`);
            g.addColorStop(1.0, 'rgba(255,255,255,0)');
            ctx.save(); ctx.globalCompositeOperation = 'screen'; ctx.fillStyle = g;
            ctx.beginPath(); ctx.arc(cx, cy, rOuter, 0, Math.PI * 2); ctx.fill();
            ctx.restore();
          }

          wx += dw;
          useLeftB = !useLeftB;
          tileIndexB++;
        }
        ctx.restore();
      }

      // Fore row drawn LAST: even lower and bigger to fill the bottom
      {
        let tileIndexC = 0;
        let useLeftC = false; // switch starting orientation for variety
        const yTopFore = yTop + 110;        // drop further down
        const scaleMulFore = 1.55;          // biggest row
        const startFore = start + Math.floor(baseTile * 3 / 4) + 10; // new stagger
        ctx.save();
        ctx.globalAlpha = 0.99; // most prominent
        for (let wx = startFore; wx < end; ) {
          const img = (useLeftC && paparazziLeftReady) ? paparazziLeftImg : (paparazziRightReady ? paparazziRightImg : paparazziLeftImg);
          const isLeft = (img === paparazziLeftImg);
          const scale = (isLeft ? scaleL : scaleR) * scaleMulFore * PNG_SCALE;
          const dw = Math.ceil(img.naturalWidth * scale);
          const dh = Math.ceil(img.naturalHeight * scale);
          const sx = Math.floor(wx - camera.x);
          ctx.drawImage(img, sx, yTopFore, dw, dh);

          // Flash effect similar to front row
          const seed = tileIndexC * 89 + (isLeft ? 7 : 11);
          const freq = 0.8 + rnd(seed + 1) * 1.4;
          const phase = rnd(seed + 2) * Math.PI * 2;
          let pulse = Math.sin(t * freq + phase);
          pulse = pulse > 0.92 ? Math.pow((pulse - 0.92) / 0.08, 2) : 0;
          if (pulse > 0) {
            const cx = isLeft ? (sx + Math.round(dw * 0.18)) : (sx + Math.round(dw * (1 - 0.18)));
            const cy = yTopFore + Math.round(dh * 0.16);
            const baseInner = Math.max(6, Math.round(Math.min(dw, dh) * 0.08));
            const rInner = Math.max(6, Math.round(baseInner * 5));
            const rOuter = Math.max(14, Math.round(rInner * 2.2));
            const g = ctx.createRadialGradient(cx, cy, 0, cx, cy, rOuter);
            let a = Math.min(0.78, 0.28 + pulse * 0.55);
            g.addColorStop(0.0, `rgba(255,255,255,${a})`);
            g.addColorStop(0.3, `rgba(255,255,255,${a*0.7})`);
            g.addColorStop(1.0, 'rgba(255,255,255,0)');
            ctx.save(); ctx.globalCompositeOperation = 'screen'; ctx.fillStyle = g;
            ctx.beginPath(); ctx.arc(cx, cy, rOuter, 0, Math.PI * 2); ctx.fill();
            ctx.restore();
          }

          wx += dw;
          useLeftC = !useLeftC;
          tileIndexC++;
        }
        ctx.restore();
      }
    }

    // Build a subtle marble texture as a repeated pattern
    function buildMarblePattern() {
      const cw = Math.max(1, Math.floor(vw));
      const ch = Math.max(1, Math.floor(vh));
      const off = document.createElement('canvas');
      off.width = cw; off.height = ch;
      const c = off.getContext('2d');
      const bgCol = getComputedStyle(document.documentElement).getPropertyValue('--bg') || '#15171c';
      c.fillStyle = bgCol; c.fillRect(0,0,cw,ch);

      const area = cw * ch;
      const diag = Math.hypot(cw, ch);

      // cloudy areas for dark marble (soft lightening)
      const cloudCount = Math.max(6, Math.floor(area / 180000));
      for (let i = 0; i < cloudCount; i++) {
        const x = Math.random()*cw;
        const y = Math.random()*ch;
        const r = diag * (0.10 + Math.random()*0.18);
        const g = c.createRadialGradient(x,y,0,x,y,r);
        g.addColorStop(0, 'rgba(255,255,255,0.10)');
        g.addColorStop(1, 'rgba(255,255,255,0)');
        c.fillStyle = g;
        c.beginPath(); c.arc(x,y,r,0,Math.PI*2); c.fill();
      }

      // subtle warm/cool tints for depth
      const warmCount = Math.max(3, Math.floor(area / 350000));
      for (let i = 0; i < warmCount; i++) {
        const x = Math.random()*cw, y = Math.random()*ch, r = diag * (0.10 + Math.random()*0.14);
        const tintWarm = c.createRadialGradient(x,y,0,x,y,r);
        tintWarm.addColorStop(0, 'rgba(180,160,140,0.05)');
        tintWarm.addColorStop(1, 'rgba(180,160,140,0)');
        c.fillStyle = tintWarm; c.beginPath(); c.arc(x,y,r,0,Math.PI*2); c.fill();
      }
      const coolCount = Math.max(2, Math.floor(area / 480000));
      for (let i = 0; i < coolCount; i++) {
        const x = Math.random()*cw, y = Math.random()*ch, r = diag * (0.10 + Math.random()*0.14);
        const tintCool = c.createRadialGradient(x,y,0,x,y,r);
        tintCool.addColorStop(0, 'rgba(140,160,180,0.05)');
        tintCool.addColorStop(1, 'rgba(140,160,180,0)');
        c.fillStyle = tintCool; c.beginPath(); c.arc(x,y,r,0,Math.PI*2); c.fill();
      }

      // faint veins: subtle criss-cross lines for marble texture
      c.lineCap = 'round';
      const veinCount = Math.max(14, Math.floor(area / 220000));
      for (let i = 0; i < veinCount; i++) {
        const ang = (-25 + Math.random()*50) * Math.PI/180;
        const len = diag * (0.5 + Math.random()*0.6);
        const cx = Math.random()*cw;
        const cy = Math.random()*ch;
        const dx = Math.cos(ang)*len/2;
        const dy = Math.sin(ang)*len/2;
        c.strokeStyle = 'rgba(220,220,220,0.10)';
        c.lineWidth = 1 + Math.random()*1.5;
        c.shadowColor = 'rgba(0,0,0,0.10)';
        c.shadowBlur = 2;
        c.beginPath();
        c.moveTo(cx-dx, cy-dy);
        c.quadraticCurveTo(cx + (Math.random()-0.5)*60, cy + (Math.random()-0.5)*60, cx+dx, cy+dy);
        c.stroke();
        if (Math.random() < 0.4) {
          c.beginPath(); c.moveTo(cx, cy);
          c.quadraticCurveTo(cx + (Math.random()-0.5)*40, cy + (Math.random()-0.5)*40, cx+dx*0.35, cy+dy*0.35);
          c.stroke();
        }
        // highlight
        c.strokeStyle = 'rgba(255,255,255,0.12)';
        c.shadowBlur = 0;
        c.beginPath(); c.moveTo(cx-dx, cy-dy);
        c.quadraticCurveTo(cx + (Math.random()-0.5)*50, cy + (Math.random()-0.5)*50, cx+dx, cy+dy);
        c.stroke();
      }
      c.shadowBlur = 0;

      // speckles (disabled for a cleaner background)
      const speckCount = 0;
      for (let i = 0; i < speckCount; i++) {
        const x = Math.random()*cw;
        const y = Math.random()*ch;
        c.fillStyle = Math.random() < 0.5 ? 'rgba(255,255,255,0.07)' : 'rgba(0,0,0,0.08)';
        c.fillRect(x, y, 1, 1);
      }

      marbleTex = off; // store full-screen texture
    }

    // Pre-rendered golden bulb sprite for marquee lights (for smooth drawing)
    let BULB_SPRITE = null;
    function ensureBulbSprite() {
      if (BULB_SPRITE) return BULB_SPRITE;
      // Increase bulb size by 50% for a bolder look
      const s = 30; // sprite size (square)
      const off = document.createElement('canvas');
      off.width = s; off.height = s;
      const c = off.getContext('2d');
      const r = s / 2;
      const g = c.createRadialGradient(r, r, 0, r, r, r);
      // Warm gold glow with a tighter falloff for a crisper look
      g.addColorStop(0.0, 'rgba(241,207,99,1.0)');
      g.addColorStop(0.22, 'rgba(241,207,99,0.85)');
      g.addColorStop(0.60, 'rgba(241,207,99,0)');
      c.fillStyle = g;
      c.beginPath(); c.arc(r, r, r, 0, Math.PI*2); c.fill();
      BULB_SPRITE = off;
      return BULB_SPRITE;
    }

    // Draw branding image at spawn area behind the carpet (world-anchored)
    function drawSpawnBranding() {
      if (!(brandingReady && brandingImg && brandingImg.naturalWidth)) return;
      const curtainTop = Math.max(60, world.runwayY() - (220 + CURTAIN_LIFT));
      const carpetTop = world.runwayY() - 2; // top edge of carpet
      const padAboveCarpet = 18;            // keep a gap above the carpet
      const maxW = Math.min(520, vw * 0.5);
      const maxH = Math.min(240, Math.max(60, carpetTop - padAboveCarpet - curtainTop));
      const scale = Math.min(maxW / brandingImg.naturalWidth, maxH / brandingImg.naturalHeight) * PNG_SCALE;
      const dw = Math.floor(brandingImg.naturalWidth * scale);
      const dh = Math.floor(brandingImg.naturalHeight * scale);

      // Center on the spawn X in world space
      const dx = Math.floor(((SPAWN_X + BRAND_OFFSET_X) - camera.x) - dw / 2);
      // Move branding up by an additional 50px (now total 95px up from original)
      const dy = Math.floor(carpetTop - padAboveCarpet - dh - 95);

      ctx.save();
      // Draw two gold poles holding up the branding, like a billboard
      const gold = getComputedStyle(document.documentElement).getPropertyValue('--runway-edge') || '#f1cf63';
      ctx.fillStyle = gold;
      const poleWidth = 20; // reduce to ~1/3 thickness
      const poleInset = 12; // base inset from image edges
      const extraInset = 30; // move posts inward toward center by 30px
      const poleTop = dy + dh; // start at bottom of image
      const poleBottom = carpetTop - 2; // stop slightly above carpet
      const leftPoleX = dx + poleInset + extraInset;
      const rightPoleX = dx + dw - poleInset - poleWidth - extraInset;
      if (poleBottom > poleTop) {
        ctx.fillRect(leftPoleX, poleTop, poleWidth, poleBottom - poleTop);
        ctx.fillRect(rightPoleX, poleTop, poleWidth, poleBottom - poleTop);
        // small round base caps
        ctx.beginPath(); ctx.arc(leftPoleX + poleWidth/2, poleBottom, 3.5, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(rightPoleX + poleWidth/2, poleBottom, 3.5, 0, Math.PI*2); ctx.fill();
      }
      // very soft shadow so it sits on the wall behind
      ctx.shadowColor = 'rgba(0,0,0,0.25)';
      ctx.shadowBlur = 8;
      ctx.drawImage(brandingImg, dx, dy, dw, dh);

      // Golden outline around the branding
      ctx.shadowBlur = 0;
      ctx.lineWidth = 3;
      ctx.strokeStyle = gold;
      ctx.strokeRect(dx - 2, dy - 2, dw + 4, dh + 4);

      // Small flashing golden light pattern around the brand png
      const t = performance.now() * 0.001;
      const bulbSpacing = 22;
      const bulbR = 3;
      ctx.save();
      ctx.globalCompositeOperation = 'screen';
      // Top edge bulbs
      for (let x = dx; x <= dx + dw; x += bulbSpacing) {
        const i = Math.floor((x - dx) / bulbSpacing);
        const phase = i * 0.6;
        const pulse = Math.max(0, Math.sin(t * 3.0 + phase));
        const a = 0.18 + Math.pow(pulse, 6) * 0.82; // sharp bright pops
        const gx = x, gy = dy - 6;
        const g = ctx.createRadialGradient(gx, gy, 0, gx, gy, bulbR * 4.2);
        g.addColorStop(0, `rgba(241,207,99,${Math.min(1,a)})`);
        g.addColorStop(1, 'rgba(241,207,99,0)');
        ctx.fillStyle = g;
        ctx.beginPath(); ctx.arc(gx, gy, bulbR * 3.8, 0, Math.PI*2); ctx.fill();
      }
      // Bottom edge bulbs
      for (let x = dx + bulbSpacing/2; x <= dx + dw; x += bulbSpacing) {
        const i = Math.floor((x - dx) / bulbSpacing) + 37;
        const phase = i * 0.6;
        const pulse = Math.max(0, Math.sin(t * 3.0 + phase));
        const a = 0.18 + Math.pow(pulse, 6) * 0.82;
        const gx = x, gy = dy + dh + 6;
        const g = ctx.createRadialGradient(gx, gy, 0, gx, gy, bulbR * 4.2);
        g.addColorStop(0, `rgba(241,207,99,${Math.min(1,a)})`);
        g.addColorStop(1, 'rgba(241,207,99,0)');
        ctx.fillStyle = g;
        ctx.beginPath(); ctx.arc(gx, gy, bulbR * 3.8, 0, Math.PI*2); ctx.fill();
      }
      // Left/right edges bulbs (sparser)
      for (let y = dy + 12; y <= dy + dh - 12; y += bulbSpacing * 1.1) {
        const i = Math.floor((y - dy) / bulbSpacing);
        const phase = i * 0.7;
        const pulse = Math.max(0, Math.sin(t * 3.0 + phase));
        const a = 0.12 + Math.pow(pulse, 6) * 0.75;
        const gx1 = dx - 6, gy1 = y;
        const g1 = ctx.createRadialGradient(gx1, gy1, 0, gx1, gy1, bulbR * 4.2);
        g1.addColorStop(0, `rgba(241,207,99,${Math.min(1,a)})`);
        g1.addColorStop(1, 'rgba(241,207,99,0)');
        ctx.fillStyle = g1; ctx.beginPath(); ctx.arc(gx1, gy1, bulbR * 3.8, 0, Math.PI*2); ctx.fill();
        const gx2 = dx + dw + 6, gy2 = y;
        const g2 = ctx.createRadialGradient(gx2, gy2, 0, gx2, gy2, bulbR * 4.2);
        g2.addColorStop(0, `rgba(241,207,99,${Math.min(1,a*0.9)})`);
        g2.addColorStop(1, 'rgba(241,207,99,0)');
        ctx.fillStyle = g2; ctx.beginPath(); ctx.arc(gx2, gy2, bulbR * 3.8, 0, Math.PI*2); ctx.fill();
      }
      ctx.restore();

      // store clickable rect for spawn branding
      view._spawnBrandRect = { x: dx, y: dy, w: dw, h: dh };
      ctx.restore();
    }
    // Draw a second stationary branding at the far right endcap (after last door)
    function drawEndcapBranding(endX) {
      if (!(brandingReady && brandingImg && brandingImg.naturalWidth)) return;
      const curtainTop = Math.max(60, world.runwayY() - (220 + CURTAIN_LIFT));
      const carpetTop = world.runwayY() - 2;
      const padAboveCarpet = 18;
      const maxW = Math.min(520, vw * 0.5);
      const maxH = Math.min(240, Math.max(60, carpetTop - padAboveCarpet - curtainTop));
      const scale = Math.min(maxW / brandingImg.naturalWidth, maxH / brandingImg.naturalHeight) * PNG_SCALE;
      const dw = Math.floor(brandingImg.naturalWidth * scale);
      const dh = Math.floor(brandingImg.naturalHeight * scale);
      const dx = Math.floor((endX - camera.x) - dw / 2);
      // Move branding up by an additional 50px (now total 95px up from original)
      const dy = Math.floor(carpetTop - padAboveCarpet - dh - 95);
      ctx.save();
      // Draw two gold poles for endcap branding as well
      const gold = getComputedStyle(document.documentElement).getPropertyValue('--runway-edge') || '#f1cf63';
      ctx.fillStyle = gold;
      const poleWidth = 20; // reduce to ~1/3 thickness
      const poleInset = 12;
      const extraInset = 30; // move posts inward toward center by 30px
      const poleTop = dy + dh;
      const poleBottom = carpetTop - 2;
      const leftPoleX = dx + poleInset + extraInset;
      const rightPoleX = dx + dw - poleInset - poleWidth - extraInset;
      if (poleBottom > poleTop) {
        ctx.fillRect(leftPoleX, poleTop, poleWidth, poleBottom - poleTop);
        ctx.fillRect(rightPoleX, poleTop, poleWidth, poleBottom - poleTop);
        ctx.beginPath(); ctx.arc(leftPoleX + poleWidth/2, poleBottom, 3.5, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(rightPoleX + poleWidth/2, poleBottom, 3.5, 0, Math.PI*2); ctx.fill();
      }
      ctx.shadowColor = 'rgba(0,0,0,0.25)';
      ctx.shadowBlur = 8;
      ctx.drawImage(brandingImg, dx, dy, dw, dh);

      // Golden outline
      ctx.shadowBlur = 0;
      ctx.lineWidth = 3;
      ctx.strokeStyle = gold;
      ctx.strokeRect(dx - 2, dy - 2, dw + 4, dh + 4);

      // Flashing golden bulbs around frame
      const t2 = performance.now() * 0.001;
      const bulbSpacing2 = 22;
      const bulbR2 = 3;
      ctx.save();
      ctx.globalCompositeOperation = 'screen';
      for (let x = dx; x <= dx + dw; x += bulbSpacing2) {
        const i = Math.floor((x - dx) / bulbSpacing2);
        const phase = i * 0.6 + 0.3; // slight offset so endcap differs
        const pulse = Math.max(0, Math.sin(t2 * 3.0 + phase));
        const a = 0.18 + Math.pow(pulse, 6) * 0.82;
        const gx = x, gy = dy - 6;
        const g = ctx.createRadialGradient(gx, gy, 0, gx, gy, bulbR2 * 4.2);
        g.addColorStop(0, `rgba(241,207,99,${Math.min(1,a)})`);
        g.addColorStop(1, 'rgba(241,207,99,0)');
        ctx.fillStyle = g; ctx.beginPath(); ctx.arc(gx, gy, bulbR2 * 3.8, 0, Math.PI*2); ctx.fill();
      }
      for (let x = dx + bulbSpacing2/2; x <= dx + dw; x += bulbSpacing2) {
        const i = Math.floor((x - dx) / bulbSpacing2) + 41;
        const phase = i * 0.6 + 0.3;
        const pulse = Math.max(0, Math.sin(t2 * 3.0 + phase));
        const a = 0.18 + Math.pow(pulse, 6) * 0.82;
        const gx = x, gy = dy + dh + 6;
        const g = ctx.createRadialGradient(gx, gy, 0, gx, gy, bulbR2 * 4.2);
        g.addColorStop(0, `rgba(241,207,99,${Math.min(1,a)})`);
        g.addColorStop(1, 'rgba(241,207,99,0)');
        ctx.fillStyle = g; ctx.beginPath(); ctx.arc(gx, gy, bulbR2 * 3.8, 0, Math.PI*2); ctx.fill();
      }
      for (let y = dy + 12; y <= dy + dh - 12; y += bulbSpacing2 * 1.1) {
        const i = Math.floor((y - dy) / bulbSpacing2);
        const phase = i * 0.7 + 0.3;
        const pulse = Math.max(0, Math.sin(t2 * 3.0 + phase));
        const a = 0.12 + Math.pow(pulse, 6) * 0.75;
        const gx1 = dx - 6, gy1 = y;
        const g1 = ctx.createRadialGradient(gx1, gy1, 0, gx1, gy1, bulbR2 * 4.2);
        g1.addColorStop(0, `rgba(241,207,99,${Math.min(1,a)})`);
        g1.addColorStop(1, 'rgba(241,207,99,0)');
        ctx.fillStyle = g1; ctx.beginPath(); ctx.arc(gx1, gy1, bulbR2 * 3.8, 0, Math.PI*2); ctx.fill();
        const gx2 = dx + dw + 6, gy2 = y;
        const g2 = ctx.createRadialGradient(gx2, gy2, 0, gx2, gy2, bulbR2 * 4.2);
        g2.addColorStop(0, `rgba(241,207,99,${Math.min(1,a*0.9)})`);
        g2.addColorStop(1, 'rgba(241,207,99,0)');
        ctx.fillStyle = g2; ctx.beginPath(); ctx.arc(gx2, gy2, bulbR2 * 3.8, 0, Math.PI*2); ctx.fill();
      }
      ctx.restore();

      // store clickable rect for endcap branding
      view._endcapBrandRect = { x: dx, y: dy, w: dw, h: dh };
      ctx.restore();
    }

    // WORLD CONFIG
    const world = {
      width: 6000, // base catwalk length in px
      minX: -2000, // extra walking room to the left (negative world space)
      maxX: 6000,  // will be updated after sections are defined
      runwayY: () => Math.floor(vh * 0.62), // Y position of runway relative to viewport
      runwayW: () => Math.min(800, Math.max(420, vw * 0.6)), // Runway visual width
      speed: 2.2, // Base movement speed factor
      ambient: 0.25, // Ambient light factor (not used heavily here)
    };

    // PLAYER (blocky voxel-like avatar with normal gait)
    const SPAWN_X = 360; // anchor for spawn area and branding placement (branding uses this)
    const player = {
      x: SPAWN_X, y: 0, vy: 0, facing: 1, walking: false, t: 0, // position, velocity, facing, walk state, walk time
      width: 32, height: 64, // player dimensions for drawing/placement
      anim: { key: 'idleRight', frame: 0, accum: 0 }, // sprite animation state
    };

    // CAMERA
    const camera = { x: 0 }; // Camera x scroll position (y is fixed by design)
    // Safe default zoom to avoid any auto-scale edge cases causing a blank scene
    const view = { scale: 1.5, offsetX: 0, yLift: 0, globalScale: 0.7, autoScale: false, autoScaleLandscape: true, landscapeScale: 0.9, edgeFades: false, edgeFadesInLandscape: false }; // You can tweak with setViewScale()/setViewOffset()
    // Expose view only; removed console tuning helpers for a leaner API
    window.view = view;
    if (view.baseScale == null) view.baseScale = view.scale; // store base scale
    // Paparazzi toggle (global)
    window.paparazziOn = true;
    // Removed console tuning helpers: setViewScale/setGlobalScale/setViewOffset/setLandscape*/setEdgeFades*
    // Stage layout: shift all marquees and carpet to the right to create a left entry area
    const stage = { leftOffset: 600 };
    // Raise the top valance a bit (in pixels). Increase to move it up more.
    const CURTAIN_LIFT = 30;
    // Branding horizontal offset relative to spawn
    // Place the billboard center ~1800px to the right of the far-left world edge
    let BRAND_OFFSET_X = (((world && typeof world.minX === 'number' ? world.minX : -2000) + 1800) - SPAWN_X);
    // Spawn the avatar near the far-left limo (independent of branding position)
    const LIMO_SPAWN_OFFSET_X = 170; // move avatar spawn further to the right
    try { player.x = (world && typeof world.minX === 'number' ? world.minX : -2000) + LIMO_SPAWN_OFFSET_X; } catch (_) {}
    // Ensure sizing applies with the now-defined view
    try { resize(); } catch (_) {}

    // INTERACTIVE SECTIONS (marquees along the runway)
    /**
     * Each section defines: x position, width, title, and content (HTML).
     * The `x` is in world space; we subtract `camera.x` to get screen position.
     */
    // Sections will be defined below; remove placeholders to avoid confusion
    // Single source of truth: sections are defined later with final content
    let sections = [];

    // Define sections used by the seven doors (final content)
    sections = [
      // Quick Sign-Up door near spawn (to the left)
      { x: -615, w: 340, key: 'signup', title: 'Artist Quick Sign-Up', content: `
        <p>Show your style on the runway. Enter the raffle to become a featured artist for an upcoming monthly show.</p>
        <h4>What you’ll make</h4>
        <ul>
          <li>Full VoxEdit gear set: Headpiece, Chest, Arms, Legs</li>
          <li>Optional: Main-hand and Off-hand equipment</li>
          <li>Original, show-safe voxel work created in VoxEdit</li>
        </ul>
        <h4>How selection works</h4>
        <ul>
          <li>New artists enter the primary raffle</li>
          <li>If slots remain, past artists enter a secondary raffle</li>
          <li>After draws, we announce the theme and the deadline</li>
        </ul>
        <h4>Timeline</h4>
        <ul>
          <li>Theme drop → ~3 weeks to finish your gear set</li>
          <li>Submit 3–5 hero images, a short description, and your display name/socials</li>
          <li>Quick tech check before showtime</li>
        </ul>
        <h4>Ready checklist</h4>
        <ul>
          <li>&#9633; VoxEdit installed</li>
          <li>&#9633; Time for ~3 weeks of build/polish</li>
        </ul>
        <p><strong>Need help?</strong> Join Discord for Q&amp;A, feedback, and tech checks.</p>
        <div class="ctaRow">
          <a class="navBtn" href="https://docs.google.com/forms/d/e/1FAIpQLSejCyO7RukrV90BhihqQB3vkTJEC29arEzdcdXc1HONIPfXNQ/viewform?usp=send_form" target="_blank" rel="noopener">Open Artist Raffle Form</a>
          <a class="navBtn" href="https://www.sandbox.game/en/create/vox-edit/" target="_blank" rel="noopener">Download VoxEdit</a>
          <a class="navBtn" href="https://discord.gg/fCMD3NkXMZ" target="_blank" rel="noopener">Join Discord</a>
          <a class="navBtn" href="#" data-close>Back to Runway</a>
        </div>
      `},
      // Door 1 — About This Website
      { x: 400, w: 360, key: 'about', title: 'The Fashion Show Website', content: `
        <p>Step onto the stage. Walk the runway and stop under a door to open a short popup about the show.</p>
        <h4>Controls</h4>
        <ul>
          <li><strong>Move:</strong> &larr; / &rarr; or A / D, or use the on-screen arrows</li>
          <li><strong>Open a door:</strong> Enter or &uarr; / W, or tap the on-screen Enter</li>
          <li><strong>Close a popup:</strong> Esc or &darr; / S, click outside the popup, or tap the X</li>
        </ul>
        <h4>Quick tips</h4>
        <ul>
          <li>Works on desktop and mobile (best in Chrome/Edge/Safari/Firefox)</li>
          <li>If keys don’t respond, click the page once to give it focus</li>
          <li>If layout looks off, rotate your device or hard refresh (Ctrl/Cmd + Shift + R)</li>
        </ul>
        <div class="ctaRow">
          <a class="navBtn" href="#" data-close>Start Walking</a>
          <a class="navBtn" href="#" data-modal="troubleshooting">Troubleshooting</a>
        </div>
      `},
      // Door 2 — The Show
      { x: 1100, w: 360, key: 'show', title: 'The Fashion Show Origin', content: `
        <p>This show was seeded by a community grant from The Sandbox DAO—funding creators to experiment, tell stories, and put voxel fashion in the spotlight. What began as an idea to showcase voxel artists on a catwalk prototype became a full showcase thanks to DAO support and feedback from builders like you. We’re committed to transparency, community credit, and sharing what we learn so more creators can ship bold ideas.</p>
        <div class="ctaRow">
          <a class="navBtn" href="https://www.sandboxdao.com/" target="_blank" rel="noopener">Open The Sandbox DAO</a>
          <a class="navBtn" href="https://forum.sandboxdao.com/t/sandbox-fashion-show/2744" target="_blank" rel="noopener">Read the Proposal</a>
          <a class="navBtn" href="https://discord.gg/fCMD3NkXMZ" target="_blank" rel="noopener">Get Updates (Discord)</a>
        </div>
      `},
      // Door 3 — How the Show Works (In The Sandbox)
      { x: 1900, w: 360, key: 'origin', title: 'What is the Fashion Show', content: `
        <p>Each month, four featured artists present a themed gearset on a playable catwalk inside The Sandbox. Artists walk the runway for live judging, while the audience joins in from the stands.</p>
        <p>During the show, attendees earn Catwalk Coins (CWK) by exploring, dancing, and other ways. Then they spend CWK to vote for their favorite creations. Judges' scores and audience votes are tallied together to spotlight the monthly winner.</p>
        <ul>
          <li>One main show every month</li>
          <li>Four artists compete per show</li>
          <li>Live panel scores: craft, originality, theme fit</li>
          <li>Audience voting with CWK during timed windows (in-experience)</li>
          <li>Live leaderboard moments</li>
        </ul>
        <div class="ctaRow">
          <a class="navBtn" href="https://www.sandbox.game/en/experiences/The%20Sandbox%20-%20Fashion%20Show/e157abb3-bda0-44c5-a769-8f797f1ebbd4/page/" target="_blank" rel="noopener">Visit Experience Page</a>
          <a class="navBtn" href="https://www.sandbox.game/en/create/vox-edit/" target="_blank" rel="noopener">Get VoxEdit (Create Gear)</a>
          <a class="navBtn" href="https://www.sandbox.game/en/create/game-maker/" target="_blank" rel="noopener">Get Game Maker (Build Experiences)</a>
        </div>
      `},
      // Door 4 — Being an Artist on the Show
      { x: 2700, w: 360, key: 'artists', title: 'Being an Artist', content: `
        <p><strong>Build a full voxel gear set in VoxEdit and bring it to the runway.</strong></p>
        <h4>What you make</h4>
        <ul>
          <li><strong>Required:</strong> Headpiece, Chest, Arms, Legs</li>
          <li><strong>Optional:</strong> Main-hand and Off-hand equipment</li>
          <li>Original work, show-safe, and created in VoxEdit</li>
        </ul>
        <h4>How selection works</h4>
        <ul>
          <li>Sign up on the Google Form to enter the primary raffle (new artists first).</li>
          <li>If slots remain, a secondary raffle includes returning artists from past shows.</li>
        </ul>
        <h4>Timeline</h4>
        <ul>
          <li>A theme is announced after the raffle.</li>
          <li>You have ~3 weeks to finish your gear set.</li>
          <li>Deliverables: 3–5 hero images, short description, display name/socials (asset files for tech check).</li>
        </ul>
        <p><strong>Need help?</strong> Join Discord for Q&amp;A, feedback, and tech checks.</p>
        <div class="ctaRow">
          <a class="navBtn" href="https://docs.google.com/forms/d/e/1FAIpQLSejCyO7RukrV90BhihqQB3vkTJEC29arEzdcdXc1HONIPfXNQ/viewform?usp=send_form" target="_blank" rel="noopener">Artist Raffle Form</a>
          <a class="navBtn" href="https://www.sandbox.game/en/create/vox-edit/" target="_blank" rel="noopener">Download VoxEdit</a>
          <a class="navBtn" href="https://discord.gg/fCMD3NkXMZ" target="_blank" rel="noopener">Join Discord</a>
        </div>
      `},
      // Door 5 — Judging & How to Join
      { x: 3500, w: 360, key: 'judging', title: 'Judging', content: `
        <p>Artists show a gearset on the live runway while a panel scores each look and the audience adds momentum.</p>
        <h4>Scoring (how winners are chosen)</h4>
        <p><strong>Panel score (1–5 per judge):</strong> three judges each pick a number from 1–5.</p>
        <p>Criteria the judges consider:</p>
        <ul>
          <li><strong>Craft &amp; Build Quality</strong> — clean geometry, detail, polish</li>
          <li><strong>Originality &amp; Concept</strong> — idea strength, voice, inventiveness</li>
          <li><strong>Runway Readability &amp; Presence</strong> — silhouette, staging, “reads” at a glance</li>
          <li><strong>Theme Fit</strong> — how well it matches the show’s theme/prompt</li>
        </ul>
        <p><strong>Audience bonus (0–1):</strong> adds 0.0 → 1.0 based on Catwalk Coins (CWK) supporting a look during the voting window.<br>
        <small>(Scaled per show; typically requires &gt; 5,000 CWK for the full +1.0 bonus.)</small></p>
        <p><strong>Final tally</strong> = average panel score + audience bonus. Tie-breaks go to panel discussion.</p>
      `},
      // Door 6 — Join the Community
      { x: 4300, w: 380, key: 'community', title: 'Join the Community', content: `
        <p>Backstage passes live on Discord. Get announcements, submission windows, tech checks, WIP feedback, and post-show recaps. Meet other creators, share progress, and help shape what comes next.</p>
        <h4>What you\u2019ll find</h4>
        <ul>
          <li><code>#announcements</code> &mdash; dates, themes, results</li>
          <li><code>#artist-signup</code> &mdash; raffle reminders &amp; guidelines</li>
          <li><code>#wip-critique</code> &mdash; share progress, get feedback</li>
          <li><code>#tech-help</code> &mdash; VoxEdit/GameMaker setup help</li>
          <li><code>#show-chat</code> &mdash; watch parties &amp; discussion</li>
        </ul>
        <h4>Roles &amp; pings</h4>
        <ul>
          <li>Artist / Judge / Audience roles</li>
          <li>Opt-in @Showtime and @ThemeDrop alerts</li>
        </ul>
        <p>Friendly, modded, PG-13 space. Zero harassment. Bring good vibes.</p>
        <div class="ctaRow">
          <a class="navBtn" href="https://discord.gg/fCMD3NkXMZ" target="_blank" rel="noopener">Join Discord</a>
          <a class="navBtn" href="#" data-modal="rules">Read Server Rules</a>
          <a class="navBtn" href="#" data-modal="ask">Ask a Question</a>
        </div>
      `},
      // Door 7 — Schedule & Following Along
      { x: 5200, w: 380, key: 'schedule', title: 'Schedule & Following Along', content: `
        <p>We run one main show every month on the <strong>fredandferd</strong> Twitch channel—live runway, judges on mic, and chat energy. Between shows, follow updates and theme drops on our Impossible Dream Studio X account, or hop into Discord for reminders and Q&amp;A.</p>
        <p><em>Want to help between live shows?</em> Try the Discord judging bot: preview gear sets, score them, and earn a raffle ticket for each valid vote. Tickets are pulled during “Fun Stream Nights” on Twitch.</p>
        <div class="ctaRow">
          <a class="navBtn" href="https://www.twitch.tv/fredandferd" target="_blank" rel="noopener">Follow on Twitch</a>
          <a class="navBtn" href="https://x.com/ImDream_Studio" target="_blank" rel="noopener">Follow on X</a>
          <a class="navBtn" href="https://discord.gg/fCMD3NkXMZ" target="_blank" rel="noopener">Join Discord</a>
        </div>
      `}
    ];

    // Assign per-door backdrop indices (exclude the quick sign-up door)
    (function assignBackdropIndexes(){
      let idx = 0;
      for (const sec of sections) {
        if (sec.key === 'signup') { sec._backdropIndex = 0; continue; }
        idx += 1; sec._backdropIndex = idx; // 1-based
      }
    })();

    // Reflow door positions so billboard appears first, then Quick Sign-Up starts
    // 4000px to the right of the billboard, and remaining doors follow evenly spaced.
    (function reflowDoors(){
      try {
        const spacing = 780;         // even spacing between door centers/anchors
        const brandCenter = (SPAWN_X + BRAND_OFFSET_X);
        const firstDoorOffset = 300; // px to the right of billboard center
        if (sections[0] && sections[0].key === 'signup') {
          sections[0].x = Math.round(brandCenter + firstDoorOffset);
        }
        let x = (sections[0] ? sections[0].x : (brandCenter + firstDoorOffset)) + spacing;
        for (let i = 1; i < sections.length; i++) {
          sections[i].x = Math.round(x);
          x += spacing;
        }
      } catch(_) {}
    })();
    // Position the endcap logo with the same spacing as the first billboard-to-door gap
    const lastRightEdge = stage.leftOffset + Math.max.apply(null, sections.map(s => s.x + s.w));
    const LAST_SEC = sections[sections.length - 1] || { x: 0, w: 360 };
    const lastCenter = stage.leftOffset + LAST_SEC.x + LAST_SEC.w / 2;
    const END_BILLBOARD_OFFSET = 800; // push end billboard farther to the right
    const TAIL_GAP = 800; // still add world space after last door for padding
    const ENDCAP_X = Math.floor(lastCenter + END_BILLBOARD_OFFSET);
    // Add generous walking room on both ends for future easter eggs/partners
    const EXTRA_WALK_LEFT = 2000;
    const EXTRA_WALK_RIGHT = 2000;
    // Update world span
    world.minX = -EXTRA_WALK_LEFT;
    world.maxX = Math.max(world.width, lastRightEdge + TAIL_GAP) + EXTRA_WALK_RIGHT;
    world.width = world.maxX; // keep legacy code that reads width functioning

    // INPUT
    const keys = { left: false, right: false, run: false, runToggle: false, shiftRun: false }; // Track walking + sprint states
    // Mouse steering dead zone with hysteresis (screen pixels)
    const MOUSE_DEAD_IN = 16;  // threshold to stop when already moving
    const MOUSE_DEAD_OUT = 28; // threshold to start moving when idle
    // Click/hold-to-walk state (scene-space X target)
    let mouseWalk = { active: false, targetX: null };
    window.addEventListener('keydown', e => { // Keyboard controls
      const k = e.key;
      if (k === 'ArrowLeft' || k === 'a' || k === 'A') { keys.left = true; e.preventDefault(); }
      if (k === 'ArrowRight' || k === 'd' || k === 'D') { keys.right = true; e.preventDefault(); }
      if (k === 'Enter' || k === 'ArrowUp' || k === 'w' || k === 'W') { tryOpen(); e.preventDefault(); }
      if (k === 'ArrowDown' || k === 's' || k === 'S' || k === 'Escape' || k === 'Esc') { closeModal(); e.preventDefault(); }
      if (k === 'Shift') { keys.shiftRun = true; }
    });
    window.addEventListener('keyup', e => { // Stop walking when keys released
      const k = e.key;
      if (k === 'ArrowLeft' || k === 'a' || k === 'A') keys.left = false; // Stop left
      if (k === 'ArrowRight' || k === 'd' || k === 'D') keys.right = false; // Stop right
      if (k === 'Shift') keys.shiftRun = false; // Release Shift sprint
    });

    // Mobile buttons
    const btnLeft  = document.getElementById('btnLeft'); // Left button element
    const btnRight = document.getElementById('btnRight'); // Right button element
    const btnUp    = document.getElementById('btnUp'); // Up/open button (Up/Enter)
    const btnSprint = document.getElementById('btnSprint'); // Sprint toggle button
    const paparazziBtn = document.getElementById('paparazziBtn');
    const controlsToggleBtn = document.getElementById('controlsToggleBtn');
    const zoomSlider = document.getElementById('zoomSlider');
    const zoomLabel = document.getElementById('zoomLabel');
    const scrollWrap = document.getElementById('scrollWrap');
    const controlsSizeWrap = document.getElementById('controlsSizeWrap');
    const controlsSizeSlider = document.getElementById('controlsSizeSlider');
    const popupSizeWrap = document.getElementById('popupSizeWrap');
    const popupSizeSlider = document.getElementById('popupSizeSlider');
    const popupSizeLabel = document.getElementById('popupSizeLabel');
    const settingsBtn = document.getElementById('settingsBtn');
    const helpBtn = document.getElementById('helpBtn');
    const settingsPanel = document.getElementById('settingsPanel');
    const settingsContent = document.getElementById('settingsContent');
    const pngSizeWrap = document.getElementById('pngSizeWrap');
    const musicPlayBtn = document.getElementById('musicPlayBtn');
    const pngSizeSlider = document.getElementById('pngSizeSlider');
    const pngSizeLabel = document.getElementById('pngSizeLabel');
    let settingsOpen = false;
    const press = (k, v) => { keys[k] = v; }; // Helper to set key state
    if (btnLeft) {
      btnLeft.addEventListener('pointerdown', () => press('left', true)); // Hold left
      btnLeft.addEventListener('pointerup',   () => press('left', false)); // Release left
      btnLeft.addEventListener('pointerleave',() => press('left', false)); // Stop if pointer leaves
    }
    if (btnRight) {
      btnRight.addEventListener('pointerdown',() => press('right', true)); // Hold right
      btnRight.addEventListener('pointerup',  () => press('right', false)); // Release right
      btnRight.addEventListener('pointerleave',() => press('right', false)); // Stop if pointer leaves
    }
    if (btnUp) {
      try { btnUp.innerHTML = '&uarr; / Enter'; btnUp.title = 'Open (Up/Enter)'; } catch(_) {}
      btnUp.addEventListener('click', () => tryOpen()); // Tap to open
    }
    if (btnSprint) {
      btnSprint.addEventListener('click', () => {
        keys.runToggle = !keys.runToggle; // persistent toggle
        btnSprint.setAttribute('aria-pressed', String(keys.runToggle));
        btnSprint.textContent = keys.runToggle ? 'Sprint: On' : 'Sprint: Off';
      });
    }
    // Start/stop mouse-driven walking along the carpet
    function startMouseWalk(targetSceneX) {
      mouseWalk.active = true; mouseWalk.targetX = targetSceneX;
      // Decide initial direction from player center in scene space
      const centerScene = (player.x - camera.x) + 16;
      const d = (targetSceneX - centerScene);
      keys.left = d < -3; keys.right = d > 3;
    }
    function stopMouseWalk() {
      mouseWalk.active = false; mouseWalk.targetX = null;
      keys.left = false; keys.right = false;
    }
    // World-anchored positioning removed: controls and toggles live in Settings only
    if (paparazziBtn) {
      paparazziBtn.addEventListener('click', () => {
        window.paparazziOn = !window.paparazziOn;
        paparazziBtn.setAttribute('aria-pressed', String(window.paparazziOn));
        paparazziBtn.textContent = 'Paparazzi: ' + (window.paparazziOn ? 'On' : 'Off');
      });
    }
    // Toggle on-screen controls (lower-left gamepad buttons)
    const controlsDiv = document.getElementById('controls');
    function applyControlsVisible(on) {
      try {
        if (!controlsDiv) return;
        controlsDiv.style.display = on ? '' : 'none';
        if (controlsToggleBtn) {
          controlsToggleBtn.setAttribute('aria-pressed', String(on));
          controlsToggleBtn.textContent = 'On-screen Controls: ' + (on ? 'On' : 'Off');
        }
      } catch(_) {}
    }
    let controlsOn = true;
    try {
      const saved = localStorage.getItem('controlsOn');
      if (saved != null) controlsOn = saved === 'true';
    } catch(_) {}
    applyControlsVisible(controlsOn);
    if (controlsToggleBtn) {
      controlsToggleBtn.addEventListener('click', () => {
        controlsOn = !controlsOn;
        try { localStorage.setItem('controlsOn', String(controlsOn)); } catch(_) {}
        applyControlsVisible(controlsOn);
      });
    }
    if (zoomSlider) {
      // Repurpose slider: move camera DOWN to reveal more of the TOP (no zoom)
      // Map 0..100 -> 0..250 px of downward scene shift
      const valueToLift = (v) => Math.max(0, Math.min(250, Math.round(250 * (v/100))));
      // Start with no lift (0)
      zoomSlider.value = '0';
      view.yLift = 0;
      if (zoomLabel) zoomLabel.textContent = '0%';
      view.autoScale = false; // ensure auto zoom doesn’t fight manual lift
      zoomSlider.setAttribute('aria-label', 'Scroll Up');
      zoomSlider.addEventListener('input', () => {
        const v = Number(zoomSlider.value) || 0;
        const lift = valueToLift(v);
        view.yLift = lift;
        if (zoomLabel) zoomLabel.textContent = v + '%';
      });
    }
    // On-screen button size slider
    function getControlsScalePct(){
      // Always default to 100% on refresh (do not persist)
      return 100;
    }
    function applyControlsScale(pct){
      const s = Math.max(0.5, Math.min(1.5, (Number(pct)||100)/100));
      if (controlsDiv) {
        controlsDiv.style.transformOrigin = 'bottom right';
        controlsDiv.style.transform = 'scale(' + s + ')';
      }
      // Also scale the Settings (and Help) buttons so the slider affects them too
      if (typeof settingsBtn !== 'undefined' && settingsBtn) {
        settingsBtn.style.transformOrigin = 'top left';
        settingsBtn.style.transform = 'scale(' + s + ')';
      }
      if (typeof helpBtn !== 'undefined' && helpBtn) {
        helpBtn.style.transformOrigin = 'top left';
        helpBtn.style.transform = 'scale(' + s + ')';
      }
    }
    if (controlsSizeSlider) {
      const lbl = document.getElementById('controlsSizeLabel');
      const init = getControlsScalePct();
      controlsSizeSlider.value = String(init);
      if (lbl) lbl.textContent = init + '%';
      applyControlsScale(init);
      controlsSizeSlider.addEventListener('input', () => {
        const v = Number(controlsSizeSlider.value)||100;
        if (lbl) lbl.textContent = v + '%';
        applyControlsScale(v);
      });
    }
    // PNG size slider (affects all stage PNGs)
    let PNG_SCALE = 1.5; // 0.5 .. 1.5 (default 150%)
    function getPngScalePct(){
      try { return Math.max(50, Math.min(150, Number(localStorage.getItem('pngScalePct')) || 150)); } catch(_) { return 150; }
    }
    function applyPngScale(pct){
      PNG_SCALE = Math.max(0.5, Math.min(1.5, (Number(pct)||100)/100));
      try { document.documentElement.style.setProperty('--png-scale', String(PNG_SCALE)); } catch(_) {}
    }
    if (pngSizeSlider) {
      const init = getPngScalePct();
      pngSizeSlider.value = String(init);
      if (pngSizeLabel) pngSizeLabel.textContent = init + '%';
      applyPngScale(init);
      pngSizeSlider.addEventListener('input', () => {
        const v = Math.max(50, Math.min(150, Number(pngSizeSlider.value)||100));
        if (pngSizeLabel) pngSizeLabel.textContent = v + '%';
        applyPngScale(v);
        try { localStorage.setItem('pngScalePct', String(v)); } catch(_) {}
      });
    }
    // Provide scroll padding for scaled Settings content so the panel scrolls to full height
    function updateSettingsScrollPad(){
      try {
        const panel = document.getElementById('settingsPanel');
        if (!panel || panel.style.display === 'none') return;
        const inner = panel.querySelector('.popupInner');
        if (!inner) return;
        const s = parseFloat(getComputedStyle(document.documentElement).getPropertyValue('--popup-scale')) || 1;
        let spacer = panel.querySelector('#settingsScrollSpacer');
        if (s <= 1) {
          if (spacer) spacer.style.height = '0px';
          return;
        }
        const unscaled = inner.scrollHeight || inner.offsetHeight || 0;
        const extra = Math.max(0, Math.ceil(unscaled * (s - 1)));
        if (!spacer) {
          spacer = document.createElement('div');
          spacer.id = 'settingsScrollSpacer';
          spacer.style.width = '1px';
          spacer.style.height = extra + 'px';
          spacer.style.pointerEvents = 'none';
          spacer.style.opacity = '0';
          panel.appendChild(spacer);
        } else {
          spacer.style.height = extra + 'px';
        }
      } catch(_) {}
    }
    // Popup size slider (affects modal and settings widths)
    function getPopupScalePct(){
      try { return Math.max(50, Math.min(150, Number(localStorage.getItem('popupScalePct')) || 100)); } catch(_) { return 100; }
    }
    function applyPopupScale(pct){
      const s = Math.max(0.5, Math.min(1.5, (Number(pct)||100)/100));
      try {
        document.documentElement.style.setProperty('--popup-scale', String(s));
        updateSettingsScrollPad();
      } catch(_) {}
    }
    if (popupSizeSlider) {
      const init = getPopupScalePct();
      popupSizeSlider.value = String(init);
      if (popupSizeLabel) popupSizeLabel.textContent = init + '%';
      applyPopupScale(init);
      let _popupRAF = 0, _pendingPopup = init;
      popupSizeSlider.addEventListener('input', () => {
        const v = Math.max(50, Math.min(150, Number(popupSizeSlider.value)||100));
        _pendingPopup = v;
        if (popupSizeLabel) popupSizeLabel.textContent = v + '%';
        if (!_popupRAF) {
          _popupRAF = requestAnimationFrame(() => { applyPopupScale(_pendingPopup); _popupRAF = 0; });
        }
      });
      popupSizeSlider.addEventListener('change', () => {
        const v = Math.max(50, Math.min(150, Number(popupSizeSlider.value)||100));
        try { localStorage.setItem('popupScalePct', String(v)); } catch(_) {}
      });
    }
    // SETTINGS PANEL WIRES
    function openSettings() {
      settingsOpen = true;
      settingsPanel.style.display = 'block';
      // Order: Interface, Display, Media, Effects
      try { settingsContent.appendChild(controlsToggleBtn); controlsToggleBtn.style.display = ''; } catch(_){ }
      try { settingsContent.appendChild(controlsSizeWrap); controlsSizeWrap.style.display = ''; } catch(_){ }
      try { settingsContent.appendChild(scrollWrap); scrollWrap.style.display = ''; } catch(_){ }
      try { settingsContent.appendChild(popupSizeWrap); popupSizeWrap.style.display = ''; } catch(_){ }
      try { settingsContent.appendChild(pngSizeWrap); pngSizeWrap.style.display = ''; } catch(_){ }
      try { settingsContent.appendChild(musicWrap); musicWrap.style.display = ''; } catch(_){ }
      try { settingsContent.appendChild(musicPlayBtn); musicPlayBtn.style.display = ''; } catch(_){ }
      try { settingsContent.appendChild(paparazziBtn); paparazziBtn.style.display = ''; } catch(_){ }
      try { if (window.bgAudioControls && window.bgAudioControls.wireSlider) window.bgAudioControls.wireSlider(); } catch(_){}
      try { updateSettingsScrollPad(); } catch(_){}
    }
    function closeSettings() {
      settingsOpen = false;
      settingsPanel.style.display = 'none';
      // Keep controls inside panel; hidden when closed
    }
    function resetSettings() {
      try {
        // On-screen controls visibility
        controlsOn = true;
        try { localStorage.setItem('controlsOn', 'true'); } catch(_) {}
        applyControlsVisible(true);
        // Paparazzi
        window.paparazziOn = true;
        if (paparazziBtn) {
          paparazziBtn.setAttribute('aria-pressed','true');
          paparazziBtn.textContent = 'Paparazzi: On';
        }
        // Scroll Up (y-lift)
        if (zoomSlider) { zoomSlider.value = '0'; }
        if (zoomLabel) { zoomLabel.textContent = '0%'; }
        view.yLift = 0;
        // On-screen controls size
        if (controlsSizeSlider) {
          controlsSizeSlider.value = '100';
          const lbl = document.getElementById('controlsSizeLabel');
          if (lbl) lbl.textContent = '100%';
          applyControlsScale(100);
        }
        // PNG scale
        if (pngSizeSlider) {
          pngSizeSlider.value = '150';
          if (pngSizeLabel) pngSizeLabel.textContent = '150%';
          applyPngScale(150);
          try { localStorage.setItem('pngScalePct','150'); } catch(_) {}
        }
        // Popup size
        if (popupSizeSlider) {
          popupSizeSlider.value = '100';
          if (popupSizeLabel) popupSizeLabel.textContent = '100%';
          applyPopupScale(100);
          try { localStorage.setItem('popupScalePct','100'); } catch(_) {}
        }
        // Music volume
        const musicSlider = document.getElementById('musicSlider');
        const musicLabel = document.getElementById('musicLabel');
        if (musicSlider) musicSlider.value = '50';
        if (musicLabel) musicLabel.textContent = '50%';
        try {
          if (window.bgAudioControls && window.bgAudioControls.setVolumePct) {
            window.bgAudioControls.setVolumePct(50);
          } else {
            localStorage.setItem('musicVolPct','50');
          }
        } catch(_) {}
      } catch(_) {}
    }
    if (settingsBtn) settingsBtn.addEventListener('click', () => { settingsOpen ? closeSettings() : openSettings(); });
    const settingsClose = document.getElementById('settingsClose');
    if (settingsClose) settingsClose.addEventListener('click', () => closeSettings());
    const settingsReset = document.getElementById('settingsReset');
    if (settingsReset) settingsReset.addEventListener('click', () => resetSettings());
    if (musicPlayBtn) {
      musicPlayBtn.addEventListener('click', () => {
        try {
          if (window.bgAudioControls && window.bgAudioControls.kick) window.bgAudioControls.kick();
        } catch(_) {}
      });
    }
    // Hide controls by default until settings opened
    if (helpBtn) helpBtn.addEventListener('click', () => {
      // Open the same modal content as the 'about' door
      try {
        const sec = sections.find(s => s && s.key === 'about');
        if (sec) openModal(sec.title, sec.content);
      } catch(_) {}
    });
    try { paparazziBtn.style.display = 'none'; } catch(_){ }
    try { controlsToggleBtn.style.display = 'none'; } catch(_){ }
    try { scrollWrap.style.display = 'none'; } catch(_){ }
    try { controlsSizeWrap.style.display = 'none'; } catch(_){ }

    // CLICKABLE DOOR HEADERS (open by clicking the marquee header)
    function screenToScene(x, y) {
      // Use the exact scale currently applied to the canvas (view.scale * view.globalScale)
      const s = (Number(view && view.scale) || 1) * (Number(view && view.globalScale) || 1);
      const tx = Number(view && view._tx) || 0;
      const ty = Number(view && view._ty) || 0;
      const ox = Number(view && view.offsetX) || 0;
      return { x: (x - tx) / s - ox, y: (y - ty) / s };
    }
    function sceneToScreen(x, y) {
      const s = (Number(view && view.scale) || 1) * (Number(view && view.globalScale) || 1);
      const tx = Number(view && view._tx) || 0;
      const ty = Number(view && view._ty) || 0;
      const ox = Number(view && view.offsetX) || 0;
      return { x: (x + ox) * s + tx, y: y * s + ty };
    }
    function sectionHeaderAt(sceneX, sceneY) {
      const y = world.runwayY();
      // Match drawMarquee geometry so clickable area tracks PNG scaling
      const DOOR_SCALE = Math.max(0.5, Math.min(1.5, (typeof PNG_SCALE === 'number' ? PNG_SCALE : 1)));
      for (const sec of sections) {
        const screenX = (stage.leftOffset + sec.x) - camera.x;
        const drawW = Math.round(sec.w * DOOR_SCALE);
        const drawX = Math.round(screenX - (drawW - sec.w) / 2);
        const headerTop = y - Math.round(220 * DOOR_SCALE);
        const headerBottom = y - Math.round(140 * DOOR_SCALE);
        const x1 = drawX + 18;
        const x2 = x1 + (drawW - 36);
        if (sceneX >= x1 && sceneX <= x2 && sceneY >= headerTop && sceneY <= headerBottom) return sec;
      }
      return null;
    }
    canvas.addEventListener('click', (e) => {
      if (modalWrap && modalWrap.style.display === 'grid') return; // ignore when modal open
      const pt = screenToScene(e.offsetX, e.offsetY);
      // If clicking the branding at spawn or endcap, open the external experience page
      const r1 = view._spawnBrandRect, r2 = view._endcapBrandRect;
      const inRect = (r) => r && pt.x >= r.x && pt.x <= r.x + r.w && pt.y >= r.y && pt.y <= r.y + r.h;
      if (inRect(r1) || inRect(r2)) {
        window.open('https://www.sandbox.game/en/experiences/The%20Sandbox%20-%20Fashion%20Show/e157abb3-bda0-44c5-a769-8f797f1ebbd4/page/', '_blank', 'noopener');
        return;
      }
      const sec = sectionHeaderAt(pt.x, pt.y);
      if (sec) { openModal(sec.title, sec.content); }
    });
    // Click-and-walk on the red carpet (left mouse button)
    canvas.addEventListener('mousedown', (e) => {
      if (e.button !== 0) return; // left click only
      if (modalWrap && modalWrap.style.display === 'grid') return;
      const pt = screenToScene(e.offsetX, e.offsetY);
      const y = world.runwayY();
      // Detect clicks on/near the red carpet band
      if (pt.y >= y - 8 && pt.y <= y + 28) {
        // Start walking toward current mouse X in scene space
        startMouseWalk(pt.x);
      }
    });
    // While holding, update the target as the mouse moves
    window.addEventListener('mousemove', (e) => {
      if (!mouseWalk.active) return;
      const rect = canvas.getBoundingClientRect();
      const sx = e.clientX - rect.left;
      const sy = e.clientY - rect.top;
      const pt = screenToScene(sx, sy);
      mouseWalk.targetX = pt.x; // update target; movement resolved in update()
    });
    window.addEventListener('mouseup', () => { if (mouseWalk.active) stopMouseWalk(); });
    
    // Touch support (iOS Safari): tap/hold on carpet to walk, slide to steer, lift to stop
    let activeTouchId = null;
    function getTouchById(touchList, id) {
      for (let i = 0; i < touchList.length; i++) if (touchList[i].identifier === id) return touchList[i];
      return null;
    }
    canvas.addEventListener('touchstart', (e) => {
      if (modalWrap && modalWrap.style.display === 'grid') return;
      const t = e.changedTouches && e.changedTouches[0];
      if (!t) return;
      const rect = canvas.getBoundingClientRect();
      const sx = t.clientX - rect.left;
      const sy = t.clientY - rect.top;
      const pt = screenToScene(sx, sy);
      const y = world.runwayY();
      if (pt.y >= y - 8 && pt.y <= y + 28) {
        e.preventDefault(); // prevent page scroll
        activeTouchId = t.identifier;
        startMouseWalk(pt.x);
      }
    }, { passive: false });
    window.addEventListener('touchmove', (e) => {
      if (activeTouchId == null || !mouseWalk.active) return;
      const t = getTouchById(e.changedTouches || [], activeTouchId) || (e.touches && getTouchById(e.touches, activeTouchId));
      if (!t) return;
      const rect = canvas.getBoundingClientRect();
      const sx = t.clientX - rect.left;
      const sy = t.clientY - rect.top;
      const pt = screenToScene(sx, sy);
      mouseWalk.targetX = pt.x;
      e.preventDefault();
    }, { passive: false });
    function endTouchWalk(e) {
      if (activeTouchId == null) return;
      const t = getTouchById(e.changedTouches || [], activeTouchId);
      if (t) { activeTouchId = null; stopMouseWalk(); }
    }
    window.addEventListener('touchend', endTouchWalk, { passive: true });
    window.addEventListener('touchcancel', endTouchWalk, { passive: true });
    canvas.addEventListener('mousemove', (e) => {
      const pt = screenToScene(e.offsetX, e.offsetY);
      const r1 = view._spawnBrandRect, r2 = view._endcapBrandRect;
      const inRect = (r) => r && pt.x >= r.x && pt.x <= r.x + r.w && pt.y >= r.y && pt.y <= r.y + r.h;
      const sec = sectionHeaderAt(pt.x, pt.y);
      const overBrand = inRect(r1) || inRect(r2);
      const overHeader = !!sec;
      const hover = overBrand || overHeader;
      canvas.style.cursor = hover ? 'pointer' : 'default';
      if (hover) {
        let asHtml = overBrand;
        let txt = overBrand ? "<img src=\"assets/images/fashion_show_experience.png\" alt=\"Fashion Show Experience\" style=\"display:block; max-width:220px; max-height:140px;\" />" : ("Open \"" + (sec && sec.title ? sec.title : "Section") + "\"");
        showHoverTip(e.clientX, e.clientY, txt, asHtml);
      } else {
        hideHoverTip();
      }
    });
    canvas.addEventListener('mouseleave', () => hideHoverTip());
    // MODAL
    const modalWrap = document.getElementById('modalWrap'); // Overlay element
    const modalTitle = document.getElementById('modalTitle'); // Title node inside modal
    const modalContent = document.getElementById('modalContent'); // Content container
    document.getElementById('closeModal').addEventListener('click', closeModal); // Close on button
    modalWrap.addEventListener('click', (e) => { if (e.target === modalWrap) closeModal(); }); // Close when clicking backdrop
    function openModal(title, html) { // Show modal with given title/content
      modalTitle.textContent = title; // Set title text
      modalContent.innerHTML = html; // Inject provided HTML content
      modalWrap.style.display = 'grid'; // Reveal overlay (CSS grid centers modal)
    }
    function closeModal() { // Hide the modal overlay
      modalWrap.style.display = 'none';
    }

    // Allow CTA links inside modals to cross-open sections or close
    const TROUBLESHOOTING_HTML = `
      <h4>Quick fixes (most issues)</h4>
      <ul>
        <li><b>Hard refresh:</b> Ctrl/Cmd + Shift + R</li>
        <li><b>Rotate device:</b> try landscape on mobile</li>
        <li><b>Close other tabs:</b> free a bit of memory/CPU</li>
      </ul>
      <h4>If Enter doesn’t open doors</h4>
      <ul>
        <li>Make sure the avatar is centered under the door</li>
        <li>Try the on-screen Enter button</li>
        <li>Click the page once to give it focus, then press Enter</li>
      </ul>
      <h4>If you can’t move</h4>
      <ul>
        <li>Click the page, then use ← / → or the on-screen arrows</li>
        <li>On mobile, tap the arrows; long-press to keep walking</li>
      </ul>
      <h4>If popups look cut off</h4>
      <ul>
        <li>Zoom 100% (Ctrl/Cmd + 0)</li>
        <li>On mobile, rotate to landscape</li>
      </ul>
      <h4>If it feels slow</h4>
      <ul>
        <li>Close heavy apps/tabs, then reload</li>
        <li>Older phones: give it a few seconds after load</li>
      </ul>
      <h4>Blank page or errors</h4>
      <ul>
        <li>Try another browser (Chrome/Edge recommended)</li>
        <li>Check your connection and reload</li>
      </ul>
      <h4>Need help?</h4>
      <p>Join our Discord for live support.</p>
      <div class="ctaRow">
        <a class="navBtn" href="https://discord.gg/fCMD3NkXMZ" target="_blank" rel="noopener">Join Discord</a>
        <a class="navBtn" href="#" data-close>Back to Site</a>
      </div>
    `;
    const SERVER_RULES_HTML = `
      <p><strong>Be kind, be creative, be safe.</strong></p>
      <ul>
        <li><strong>Respect first.</strong> No harassment, hate speech, or personal attacks.</li>
        <li><strong>Keep it show-safe.</strong> No NSFW, gore, or infringing content.</li>
        <li><strong>Credit creators.</strong> Share only work you own or have permission to post.</li>
        <li><strong>Stay on topic.</strong> Use the right channels (announcements, WIP, help, etc.).</li>
        <li><strong>No spam/scams.</strong> No ads, token shills, or unsolicited DMs.</li>
        <li><strong>Follow staff directions.</strong> Moderators’ decisions keep things safe and fair.</li>
      </ul>
      <p>Questions or issues? Open Ask a Question here or ping a mod in <code>#help-desk</code> once you join.</p>
      <div class="ctaRow">
        <a class="navBtn" href="https://discord.gg/fCMD3NkXMZ" target="_blank" rel="noopener">Join Discord</a>
        <a class="navBtn" href="#" data-close>Back</a>
      </div>
    `;
    const ASK_HTML = `
      <p><strong>Need help fast?</strong></p>
      <ul>
        <li><strong>Tech or setup questions:</strong> join and post in <code>#help-desk</code>.</li>
        <li><strong>Artist logistics (raffle, deadlines, specs):</strong> ask in <code>#artist-signup</code>.</li>
        <li><strong>Private matters or reports:</strong> DM a moderator once you’re in.</li>
      </ul>
      <p>If you don’t use Discord, you can still reach us at <em>[your email here]</em>.</p>
      <div class="ctaRow">
        <a class="navBtn" href="https://discord.gg/fCMD3NkXMZ" target="_blank" rel="noopener">Join Discord</a>
        <a class="navBtn" href="#" data-close>Back</a>
      </div>
    `;
    function openSectionByKey(key) {
      const sec = sections.find(s => s.key === key);
      if (sec) openModal(sec.title, sec.content);
    }
    modalContent.addEventListener('click', (e) => {
      const closeA = e.target.closest('a[data-close]');
      if (closeA) { e.preventDefault(); closeModal(); return; }
      const modalA = e.target.closest('a[data-modal]');
      if (modalA) {
        e.preventDefault();
        const which = modalA.getAttribute('data-modal');
        if (which === 'troubleshooting') openModal('Troubleshooting', TROUBLESHOOTING_HTML);
        else if (which === 'rules') openModal('Server Rules', SERVER_RULES_HTML);
        else if (which === 'ask') openModal('Ask a Question', ASK_HTML);
        return;
      }
      const a = e.target.closest('a[data-open]');
      if (a) { e.preventDefault(); openSectionByKey(a.getAttribute('data-open')); }
    });

    // Build top navigation from sections
    // Removed hidden top navigation builder for lighter runtime

    // Legend dismiss (non-persistent: always shows again on reload)
    (function setupLegendDismiss(){
      const legend = document.getElementById('legend');
      if (!legend) return;
      // Always show on page load (ignore any previous persistence)
      legend.style.display = '';
      // Clean up any old persistent flag that might have been set earlier
      try { localStorage.removeItem('legendDismissed'); } catch(_) {}
      const btn = legend.querySelector('.legendClose');
      if (btn) {
        btn.addEventListener('click', () => {
          legend.style.display = 'none';
        });
      }
    })();

    // TOOLTIP
    const tooltip = document.getElementById('tooltip'); // Tooltip element
    function showTooltip(scrX, scrY, text, openKey) { // Position and show tooltip
      tooltip.textContent = text; // Set text
      tooltip.style.left = scrX + 'px'; // Horizontal position
      tooltip.style.top = scrY + 'px'; // Vertical position
      if (openKey) {
        tooltip.dataset.openKey = openKey;
        tooltip.style.pointerEvents = 'auto';
        tooltip.style.cursor = 'pointer';
        tooltip.title = 'Click to open';
      } else {
        delete tooltip.dataset.openKey;
        tooltip.style.pointerEvents = 'none';
        tooltip.style.cursor = 'default';
        tooltip.removeAttribute('title');
      }
      tooltip.style.display = 'block'; // Make visible
    }
    function hideTooltip() {
      tooltip.style.display = 'none';
      delete tooltip.dataset.openKey;
      tooltip.style.pointerEvents = 'none';
      tooltip.style.cursor = 'default';
      tooltip.removeAttribute('title');
    } // Hide tooltip
    // Click the tooltip to open its target section (if any)
    tooltip.addEventListener('click', () => {
      const key = tooltip.dataset.openKey;
      if (key) { openSectionByKey(key); }
    });

    // Hover tip near pointer for clickable areas (headers/branding)
    const hoverTipEl = document.getElementById('hoverTip');
    function showHoverTip(scrX, scrY, text, asHtml) {
      if (!hoverTipEl) return;
      if (asHtml) hoverTipEl.innerHTML = text; else hoverTipEl.textContent = text;
      hoverTipEl.style.left = scrX + 'px';
      hoverTipEl.style.top = scrY + 'px';
      hoverTipEl.style.display = 'block';
    }
    function hideHoverTip() { if (hoverTipEl) hoverTipEl.style.display = 'none'; }

    // OPEN section when near
    // Shared proximity threshold to open a door (in px)
    const OPEN_DISTANCE = 80;

    function tryOpen() { // Attempts to open the nearest section if close
      // First: teleport if near a limo
      try {
        // Require being closer to the limo center before teleporting
        const thresh = 100;
        const leftC = Number(window.limoLeftCenterX);
        const rightC = Number(window.limoRightCenterX);
        if (Number.isFinite(leftC) && Math.abs(player.x - leftC) < thresh) {
          // teleport to the right-side spawn
          const off = Number(typeof LIMO_SPAWN_OFFSET_X === 'number' ? LIMO_SPAWN_OFFSET_X : 170);
          player.x = Math.max(world.minX, Math.min(world.maxX, (world.maxX || 6000) - off));
          return;
        }
        if (Number.isFinite(rightC) && Math.abs(player.x - rightC) < thresh) {
          const off = Number(typeof LIMO_SPAWN_OFFSET_X === 'number' ? LIMO_SPAWN_OFFSET_X : 170);
          player.x = Math.max(world.minX, Math.min(world.maxX, (world.minX || -2000) + off));
          return;
        }
      } catch(_) {}
      // Otherwise: open nearest section if close enough
      const near = nearestSection(); // Find nearest
      if (near && near.dist < OPEN_DISTANCE) openModal(near.sec.title, near.sec.content); // Open if within threshold
    }

    function nearestSection() { // Returns nearest section to player.x
      let best = null; let bestDist = Infinity; let which = null; // Track best match
      for (const sec of sections) { // Check each section
        const center = stage.leftOffset + sec.x + sec.w/2; // Section center x (shifted by stage offset)
        const d = Math.abs(center - player.x); // Distance to player
        if (d < bestDist) { bestDist = d; which = sec; } // Keep if nearer
      }
      return which ? { sec: which, dist: bestDist } : null; // Return object or null
    }

    // DRAW helpers
    function drawSpotlights() { // Moving soft spotlights to mimic stage lights (warm tone)
      const baseY = world.runwayY() - 180; // Height above runway
      const t = performance.now() * 0.001; // Time in seconds
      // Anchor to visual screen center; compensate for scene nudge so lights stay centered
      const centerX = vw * 0.5 - (view.offsetX || 0);
      const spacing = 240; // distance between spot centers
      const amp = 60;      // side-to-side oscillation amplitude
      const rx = 180, ry = 36; // ellipse radii
      const altDrop = 46;  // vertical drop for every other spotlight
      for (let i = -2; i <= 2; i++) { // Create multiple spot ellipses
        const cx = centerX + i * spacing + Math.sin(t + i) * amp;
        const cy = baseY + (Math.abs(i) % 2 ? altDrop : 0); // stagger alternate lights lower
        ctx.fillStyle = 'rgba(255,220,180,0.06)'; // Warm white
        ctx.beginPath();
        ctx.ellipse(cx, cy, rx, ry, 0, 0, Math.PI*2); // Wide, shallow ellipse
        ctx.fill();
      }
    }

    function drawCurtains() { // Big red curtains framing the stage
      const topH = Math.max(60, world.runwayY() - (220 + CURTAIN_LIFT)); // Height of top valance (raised)
      // Extend width beyond screen so edges are never visible when zoomed out
      const s = Number(view && view.scale) > 0 ? Number(view.scale) : 1;
      const bleed = Math.max(200, Math.ceil((1/s - 1) * vw) + 200); // extra draw width on both sides
      const fullW = vw + bleed * 2;
      // Top valance with scalloped bottom edge
      const grdTop = ctx.createLinearGradient(0, 0, 0, topH);
      grdTop.addColorStop(0, '#7e0a16');
      grdTop.addColorStop(1, '#d0142e');
      ctx.fillStyle = grdTop;
      ctx.beginPath();
      ctx.moveTo(-bleed, 0);
      ctx.lineTo(vw + bleed, 0);
      ctx.lineTo(vw + bleed, topH);
      // scallops along the bottom across extended width
      const scallops = 8; const amp = 16; const baseY = topH - 8;
      for (let i = scallops; i >= 0; i--) {
        const x = (i / scallops) * fullW - bleed;
        const cx = x + fullW / scallops / 2;
        const y = baseY + Math.sin(i) * 2; // tiny irregularity
        ctx.quadraticCurveTo(cx, baseY + amp, x - 1, y);
      }
      ctx.closePath();
      ctx.fill();

      // Extend valance far beyond the top so no background shows when zoomed/panned
      const extraTop = Math.max(800, Math.ceil((Number(view && view._ty) || 0) + 400));
      if (extraTop > 0) {
        ctx.fillStyle = grdTop;
        ctx.fillRect(-bleed, -extraTop, vw + bleed * 2, extraTop);
      }

      // Subtle vertical fold texture on the top valance
      ctx.save();
      // Clip to the same valance shape
      ctx.beginPath();
      ctx.moveTo(-bleed, 0);
      ctx.lineTo(vw + bleed, 0);
      ctx.lineTo(vw + bleed, topH);
      const scallops2 = 8; const amp2 = 16; const baseY2 = topH - 8;
      for (let i = scallops2; i >= 0; i--) {
        const x = (i / scallops2) * fullW - bleed;
        const cx = x + fullW / scallops2 / 2;
        const y = baseY2 + Math.sin(i) * 2;
        ctx.quadraticCurveTo(cx, baseY2 + amp2, x - 1, y);
      }
      ctx.closePath();
      ctx.clip();

      // Very subtle vertical folds for texture (low alpha, half-pixel to reduce shimmer)
      ctx.strokeStyle = 'rgba(0,0,0,0.18)';
      ctx.lineWidth = 1;
      for (let x = -bleed + 12; x < vw + bleed - 12; x += 26) {
        const x1 = Math.round(x) + 0.5;
        ctx.beginPath(); ctx.moveTo(x1, 2); ctx.lineTo(x1 - 4, topH - 2); ctx.stroke();
      }
      ctx.strokeStyle = 'rgba(255,255,255,0.06)';
      for (let x = -bleed + 24; x < vw + bleed - 12; x += 26) {
        const x1 = Math.round(x) + 0.5;
        ctx.beginPath(); ctx.moveTo(x1, 2); ctx.lineTo(x1 - 4, topH - 2); ctx.stroke();
      }
      ctx.restore();

      // Side curtains
      const sideW = 120; const sideH = Math.max(120, world.runwayY() - 80);
      const grdSide = ctx.createLinearGradient(0, 0, sideW, 0);
      grdSide.addColorStop(0, '#660812');
      grdSide.addColorStop(0.5, '#c4122b');
      grdSide.addColorStop(1, '#8f0d1b');

      // Left (extend beyond screen)
      ctx.fillStyle = grdSide;
      ctx.fillRect(-bleed, -extraTop, sideW + bleed, sideH + extraTop);
      // Right (mirror)
      const grdSideR = ctx.createLinearGradient(vw - sideW, 0, vw, 0);
      grdSideR.addColorStop(0, '#8f0d1b');
      grdSideR.addColorStop(0.5, '#c4122b');
      grdSideR.addColorStop(1, '#660812');
      ctx.fillStyle = grdSideR;
      ctx.fillRect(vw - sideW, -extraTop, sideW + bleed, sideH + extraTop);

      // Fold lines on side curtains
      ctx.strokeStyle = 'rgba(0,0,0,0.25)';
      ctx.lineWidth = 1.2;
      for (let x = 12; x < sideW; x += 16) {
        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x - 4, sideH); ctx.stroke();
      }
      for (let x = vw - sideW + 4; x < vw - 4; x += 16) {
        ctx.beginPath(); ctx.moveTo(x, 0); ctx.lineTo(x + 4, sideH); ctx.stroke();
      }

      // (branding moved to spawn area; old top placement disabled)
    }

    function drawRunway() { // Draw runway, edges, and center stripes
      const y = world.runwayY(); // Y coordinate for runway
      const w = world.runwayW(); // Visual runway width (currently not used directly)
      // edges (dark floor beyond runway) — extend beyond screen edges like curtains
      ctx.fillStyle = '#1b1b24';
      {
        const s = Number(view && view.scale) > 0 ? Number(view.scale) : 1;
        const bleed = Math.max(400, Math.ceil((1/s - 1) * vw) + 400);
        ctx.fillRect(-bleed, y + 18, vw + bleed*2, vh - y); // Large rect covering bottom area
      }
      // Overlay a subtle gradient and ensure it reaches the bottom edge
      {
        const sCombined = ((Number(view && view.scale) || 1) * (Number(view && view.globalScale) || 1));
        const bleed2 = Math.max(400, Math.ceil((1/sCombined - 1) * vw) + 400);
        const yTop2 = y + 12;
        const overBottom2 = 300;
        const g2 = ctx.createLinearGradient(0, yTop2, 0, vh + overBottom2);
        g2.addColorStop(0.00, '#1b1b24');
        g2.addColorStop(0.50, '#151820');
        g2.addColorStop(1.00, '#0d0f14');
        ctx.fillStyle = g2;
        ctx.fillRect(-bleed2, yTop2, vw + bleed2*2, (vh + overBottom2) - yTop2);
      }
      // Rope stanchions along the carpet sides (draw BEFORE carpet so carpet is in front)
      const postStep = 140; // distance between posts
      const topY = y - 6;   // near top edge of carpet
      const botY = y + 28;  // near bottom edge of carpet
      const gold = getComputedStyle(document.documentElement).getPropertyValue('--runway-edge') || '#f1cf63';

      // Build screen-space openings where rope should not cross
      const openings = [];
      for (const sec of sections) {
        const left = (stage.leftOffset + sec.x) - camera.x + 18; // just inside left pillar (shifted stage)
        const right = (stage.leftOffset + sec.x) - camera.x + sec.w - 18; // just inside right pillar
        if (right < -50 || left > vw + 50) continue; // skip off-screen
        openings.push({ left, right });
      }
      // Also block posts/ropes from the start up through the limo's right edge
      let limoGapRight = null; // expose for rope segment suppression below
      let rightLimoGapLeft = null; // left boundary of the right-side limo gap
      if (limoReady && limoImg && limoImg.naturalWidth) {
        const isSmallScreenLR = (vw < 900) || (vh < 600);
        const targetHLR = Math.min(448, Math.max(80, Math.floor(vh * (isSmallScreenLR ? 0.22 : 0.18) * 1.6)));
        const scaleLR = targetHLR / limoImg.naturalHeight;
        const dwLR = Math.max(20, Math.round(limoImg.naturalWidth * scaleLR));
        const centerWorldXLR = (world && typeof world.minX === 'number' ? world.minX : -2000);
        const extraLeftLR = 20; // keep aligned with drawLimoLeft
        const worldXLR = Math.floor(centerWorldXLR - dwLR / 2 - extraLeftLR);
        const screenLeftLR = Math.floor(worldXLR - camera.x);
        const padLR = 24;
        const rightEdge = screenLeftLR + dwLR + padLR;
        limoGapRight = rightEdge; // remember the right boundary of the limo gap
        // One large opening that removes any posts/rope on or before the limo
        openings.push({ left: -100000, right: rightEdge });

        // Mirror calculation for the right-side limo: create an opening from its left edge onward
        const centerWorldXR = (world && typeof world.maxX === 'number' ? world.maxX : 6000);
        const worldXR = Math.floor(centerWorldXR - dwLR / 2 + 20);
        const screenLeftR = Math.floor(worldXR - camera.x);
        const leftEdgeR = screenLeftR - padLR;
        rightLimoGapLeft = leftEdgeR;
        openings.push({ left: leftEdgeR, right: 100000 });
      }

      let prevX_rope = null;
      const OVERSCAN = 220;
      for (let sx = -((camera.x % postStep) + postStep) - OVERSCAN; sx < vw + postStep + OVERSCAN; sx += postStep) {
        const insideOpening = openings.some(o => sx > o.left && sx < o.right);
        // Posts: small vertical poles with a gold cap
        ctx.strokeStyle = '#3a2a2a';
        ctx.lineWidth = 3;
        if (!insideOpening) {
          // top row post (audience side only; no near-side post)
          ctx.beginPath(); ctx.moveTo(sx, topY - 2); ctx.lineTo(sx, topY - 18); ctx.stroke();
          // cap
          ctx.fillStyle = gold;
          ctx.beginPath(); ctx.arc(sx, topY - 20, 3, 0, Math.PI*2); ctx.fill();
        }

        // ropes between this and previous post (slight sag), clipped to openings
        if (prevX_rope !== null) {
          let segments = [[prevX_rope, sx]]; // list of drawable segments
          for (const o of openings) {
            const afterCut = [];
            for (const seg of segments) {
              let a = seg[0], b = seg[1];
              const L = o.left, R = o.right;
              const leftX = Math.min(a,b), rightX = Math.max(a,b);
              if (rightX <= L || leftX >= R) { afterCut.push([a,b]); continue; }
              // Intersection exists: keep parts outside [L,R]
              if (leftX < L) afterCut.push([a < b ? leftX : leftX, a < b ? L : L]);
              if (rightX > R) afterCut.push([a < b ? R : R, a < b ? rightX : rightX]);
            }
            segments = afterCut;
          }
          // Draw remaining segments
          ctx.strokeStyle = gold;
          ctx.lineWidth = 1.6;
          for (const seg of segments) {
            const a = seg[0], b = seg[1];
            if (Math.abs(b - a) < 6) continue; // too short to see
            // Suppress the tiny rope run that starts exactly at the carpet start (limo gap)
            if (limoGapRight != null && Math.min(a, b) <= limoGapRight + 2) continue;
            const midX = (a + b) / 2;
            // top rope (far/audience side only)
            ctx.beginPath();
            ctx.moveTo(a, topY - 18);
            ctx.quadraticCurveTo(midX, topY - 12, b, topY - 18);
            ctx.stroke();
          }
        }
        prevX_rope = sx;
      }
      // runway (red carpet strip)
      ctx.shadowColor = 'rgba(255,180,180,0.35)'; // Soft warm glow
      ctx.shadowBlur = 24;
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--runway'); // Use CSS variable
      // Leave gaps under both limos so they sit BEFORE the catwalk (no carpet under limos)
      if (limoReady && limoImg && limoImg.naturalWidth) {
        const isSmallScreenLR2 = (vw < 900) || (vh < 600);
        const targetHLR2 = Math.min(448, Math.max(80, Math.floor(vh * (isSmallScreenLR2 ? 0.22 : 0.18) * 1.6)));
        const scaleLR2 = targetHLR2 / limoImg.naturalHeight;
        const dwLR2 = Math.max(20, Math.round(limoImg.naturalWidth * scaleLR2));
        const padLR2 = 24;
        // Left limo gap right edge
        const leftCenter = (world && typeof world.minX === 'number' ? world.minX : -2000);
        const leftWorldX = Math.floor(leftCenter - dwLR2 / 2 - 20);
        const leftGapRight = Math.floor(leftWorldX - camera.x) + dwLR2 + padLR2;
        // Right limo gap left edge
        const rightCenter = (world && typeof world.maxX === 'number' ? world.maxX : 6000);
        const rightWorldX = Math.floor(rightCenter - dwLR2 / 2 + 20);
        const rightGapLeft = Math.floor(rightWorldX - camera.x) - padLR2;
        const fullStart = -2000;
        const fullEnd = vw + 2000;
        const drawL = Math.max(fullStart, leftGapRight);
        const drawR = Math.min(fullEnd, rightGapLeft);
        if (drawR > drawL) ctx.fillRect(drawL, y - 2, drawR - drawL, 24);
      } else {
        ctx.fillRect(-2000, y - 2, vw + 4000, 24); // full strip when no limo computed
      }
      ctx.shadowBlur = 0; // Reset shadow

      // center studs (small gold circles like carpet tacks)
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--runway-edge'); // Gold
      const studsGap = (() => {
        if (limoReady && limoImg && limoImg.naturalWidth) {
          const isSmallScreenLR3 = (vw < 900) || (vh < 600);
          const targetHLR3 = Math.min(448, Math.max(80, Math.floor(vh * (isSmallScreenLR3 ? 0.22 : 0.18) * 1.6)));
          const scaleLR3 = targetHLR3 / limoImg.naturalHeight;
          const dwLR3 = Math.max(20, Math.round(limoImg.naturalWidth * scaleLR3));
          const leftCenter3 = (world && typeof world.minX === 'number' ? world.minX : -2000);
          const leftX3 = Math.floor(leftCenter3 - dwLR3 / 2 - 20);
          const left = Math.floor(leftX3 - camera.x) - 24;
          const leftRight = left + dwLR3 + 48;
          const rightCenter3 = (world && typeof world.maxX === 'number' ? world.maxX : 6000);
          const rightX3 = Math.floor(rightCenter3 - dwLR3 / 2 + 20);
          const rightLeft = Math.floor(rightX3 - camera.x) - 24;
          return { leftStop: leftRight, rightStop: rightLeft, ok: true };
        }
        return { ok: false };
      })();
      for (let x = -((camera.x % 80)+80) - 200; x < vw + 80 + 200; x += 80) {
        // Skip studs left of left gap and right of right gap
        if (studsGap.ok && x < studsGap.leftStop) continue;
        if (studsGap.ok && x > studsGap.rightStop) continue;
        ctx.beginPath();
        ctx.arc(x, y + 26, 2.2, 0, Math.PI*2);
        ctx.fill();
      }

      // (No special first post — all posts are uniform)

      // (rope was drawn before carpet)
    }

    // Backstage props spanning the whole back wall (behind doors)
    function drawBackstageProps() {
      if (!(statueReady || chairReady)) return;
      // Hide in portrait; backstage props look cramped on tall screens
      const isPortrait = vh > vw;
      if (isPortrait) return;
      const y = world.runwayY(); // floor baseline
      // Leave space near side curtains
      const sideMargin = 140; // keep a bit of gap from side curtains
      const left = -0 + sideMargin;
      const right = vw - sideMargin;
      if (right <= left) return;
      const items = ['statue','chair','chair','chair','statue'];
      const n = items.length;
      const availableW = right - left;
      // Pull items a bit closer together by shrinking the group width
      const groupScale = 0.82; // 18% tighter spacing
      const groupW = availableW * groupScale;
      const groupLeft = left + (availableW - groupW) / 2;
      // Drop props by 100px to help landscape layouts on phones
      const baseline = Math.floor(y - 54);
      for (let i = 0; i < n; i++) {
        const kind = items[i];
        const img = (kind === 'statue') ? (statueReady ? statueImg : null) : (chairReady ? chairImg : null);
        if (!img) continue;
        // Target heights tuned for balance under the valance (bigger)
        const maxH = Math.max(60, Math.min(260, Math.round(vh * (kind === 'statue' ? 0.28 : 0.20))));
        const scale = maxH / img.naturalHeight;
        const w = Math.max(1, Math.round(img.naturalWidth * scale * PNG_SCALE));
        const h = Math.max(1, Math.round(img.naturalHeight * scale * PNG_SCALE));
        const cx = groupLeft + ((i + 0.5) * (groupW / n));
        const dx = Math.round(cx - w / 2);
        const dy = Math.round(baseline - h);
        ctx.drawImage(img, dx, dy, w, h);
      }
    }

    // Limo at far left of the catwalk (world-anchored at world.minX)
    function drawLimoLeft() {
      if (!limoReady || !limoImg || !limoImg.naturalWidth) return;
      const y = world.runwayY();
      const isSmallScreen = (vw < 900) || (vh < 600);
      // 60% bigger than baseline (1.6x)
      const targetH = Math.min(448, Math.max(80, Math.floor(vh * (isSmallScreen ? 0.22 : 0.18) * 1.6)));
      const scale = targetH / limoImg.naturalHeight;
      const dw = Math.max(20, Math.round(limoImg.naturalWidth * scale * PNG_SCALE));
      const dh = Math.max(20, Math.round(limoImg.naturalHeight * scale * PNG_SCALE));
      // Place limo so that its center is slightly left of the catwalk edge; positive shift moves it further off-screen
      const centerWorldX = (world && typeof world.minX === 'number' ? world.minX : -2000);
      const extraLeft = 20; // pixels to push left from the exact edge (reduced to move it right ~100px)
      const worldX = Math.floor(centerWorldX - dw / 2 - extraLeft);
      const dx = Math.floor(worldX - camera.x);
      // Move up by 25px relative to prior; keep current natural floor contact
      const baseline = Math.floor(y + 26 + 40);
      const dy = Math.floor(baseline - dh);
      // subtle shadow
      ctx.save();
      ctx.shadowColor = 'rgba(0,0,0,0.35)';
      ctx.shadowBlur = 12;
      ctx.drawImage(limoImg, dx, dy, dw, dh);
      ctx.restore();
      // Expose world-space center for interactions
      try { window.limoLeftCenterX = centerWorldX; } catch(_) {}
    }

    // Limo at far right of the catwalk (mirrored)
    function drawLimoRight() {
      if (!limoReady || !limoImg || !limoImg.naturalWidth) return;
      const y = world.runwayY();
      const isSmallScreen = (vw < 900) || (vh < 600);
      // Same scale as left limo
      const targetH = Math.min(448, Math.max(80, Math.floor(vh * (isSmallScreen ? 0.22 : 0.18) * 1.6)));
      const scale = targetH / limoImg.naturalHeight;
      const dw = Math.max(20, Math.round(limoImg.naturalWidth * scale * PNG_SCALE));
      const dh = Math.max(20, Math.round(limoImg.naturalHeight * scale * PNG_SCALE));
      // Anchor at the far-right world edge
      const centerWorldX = (world && typeof world.maxX === 'number' ? world.maxX : 6000);
      const extraRight = 20; // push slightly further to the right
      const worldX = Math.floor(centerWorldX - dw / 2 + extraRight);
      const dx = Math.floor(worldX - camera.x);
      const baseline = Math.floor(y + 26 + 40);
      const dy = Math.floor(baseline - dh);
      // Draw mirrored (flip horizontally around its left edge)
      ctx.save();
      ctx.translate(dx + dw, 0);
      ctx.scale(-1, 1);
      ctx.shadowColor = 'rgba(0,0,0,0.35)';
      ctx.shadowBlur = 12;
      ctx.drawImage(limoImg, 0, dy, dw, dh);
      ctx.restore();
      try { window.limoRightCenterX = centerWorldX; } catch(_) {}
    }

    function drawMarquee(sec) { // Draw an interactive marquee for a section
      const y = world.runwayY(); // Base Y
      const screenX = (stage.leftOffset + sec.x) - camera.x; // Convert world X to screen X (shifted)
      // Link door size to PNG size slider
      const DOOR_SCALE = Math.max(0.5, Math.min(1.5, (typeof PNG_SCALE === 'number' ? PNG_SCALE : 1)));
      const drawW = Math.round(sec.w * DOOR_SCALE);
      const drawX = Math.round(screenX - (drawW - sec.w) / 2); // keep door centered on its original center
      // Pillars (sides)
      ctx.fillStyle = '#2a2a36';
      ctx.fillRect(drawX, y - Math.round(220 * DOOR_SCALE), 18, Math.round(220 * DOOR_SCALE)); // Left pillar
      ctx.fillRect(drawX + drawW - 18, y - Math.round(220 * DOOR_SCALE), 18, Math.round(220 * DOOR_SCALE)); // Right pillar
      // Header panel (screen-like black box)
      const headerTop = y - Math.round(220 * DOOR_SCALE);
      const headerBottom = y - Math.round(140 * DOOR_SCALE);
      // Darker, subtle gradient for the header panel (screen-like)
      const grd = ctx.createLinearGradient(0, headerTop, 0, headerBottom);
      grd.addColorStop(0, '#0d0e12'); // near-black top
      grd.addColorStop(1, '#191a22'); // very dark bottom
      ctx.fillStyle = grd;
      ctx.fillRect(drawX + 18, headerTop, drawW - 36, Math.round(80 * DOOR_SCALE)); // Panel between pillars
      // Title text in the header
      const goldText = getComputedStyle(document.documentElement).getPropertyValue('--accent') || '#f1cf63';
      ctx.fillStyle = goldText;
      const headerFontPx = Math.max(12, Math.round(20.8 * DOOR_SCALE));
      ctx.font = '700 ' + headerFontPx + 'px system-ui'; // scale label with door
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.fillText(sec.title, drawX + drawW/2, Math.round(y - 180 * DOOR_SCALE)); // Centered label
      // Accent underglow strip
      ctx.fillStyle = getComputedStyle(document.documentElement).getPropertyValue('--accent');
      ctx.globalAlpha = 0.4; // Semi transparent
      ctx.fillRect(drawX + 20, headerBottom + 2, drawW - 40, 4); // Thin bar under header
      ctx.globalAlpha = 1; // Restore alpha

      // Flashing bulbs around clickable header panel (door button)
      (function drawHeaderLights(){
        // Round all geometry to whole pixels to avoid subpixel shimmer while panning
        const hx = Math.round(drawX + 18); // header box x
        const hy = Math.round(headerTop);    // header box y
        const hw = Math.round(drawW - 36);   // header box width
        const hh = Math.round(80 * DOOR_SCALE); // header box height
        const gold = getComputedStyle(document.documentElement).getPropertyValue('--accent') || '#f1cf63';
        ctx.save();
        // Twinkling bulbs along the frame (no outline)
        const t = performance.now() * 0.001;
        const bulbSpacing = 20;
        const sprite = ensureBulbSprite();
        const r = sprite.width >> 1; // half size
        // Bring bulbs slightly closer to the header (less up/out)
        const outside = Math.max(2, r - 6);
        ctx.globalCompositeOperation = 'screen';
        // Top edge bulbs (inside panel to avoid clipping)
        for (let x = hx + 8; x <= hx + hw - 8; x += bulbSpacing) {
          const i = Math.floor((x - hx) / bulbSpacing);
          const phase = i * 0.55;
          const pulse = Math.max(0, Math.sin(t * 3.2 + phase));
          const a = 0.16 + Math.pow(pulse, 6) * 0.84;
          // Place bulbs centered on the outside of the top edge
          const gx = Math.round(x), gy = Math.round(hy - outside);
          ctx.globalAlpha = Math.min(1, a);
          ctx.drawImage(sprite, gx - r, gy - r);
        }
        // Left/right edges bulbs (sparser) — no bottom-row bulbs to avoid clipping
        for (let y2 = hy + 12; y2 <= hy + hh - 12; y2 += bulbSpacing * 1.05) {
          const i = Math.floor((y2 - hy) / bulbSpacing);
          const phase = i * 0.6;
          const pulse = Math.max(0, Math.sin(t * 3.2 + phase));
          const a = 0.12 + Math.pow(pulse, 6) * 0.78;
          // Place bulbs centered on the outside of the left/right edges
          const gx1 = Math.round(hx - outside), gy1 = Math.round(y2);
          const gx2 = Math.round(hx + hw + outside), gy2 = Math.round(y2);
          ctx.globalAlpha = Math.min(1, a);
          ctx.drawImage(sprite, gx1 - r, gy1 - r);
          ctx.globalAlpha = Math.min(1, a * 0.9);
          ctx.drawImage(sprite, gx2 - r, gy2 - r);
        }
        ctx.globalAlpha = 1;
        ctx.restore();
      })();

      // Entrance curtains per section: fully open at center, close as you walk away
      const gold = getComputedStyle(document.documentElement).getPropertyValue('--accent') || '#f1cf63';
      const boxX = drawX + 18; const boxW = drawW - 36; // between the pillars
      // Taller curtains only on mobile landscape so header text is covered there,
      // but keep desktop browsers at the original height.
      const isMobileLandscape = (vw > vh) && IS_TOUCH;
      // Keep curtains above the red carpet (stop right at carpet top)
      const curtainBottomY = Math.floor(world.runwayY() - 2);
      // Overlap the header slightly so curtains cover the seam, but sit a bit lower
      const CURTAIN_OVERLAP = 12; // pixels into header area (reduced to lower curtains)
      const boxTop = headerBottom - CURTAIN_OVERLAP; // raise top a bit into the header
      const boxH = Math.max(12, curtainBottomY - boxTop); // extend down to carpet edge

      // Backdrop image behind the curtains (visible through the opening)
      // Prefer per-door backdrop if available, otherwise fall back to the default image
      const bi = sec._backdropIndex;
      const setEntry = (bi && doorBackdropSet && doorBackdropSet[bi] && doorBackdropSet[bi].ready) ? doorBackdropSet[bi] : null;
      const useImg = setEntry ? setEntry.img : (doorBackdropReady ? doorBackdropImg : null);
      if (useImg && useImg.naturalWidth) {
        ctx.save();
        // Clip to the area between pillars; align the top exactly to the curtain top
        // so the backdrop image overlaps up to the seam and no gap is visible
        ctx.beginPath();
        const CLIP_TOP = Math.floor(boxTop); // align with curtain top to avoid visible gap
        const CLIP_H = Math.max(1, curtainBottomY - CLIP_TOP);
        ctx.rect(boxX, CLIP_TOP, boxW, CLIP_H);
        ctx.clip();
        // Cover-fit the image within the box, preserving aspect ratio
        const iw = useImg.naturalWidth;
        const ih = useImg.naturalHeight;
        const baseScale = Math.max(boxW / iw, boxH / ih);
        const scale = baseScale * Math.max(1, PNG_SCALE);
        const dw = Math.ceil(iw * scale);
        const dh = Math.ceil(ih * scale);
        const dx = Math.floor(boxX + (boxW - dw) / 2);
        const dy = Math.floor(boxTop + (boxH - dh) / 2);
        // Slight overscan to guarantee no slivers at the edges when scaled/rounded
        const OVERSCAN_IMG = 12; // pixels
        ctx.drawImage(useImg, dx - OVERSCAN_IMG, dy - OVERSCAN_IMG, dw + OVERSCAN_IMG*2, dh + OVERSCAN_IMG*2);

        ctx.restore();
      }
      const centerXWorld = stage.leftOffset + sec.x + sec.w/2; // world center with stage offset
      const dist = Math.abs(player.x - centerXWorld); // distance from player to center
      // Scale opening radius with zoom so curtains don't open too early when zoomed in
      const radius = 220 * Math.max(1, Number(view && view.scale) || 1); // distance at which curtains fully closed
      const open = Math.max(0, Math.min(1, 1 - dist / radius)); // 0..1
      const minCurtain = 10; // min width of each curtain when fully open
      const overlap = 6; // small overlap so no sliver shows through
      const gap = Math.max(0, open * (boxW - minCurtain*2) - overlap);
      const half = boxW / 2;
      const leftRight = boxX + half - gap/2; // right edge of left curtain
      const rightLeft = boxX + half + gap/2; // left edge of right curtain

      // Curtain gradients (deep red)
      const redL = ctx.createLinearGradient(boxX, boxTop, boxX + half, boxTop);
      redL.addColorStop(0, '#660812'); redL.addColorStop(0.5, '#c4122b'); redL.addColorStop(1, '#8f0d1b');
      const redR = ctx.createLinearGradient(boxX + half, boxTop, boxX + boxW, boxTop);
      redR.addColorStop(0, '#8f0d1b'); redR.addColorStop(0.5, '#c4122b'); redR.addColorStop(1, '#660812');

      // Left curtain
      ctx.fillStyle = redL;
      ctx.fillRect(boxX, boxTop, Math.max(minCurtain, leftRight - boxX), boxH);
      // Right curtain
      ctx.fillStyle = redR;
      ctx.fillRect(rightLeft, boxTop, Math.max(minCurtain, boxX + boxW - rightLeft), boxH);

      // Fold lines for gentle curtain texture (aligned to half-pixels to avoid flicker)
      (function drawFoldLines(){
        const y1 = Math.round(boxTop) + 0.5;
        const y2 = Math.round(boxTop + boxH) + 0.5;
        ctx.strokeStyle = 'rgba(0,0,0,0.22)';
        ctx.lineWidth = 1;
        for (let x = Math.ceil(boxX + 8); x < leftRight; x += 14) {
          const x1 = Math.round(x) + 0.5;
          const x2 = Math.round(x - 3) + 0.5;
          ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();
        }
        for (let x = Math.ceil(rightLeft + 4); x < boxX + boxW - 4; x += 14) {
          const x1 = Math.round(x) + 0.5;
          const x2 = Math.round(x + 3) + 0.5;
          ctx.beginPath(); ctx.moveTo(x1, y1); ctx.lineTo(x2, y2); ctx.stroke();
        }
      })();

      // (Removed gold tiebacks to avoid visual confusion)
      // Instruction bubble if player is close — position just above the avatar's head
      const d = Math.abs(player.x - (stage.leftOffset + sec.x + sec.w/2)); // Distance from player to center
      // Only show the hint when you're firmly inside the open zone
      if (d < Math.max(10, (OPEN_DISTANCE - 10))) { // a little tighter than open distance
        // Anchor tooltip near the avatar's feet (runway level), so it hovers around the shoes
        const footSceneX = (player.x - camera.x) + 16; // player center column
        const footSceneY = y - 6; // just above the carpet baseline
        const pt = sceneToScreen(footSceneX, footSceneY);
        showTooltip(Math.round(pt.x), Math.round(pt.y), 'Press Up or Enter to open', sec.key);
      }
    }
    

    function drawPlayer() { // Avatar (sprite sheet if available; fallback to blocky)
      // Raise the avatar 5px to better center on the catwalk
      const baseY = world.runwayY() - 5;           // Ground baseline (nudged up)
      const px = player.x - camera.x;               // Player X on screen
      const facing = player.facing || 1;            // 1 or -1

      // Shadow
      ctx.fillStyle = 'rgba(0,0,0,0.35)';
      ctx.beginPath();
      // Nudge shadow up a bit to sit tighter under the feet
      ctx.ellipse(px + 16, baseY + 14, 22, 6, 0, 0, Math.PI*2);
      ctx.fill();

      // Prefer sprite sheet rendering when available
      if (AVATAR && AVATAR.ready) {
        const seq = AVATAR.seq[player.anim && player.anim.key] || AVATAR.seq.idleRight;
        const frame = (player.anim && Number.isFinite(player.anim.frame)) ? (player.anim.frame % seq.len) : 0;
        const sx = frame * AVATAR.fw;
        const sy = seq.row * AVATAR.fh;

        // Scale sprite relative to viewport so the figure reads well on all screens
        const isSmallScreen = (vw < 900) || (vh < 600);
        const targetHBase = Math.max(80, Math.min(160, Math.floor(vh * 0.26)));
        const targetH = isSmallScreen ? Math.floor(targetHBase * 1.05) : targetHBase;
        const targetHScaled = Math.floor(targetH * (AVATAR.sizeMul || 1) * PNG_SCALE);
        const scale = targetHScaled / AVATAR.fh;
        const dw = Math.floor(AVATAR.fw * scale);
        const dh = Math.floor(AVATAR.fh * scale);

        // Center on player column; anchor feet to carpet
        const dx = Math.floor(px + 16 - dw / 2);
        // Anchor the soles to the carpet using footInset pixels from bottom of source frame
        let dy = Math.floor(baseY - (dh - Math.floor((AVATAR.footInset||0) * scale)));
        // Apply screen-space nudge to push the sprite down/up relative to the carpet
        dy += Math.floor(AVATAR.yNudge || 0);

        // Draw with crisp pixels if the art is low-res
        const prevSmooth = ctx.imageSmoothingEnabled;
        ctx.imageSmoothingEnabled = false;
        ctx.drawImage(AVATAR.img, sx, sy, AVATAR.fw, AVATAR.fh, dx, dy, dw, dh);
        ctx.imageSmoothingEnabled = prevSmooth;
        return; // sprite drawn; skip fallback
      }

      // Minimal placeholder if sprite fails (sprite-only)
      ctx.fillStyle = '#e6e9ef';
      ctx.fillRect(px + 8, baseY - 32, 16, 32);
      return;
    }
    // drawBackgroundParallax() removed (unused)

    // drawPaparazziForeground() removed (unused)

    function update(dt) { // Update simulation for one frame
      player.walking = false; // Reset walking flag
      const isRunning = (keys.runToggle || keys.shiftRun); // effective sprint: toggle OR Shift
      const runMul = isRunning ? 3.6 : 1; // sprint speed multiplier

      // When holding mouse, continuously steer based on mouse X vs avatar center
      if (mouseWalk.active && mouseWalk.targetX != null) {
        const centerScene = (player.x - camera.x) + 16;
        const d = mouseWalk.targetX - centerScene;
        const moving = (keys.left || keys.right);
        const thresh = moving ? MOUSE_DEAD_IN : MOUSE_DEAD_OUT;
        if (Math.abs(d) <= thresh) {
          // In dead zone: idle but face toward mouse side if offset exists
          keys.left = false; keys.right = false;
          if (d > 0) player.facing = 1; else if (d < 0) player.facing = -1;
        } else if (d > thresh) {
          keys.left = false; keys.right = true; player.facing = 1;
        } else if (d < -thresh) {
          keys.left = true; keys.right = false; player.facing = -1;
        }
      }
      if (keys.left)  { player.x -= world.speed * runMul * 60 * dt; player.facing = -1; player.walking = true; } // Move left
      if (keys.right) { player.x += world.speed * runMul * 60 * dt; player.facing = 1;  player.walking = true; } // Move right
      player.x = Math.max(world.minX, Math.min(world.maxX, player.x)); // Clamp player within world bounds
      if (player.walking) player.t += dt * (isRunning ? 3.0 : 1); else player.t *= 0.8; // Faster gait when running

      // Update avatar sprite animation (idle/walk + facing)
      if (!player.anim) player.anim = { key: 'idleRight', frame: 0, accum: 0 };
      const prevKey = player.anim.key;
      let nextKey;
      if (player.walking) {
        if (isRunning && AVATAR && AVATAR.seq && (AVATAR.seq.sprintRight && AVATAR.seq.sprintLeft)) {
          nextKey = (player.facing === 1) ? 'sprintRight' : 'sprintLeft';
        } else {
          nextKey = (player.facing === 1) ? 'walkRight' : 'walkLeft';
        }
      } else {
        nextKey = (player.facing === 1) ? 'idleRight' : 'idleLeft';
      }
      if (nextKey !== prevKey) { player.anim.key = nextKey; player.anim.accum = 0; player.anim.frame = 0; }
      const seq = (AVATAR && AVATAR.seq[player.anim.key]) ? AVATAR.seq[player.anim.key] : { len: 1, fps: 1 };
      player.anim.accum += dt * seq.fps;
      player.anim.frame = Math.floor(player.anim.accum) % seq.len;

      // camera follows with smoothing, while keeping player on-screen with margins
      // Bias a bit more to the left so the camera pans left sooner (shows more of left side)
      const baseTarget = player.x - vw * 0.55;
      // Screen margin constraints (pixels) accounting for scene nudge
      const margin = { left: 60, right: 60 };
      const pxNudge = (view.offsetX || 0);
      const lowerBound = player.x + pxNudge - (vw - margin.right); // min camera.x so player not off right
      const upperBound = player.x + pxNudge - margin.left;          // max camera.x so player not off left
      // World bounds for camera, using extended walk space
      const worldMin = world.minX;
      const worldMax = Math.max(0, world.maxX - vw);
      // Valid camera range intersection
      const camMin = Math.max(worldMin, lowerBound);
      const camMax = Math.min(worldMax, upperBound);
      // Clamp target into valid range
      let target = Math.max(camMin, Math.min(camMax, baseTarget));
      camera.x += (target - camera.x) * 0.12; // Ease camera towards target
      // Hard-ensure player remains within on-screen margins after easing
      const playerScreenX = player.x - camera.x;
      if (playerScreenX < margin.left) {
        camera.x = player.x - margin.left;
      } else if (playerScreenX > (vw - margin.right)) {
        camera.x = player.x - (vw - margin.right);
      }
      // Clamp to world bounds
      camera.x = Math.max(worldMin, Math.min(worldMax, camera.x));
    }

    let last = performance.now(); // Timestamp of previous frame
    function frame(now) { // Main animation loop
      const dt = Math.min(0.05, (now - last) / 1000); // Delta time in seconds (clamped)
      last = now; // Store current time for next frame
      update(dt); // Step the simulation

      // Clear entire canvas in device pixels regardless of transform
      ctx.save();
      ctx.setTransform(1,0,0,1,0,0);
      ctx.clearRect(0, 0, canvas.width, canvas.height);
      ctx.restore();

      // Apply view zoom (uniform scale) with slight upward bias on zoom-out
      const baseScale = Number(view.baseScale) || 1.5;
      const s0 = Number(view.scale) > 0 ? Number(view.scale) : baseScale;
      const g = Number(view.globalScale) > 0 ? Number(view.globalScale) : 1;
      const s = s0 * g; // apply global scale-down (e.g., 0.7 for ~30% smaller)
      const minS = (Number(window.zoomMinScale || 0.6)) * g;
      const xAnchor = vw * 0.5;           // anchor horizontally at screen center
      const yAnchor = world.runwayY();    // anchor vertically at runway
      const tx = xAnchor * (1 - s);
      const zoomOut = Math.max(0, Math.min(1, (baseScale - s) / Math.max(0.0001, baseScale - minS)));
      const tyCenter = yAnchor * (1 - s);
      const extraUp = 160 * zoomOut;      // move scene up as you zoom out (more headroom above doors)
      const tyCap = -yAnchor * 0.92;      // do not overshoot the very top
      // Apply additional manual lift from slider (move scene DOWN to reveal more of the TOP)
      // Positive values shift the scene downward; clamp to a max of +250px
      const lift = Math.max(0, Math.min(250, Number(view.yLift) || 0));
      const ty = Math.max(tyCap, Math.min(250, (tyCenter - extraUp) + lift));
      view._tx = tx; view._ty = ty; // expose current transform for input mapping
      ctx.setTransform(DPR * s, 0, 0, DPR * s, DPR * tx, DPR * ty);
      // Optional extra nudge (not used by default; stage.leftOffset handles layout)
      if (view.offsetX) ctx.translate(view.offsetX, 0);

      // ambient background with subtle marble texture
      const bgCol = getComputedStyle(document.documentElement).getPropertyValue('--bg') || '#12090c';
      const OVERSCAN = 220; // extend drawing beyond edges to avoid slivers at 100% zoom
      ctx.fillStyle = bgCol;
      ctx.fillRect(-OVERSCAN, -OVERSCAN, vw + OVERSCAN*2, vh + OVERSCAN*2);
      if (marbleTex) {
        ctx.save();
        ctx.globalAlpha = 0.55; // slightly stronger to keep marble visible
        // Draw with overscan so edges never reveal gaps
        ctx.drawImage(marbleTex, -OVERSCAN, -OVERSCAN, vw + OVERSCAN*2, vh + OVERSCAN*2);
        ctx.restore();
      }

      // drawBackgroundParallax(); // Disabled to remove tiny background speckle dots
      
      drawCurtains();           // Big red curtains framing the stage
      drawSpotlights();         // Moving soft lights (in front of curtains)

      drawRunway();             // Ground and runway
      drawLimoLeft();           // Limo at far left edge
      drawLimoRight();          // Limo at far right edge (mirrored)
      drawBackstageProps();     // Statues and chairs across the back wall

      // Draw branding/billboard in front of backstage props
      drawSpawnBranding();      // Branding at spawn, stays put as you walk away
      drawEndcapBranding(ENDCAP_X); // Second branding after last door for a visual endcap
      if (window.paparazziOn !== false) drawPaparazziStrip(); // PNG robots row
      // world-anchored positioning removed; controls live in Settings only

      // sections
      hideTooltip(); // Hide tooltip before possibly showing it for a nearby section
      for (const sec of sections) { // Render visible marquees
        const scrX = (stage.leftOffset + sec.x) - camera.x; // Screen x for culling (shifted)
        if (scrX + sec.w < -50 || scrX > vw + 50) continue; // Skip if far off-screen
        drawMarquee(sec); // Draw this marquee
      }
      
       // Foreground silhouettes and flashes (behind player)
      drawPlayer(); // Draw the model/figure

      // edge fades to soften edges (disabled by default to avoid visible side bands)
      const bgCol2 = getComputedStyle(document.documentElement).getPropertyValue('--bg') || '#12090c';
      const isLandscape = vw > vh;
      if (view.edgeFades && (!isLandscape || view.edgeFadesInLandscape)) {
        ctx.save();
        if (view.offsetX) ctx.translate(-view.offsetX, 0); // undo scene nudge for fades
        const g = ctx.createLinearGradient(0,0,80,0); g.addColorStop(0,bgCol2); g.addColorStop(1,'transparent'); // Left fade
        ctx.fillStyle = g; ctx.fillRect(0,0,80,vh);
        const g2 = ctx.createLinearGradient(vw,0,vw-80,0); g2.addColorStop(0,bgCol2); g2.addColorStop(1,'transparent'); // Right fade
        ctx.fillStyle = g2; ctx.fillRect(vw-80,0,80,vh);
        ctx.restore();
      }

      requestAnimationFrame(frame); // Queue next frame
    }
    requestAnimationFrame(frame); // Kick off animation loop
  })(); // End IIFE
  </script>
  <!-- Background music: loops and autoplays; volume controlled via settings -->
  <audio id="bgAudio" preload="auto" loop muted playsinline></audio>
  <script>
    (function () {
      const audio = document.getElementById('bgAudio');
      if (!audio) return;
      let ctx = null, source = null, gain = null;
      const clamp = (v,min,max)=>Math.max(min,Math.min(max,v));
      // Provide multiple sources with fallback; browsers pick the first playable/available
      function chooseAudioSource() {
        try {
          // Order: MP3 (Chrome/Android/iOS), M4A (iOS Safari), OGG (Firefox/Chrome desktop)
          const candidates = [
            { src: 'assets/sounds/fashion_show_song_0.mp3', type: 'audio/mpeg' },
            { src: 'assets/sounds/fashion_show_song_0.m4a', type: 'audio/mp4' },
            { src: 'assets/sounds/fashion_show_song_0.ogg', type: 'audio/ogg' },
          ];
          audio.innerHTML = '';
          for (const c of candidates) {
            const s = document.createElement('source');
            s.src = c.src; s.type = c.type;
            audio.appendChild(s);
          }
          audio.load();
        } catch(_) {}
      }
      chooseAudioSource();
      const getPct = () => {
        const v = Number(localStorage.getItem('musicVolPct'));
        return Number.isFinite(v) ? clamp(v, 0, 150) : 50; // default 50%
      };
      const ensureGraph = () => {
        if (ctx) return;
        try { ctx = new (window.AudioContext || window.webkitAudioContext)(); } catch(_) { ctx = null; }
        // Try to build routing graph; if not possible, we will fall back to element volume
        if (ctx) {
          try { source = ctx.createMediaElementSource(audio); } catch(_) { source = null; }
          try {
            gain = ctx.createGain();
            gain.gain.value = clamp(getPct()/100, 0, 1.5);
            if (source) source.connect(gain);
            gain.connect(ctx.destination);
            // mute element's direct output to avoid double audio only if we have a routed graph
            if (source) audio.volume = 0;
          } catch(_) { ctx = null; gain = null; source = null; }
        }
        // If WebAudio not available, fallback to element volume immediately
        if (!ctx || !gain) {
          audio.volume = clamp(getPct()/100, 0, 1);
        }
      };
      function setVolumePct(pct) {
        pct = clamp(Number(pct)||0, 0, 150);
        localStorage.setItem('musicVolPct', String(pct));
        if (gain) gain.gain.value = pct/100;
        // Always set element volume as a fallback (caps at 1.0)
        audio.volume = Math.min(1, pct/100);
      }
      function wireSlider() {
        const slider = document.getElementById('musicSlider');
        const label = document.getElementById('musicLabel');
        if (!slider) return;
        slider.min = '0'; slider.max = '150'; slider.step = '1';
        const val = getPct();
        slider.value = String(val);
        if (label) label.textContent = val + '%';
        const applyVolumeFromUI = () => {
          const v = Number(slider.value)||0;
          if (label) label.textContent = v + '%';
          setVolumePct(v);
          ensureGraph();
          if (ctx && ctx.state === 'suspended') { try { ctx.resume(); } catch(_) {} }
          // Unmute and play when volume > 0 so users hear changes immediately
          if (v > 0) {
            audio.muted = false;
            // Start playback in response to this gesture
            audio.play().catch(() => {});
          } else {
            // Keep audible path at 0 but also mute element for clarity
            if (gain) gain.gain.value = 0;
            audio.muted = true;
          }
        };
        slider.addEventListener('input', applyVolumeFromUI);
        slider.addEventListener('change', applyVolumeFromUI);
      }
      const unlock = () => {
        ensureGraph();
        if (ctx && ctx.state === 'suspended') { try { ctx.resume(); } catch(_) {} }
        // Apply stored volume and unmute
        setVolumePct(getPct());
        // Only unmute if volume > 0
        audio.muted = getPct() <= 0 ? true : false;
        audio.play().catch(() => {});
      };
      // Unlock audio on first user gesture anywhere
      const once = () => { unlock(); window.removeEventListener('pointerdown', once, true); window.removeEventListener('touchstart', once, true); };
      window.addEventListener('pointerdown', once, true);
      window.addEventListener('touchstart', once, true);
      // Start muted; route through Web Audio once unlocked
      audio.volume = 0;
      audio.play().catch(() => {});
      // Use capture-phase + once so we catch the first gesture even if inner UI stops propagation
      const unlockEvents = ['pointerdown','pointerup','click','touchstart','touchend','keydown','keyup'];
      for (const ev of unlockEvents) {
        window.addEventListener(ev, unlock, { capture: true, once: true });
      }
      // Wire slider if present and expose controls for settings
      wireSlider();
      window.bgAudioControls = {
        setVolumePct,
        getVolumePct: getPct,
        wireSlider,
        ensure: ensureGraph,
        kick: () => { unlock(); }
      };
    })();
  </script>
</body>
</html>








